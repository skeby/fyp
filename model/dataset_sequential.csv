Question ID,Question Text,Option A,Option B,Option C,Option D,Correct Answer,Explanation,Concept,Difficulty,Discrimination,Guessing Probability
1,"What will the output of the below code?
        C++
        
        #include &lt;iostream&gt;
using namespace std;

int main()
{

    int arr[2] = { 1, 2 };
    cout &lt;&lt; arr[0] &lt;&lt; &quot;, &quot; &lt;&lt; arr[1] &lt;&lt; endl;
    return 0;
}

        
    
        Java
        
        public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2};
        System.out.println(arr[0] + &quot;, &quot; + arr[1]);
    }
}","1, 2",Syntax error,Run time error,None,A,"The code declares an integer array arr with two elements, 1 and 2, and then prints them as 1, 2 using cout.",Array,Easy,Medium,0.25
2,The minimum number of comparisons required to determine if an integer appears more than n/2 times in a sorted array of n integers is,Θ(n),Θ(logn),Θ(n*logn),Θ(1),B,"If you answered Theta(1), then think of examples {1, 2, 2, 2, 4, 4}, {1, 1, 2, 2, 2, 2, 3, 3} The Best way to find out whether an integer appears more than n/2 times in a sorted array(Ascending Order) of n integers, would be binary search approach.The First occurrence of an element can be found out in O(log(n)) time using divide and conquer technique,lets say it is i.The Last occurrence of an element can be found out in O(log(n)) time using divide and conquer technique,lets say it is j.Now number of occurrence of that element(count) is (j-i+1). Overall time complexity = log n +log n +1 = O(logn)See Check for Majority Element in a sorted array This solution is contributed by Nirmal Bharadwaj",Array,Hard,High,0.25
3,"An algorithm performs (logN)1/2  find operations, N insert operations, (logN)1/2 , delete operations, and (logN)1/2  decrease-key operations on a set of data items with keys drawn from a linearly ordered set. For a delete operation, a pointer is provided to the record that must be deleted. For the decrease-key operation, a pointer is provided to the record that has its key decreased. Which one of the following data structures is the most suited for the algorithm to use, if the goal is to achieve the best total asymptotic complexity considering all the operations?",Unsorted array,Min-heap,Sorted array,Sorted doubly linked list,A,"The time complexity of insert in unsorted array is O(1), O(Logn) in Min-Heap, O(n) in sorted array and sorted DLL. For unsorted array, we can always insert an element at end and do insert in O(1) timeFor Min Heap, insertion takes O(Log n) time. Refer Binary Heap operations for details. For sorted array, insert takes O(n) time as we may have to move all elements worst case. For sorted doubly linked list, insert takes O(n) time to find position of element to be inserted. Since number of insertion operations is asymptotically higher, unsorted array is preferred.",Array,Hard,High,0.25
4,Consider an array consisting of –ve and +ve numbers. What would be the worst case time complexity of an algorithm to segregate the numbers having same sign altogether i.e all +ve on one side and then all -ve on the other ?,O(N),O(N Log N),O(N * N),O(N Log Log N),A,Here we can use the partition algorithm of quick sort for segregation and answer will be O(N).,Array,Medium,High,0.25
5,"Let A[1...n] be an array of n distinct numbers. If i &lt; j and A[i] &gt; A[j], then the pair (i, j) is called an inversion of A. What is the expected number of inversions in any permutation on n elements ?",n(n-1)/2,n(n-1)/4,n(n+1)/4,2n[logn],B,"There are n(n-1)/2 pairs such that i &lt; j. For a pair (ai, aj), probability of being inversion is 1/2. Therefore expected value of inversions = 1/2 * (n(n-1)/2) = n(n-1)/4.",Array,Hard,High,0.25
6,"Consider a two dimensional array A[20][10]. Assume 4 words per memory cell, the base address of array A is 100, elements are stored in row-major order and first element is A[0][0]. What is the address of A[11][5] ?",560,460,570,575,A,"Element A[11][0] is stored at ""Base Address + 11 * 10 * 4"" which is  ""Base Address + 440"" = 540.  So A[11][5] is stored at 540 + 5*4 = 560.",Array,Medium,Medium,0.25
7,"An array A consists of n integers in locations A[0], A[1] ....A[n-1]. It is required to shift the elements of the array cyclically to the left by k places, where 1 &lt;= k &lt;= (n-1). An incomplete algorithm for doing this in linear time, without using another array is given below. Complete the algorithm by filling in the blanks. Assume alt the variables are suitably declared.
        C++
        
        min = n; i = 0;

while (___________) {	

     temp = A[i]; j = i;

     while (________) {

     A[j] = ________	

     j= (j + k) mod n ;

     If ( j&lt; min ) then

         min = j;

}

A[(n + i — k) mod n] = _________

i = __________",i &gt; min; j!= (n+i)mod n; A[j + k]; temp; i + 1 ;,i &lt; min; j!= (n+i)mod n; A[j + k]; temp; i + 1;,i &gt; min; j!= (n+i+k)mod n; A[(j + k)]; temp; i + 1;,i &lt; min; j!= (n+i-k)mod n; A[(j + k)mod n]; temp; i + 1;,D,"In the five blanks given in the question, the last two blanks must be temp and i+1 because all the given options for the fourth and fifth blanks have temp and i+1. Now, for the first blank, it must be imin then the control goes out of the while loop in the initial case when i=0 and min=n So, the first blank is i &lt; min which implies either option (B) or option (D) is correct. Assume option (B) is correct then in the bracket of while we have j!=(n+i)modn That means whenever j becomes equal to (n+i)modn then control goes out of the while loop. Now (n+i)modn=i and j is always equal to i because in line 3 of the code we are assigning the value of i to j. So, if option (B) is true control never enters the second while loop but it has to enter the second while loop to shift the nos. K places left. Hence, option (D) is correct.",Array,Hard,High,0.25
8,Which of the following correctly declares an array?,int geeks[20];,int geeks;,geeks{20};,array geeks[20];,A,"Option A is correct. Int is the data type used, geeks is the name of the array and 20 is the size of the array.",Array,Easy,Low,0.25
9,"A three dimensional array in ‘C++’ is declared as int A[x][y][z]. Consider that array elements are stored in row major order and indexing begins from 0. Here, the address of an item at the location A[p][q][r] can be computed as follows (where w is the word length of an integer):",&amp;A[0][0][0] + w(y * z * q + z * p + r),&amp;A[0][0][0] + w(y * z * p + z*q + r),&amp;A[0][0][0] + w(x * y * p + z * q+ r),&amp;A[0][0][0] + w(x * y * q + z * p + r),B,"According to above question we have to find the address of A[p][q][r] To reach pth row we must have to cross 0 to p-1 row i.e. p rows and each rows contains y∗z elements Hence , = y∗z∗p Now to reach qth element in pth row we have to cross q rows and each row contains z(total columns) elements =z∗q to reach rth elements we have to cross r elements in (p+1)th row Total elements to cross =(y∗z∗p+z∗q+r) Now each element occupies m amount of space in memory Therefore total space occupied by these elements = m(y∗z∗p+z∗q+r) Hence , address of A[p][q][r]=base address+ Space Occupied by the Elements Before it. =&amp;A[0][0][0]+m(y*z*p+z*q+r) Hence Option (B) is correct.",Array,Hard,High,0.25
10,Let A be a square matrix of size n x n. Consider the following program. What is the expected output?&nbsp;C = 100for i = 1 to n do    for j = 1 to n do    {        Temp = A[i][j] + C        A[i][j] = A[j][i]        A[j][i] = Temp - C    } for i = 1 to n do    for j = 1 to n do        Output(A[i][j]);,The matrix A itself,Transpose of matrix A,Adding 100 to the upper diagonal elements and subtracting 100 from diagonal elements of A,Inverse of matrix A,A,"If we take look at the inner statements of first loops, we can notice that the statements swap A[i][j] and A[j][i] for all i and j. Since the loop runs for all elements, every element A[l][m] would be swapped twice, once for i = l and j = m and then for i = m and j = l. Swapping twice means the matrix doesn’t change.",Array,Medium,Medium,0.25
11,A program P reads in 500 integers in the range [0..100] representing the scores of 500 students. It then prints the frequency of each score above 50. What would be the best way for P to store the frequencies?&nbsp;,An array of 50 numbers&nbsp;,An array of 100 numbers&nbsp;,An array of 500 numbers&nbsp;,A dynamically allocated array of 550 numbers&nbsp;,A,An array of 50 numbers is correct.,Array,Easy,Low,0.25
12,"What will the output of the below code, be if the base address of the array is 1200?
        C++
        
        #include &lt;iostream&gt;
using namespace std;

int main()
{

    int arr[] = { 1, 2, 3, 4, 5 };
    cout &lt;&lt; arr &lt;&lt; &quot;, &quot; &lt;&lt; &amp;arr &lt;&lt; &quot;, &quot; &lt;&lt; &amp;arr[0] &lt;&lt; endl;
    return 0;
}","1200, 1202, 1204",1200 1200 1200,"1200, 1204, 1208","1200, 1204, 1208",B,"Given that, the base address of the array is 1200.arr, &amp;arr is pointing to the base address of the array arr.&amp;arr[0] is pointing to the address of the first element array arr (base address).Hence the correct option is (B)",Array,Medium,Medium,0.25
13,"What is the correct way to call the function (fun) in the below program?
        C++
        
        #include &lt;bits/stdc++.h&gt;
#include &lt;iostream&gt;
using namespace std;

void fun(char* arr)
{
    int i;
    unsigned int n = strlen(arr);
    for (i = 0; i &lt; n; i++)
        cout &lt;&lt; &quot; &quot; &lt;&lt; arr[i];
}

// Driver program
int main()
{
    char arr[]
        = { &#39;g&#39;, &#39;e&#39;, &#39;e&#39;, &#39;k&#39;, &#39;s&#39;, &#39;q&#39;, &#39;u&#39;, &#39;i&#39;, &#39;z&#39; };
    // How to call the above function here to print the char
    // elements?

    return 0;
}",fun(&amp;arr);,fun(*arr);,fun(arr),None,C,fun(arr) is the correct syntax to call the function having array (arr) as a Parameter.Hence option(C) is correct.&nbsp;,Array,Easy,Low,0.25
14,"Let A be a matrix of size n x n. Consider the following program. What is the expected output?&nbsp;
        C++
        
        void fun(int A[][N])
{
    for (int i = 0; i &lt; N; i++)
        for (int j = i + 1; j &lt; N; j++)
            swap(A[i][j], A[j][i]);
}",Matrix A,Diagonal Of matrix A,Transpose of matrix A,None,C,"In the above program, we are just swapping(arr[i][j]) to arr[j][i]). That means row will become column and column will become row.That means the Transpose of the graph.Hence (C) is the correct output.",Array,Medium,Medium,0.25
15,"What will do the following code?
        C++
        
        void fun(int arr[], int n)
{
    for (int i = 0; i &lt; n; i++) {
        for (int j = i; j &lt; n; j++) {
            for (int k = i; k &lt;= j; k++)
                cout &lt;&lt; arr[k] &lt;&lt; &quot; &quot;;

            cout &lt;&lt; endl;
        }
    }
}",Prints the subsequence of the article.,Prints the elements of the array,Prints the subarray of the element.,None,C,The above code will print subarray of the elements.Hence the correct option is(C).,Array,Medium,Medium,0.25
16,Which of the following is the limitation of the array?,elements can be accessed from anywhere.,The size of the array is fixed.,Indexing is started from Zero.,Memory waste if an array's elements are smaller than the size allotted to them,D,"Suppose we have an arry like : arr[5] ={1, 2, 3}Here we have declared the size of the array as 5, but we have initialized only &nbsp;3 values to it. So it leads to memory wastage.Hence Option (D) is correct.",Array,Easy,Low,0.25
17,"Consider the below program, and what is doing this program basically?
        C++
        
        #include &lt;bits/stdc++.h&gt;
using namespace std;

void print(char a[], int n, int ind)
{
    for (int i = ind; i &lt; n + ind; i++)
        cout &lt;&lt; a[(i % n)] &lt;&lt; &quot; &quot;;
}

int main()
{
    char a[] = { &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; };
    int n = sizeof(a) / sizeof(a[0]);
    print(a, n, 3);
    return 0;
}",It is printing the normal array,It is printing circular array rotated by 3,Syntax error,None,B,"In the above program, we are just shifting the array elements by 3 circularly.we are running loop from i = 3 to 9.Inside the loop we are printing arr[3%6] = arr[3] = 'D'arr[4 % 6] = arr[4] &nbsp;= 'E'arr[5 % 6] = arr[5] = 'F'arr[6 % 6] = arr[0] = 'A'arr[7 % 6] = arr[1] = 'B'arr[8 % 6] = arr[2] = 'C'Hence Option (B) is correct.",Array,Medium,High,0.25
18,"Fill in the blanks for completing the program to rotate an array by d elements.
        C++
        
        /*Function to left rotate arr[] of size n by d*/
void Rotate(int arr[], int d, int n)
{
    int p = 1;
    while (_______) {
        int last = arr[0];
        for (int i = 0; ______ i++) {
            arr[i] = arr[i + 1];
        }
        __________
        p++;
    }
}","p &lt;= d , i &lt; n - 1 , arr[n - 1] = last;","p &lt; d, i &lt; n, arr[n] = last;","p &gt;=d, i &gt;n , arr[n] = &nbsp;last",None,A,"In the three blanks given in the questions.The first blank will be a conditional statement which should be (p.&lt;=d) because p starts with 1 and goes till d.The second blank should be the condition for looping, which is (i &lt; n-1), because the loop will run till n-1 elements.and the last blank will be updating the last element.Hence Option(A) is correct.",Array,Hard,High,0.25
19,Refer the below diagram and identify the problem.&nbsp;,Normal traversal of the matrix.,Row-wise traversal of the matrix.,Column-wise traversal of the matrix.,spiral traversal of the matrix.,D,The image is for the spiral traversal of the matrix.Refer the below article:https://www.geeksforgeeks.org/print-a-given-matrix-in-spiral-form/Hence Option (D) is correct.,Array,Medium,Medium,0.25
20,"Consider the below program. What is the expected output?&nbsp;
        C++
        
        void fun(int arr[], int start, int end)
{
    while (start &lt; end) {
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}",swapping the elements pairwise,sorting the elements,Reverse an array,None,C,"The above code is for reversing an array of elements., we are just swapping the first and last element of the array, and the whole array is reversed.For more reference:https://www.geeksforgeeks.org/write-a-program-to-reverse-an-array-or-string/Hence Option(C) is correct.&nbsp;",Array,Medium,Medium,0.25
21,"What does the following function do for a given Linked List with first node as head?
        C++
        
        void fun1(struct node* head)
{
  if(head == NULL)
    return;
  
  fun1(head-&gt;next);
  printf(&quot;%d  &quot;, head-&gt;data);
}

        
    
        C
        
        void fun1(struct node* head) {
  if(head == NULL)
    return;
  
  fun1(head-&gt;next);
  printf(&quot;%d  &quot;, head-&gt;data);
}

        
    
        Java
        
        void fun1(Node head) {
  if(head == null)
    return;
  
  fun1(head.next);
  System.out.print(head.data + &quot;  &quot;);
}

        
    
        Python
        
        def fun1(head):
  if head is None:
    return
  
  fun1(head.next)
  print(head.data, end=&#39;  &#39;)

        
    
        JavaScript
        
        function fun1(head) {
  if (head === null)
    return;
  
  fun1(head.next);
  console.log(head.data + &#39;  &#39;);
}",Prints all nodes of linked lists,Prints all nodes of linked list in reverse order,Prints alternate nodes of Linked List,Prints alternate nodes in reverse order,B,"This function fun1 recursively prints the elements of a linked list in reverse order.It first checks if the head is NULL, and if it is, it returns without doing anything. Otherwise, it calls the fun1 function recursively with the next node in the linked list (head-&gt;next). This continues until the last node is reached, which is the node whose next pointer is NULL.At this point, the function starts returning, and as it returns it prints the value of each node in the linked list starting from the last node, working its way backwards to the first node. This is achieved through the printf statement which prints the value of head-&gt;data.Thus, when this function is called with the head of a linked list as an argument, it will print the values of the nodes in reverse order.",Linked List,Medium,High,0.25
22,Which of the following points is/are true about Linked List data structure when it is compared with array?,Arrays have better cache locality that can make them better in terms of performance.,It is easy to insert and delete elements in Linked List,Random access is not allowed in a typical implementation of Linked Lists,"The size of array has to be pre-decided, linked lists can change their size any time.",E,"The following points are true when comparing Linked List data structure with an array:Insertion and deletion: Linked lists allow for efficient insertion and deletion operations at any point in the list, as they involve simply adjusting pointers, while in an array, these operations can be expensive as all the elements after the insertion or deletion point need to be shifted.Memory allocation: Linked lists use dynamic memory allocation, so they can grow or shrink as needed, while arrays have a fixed size and need to be allocated a contiguous block of memory upfront.Access time: Arrays provide constant-time access to any element in the array (assuming the index is known), while accessing an element in a linked list takes linear time proportional to the number of elements in the list, as the list needs to be traversed from the beginning to find the desired element.Random access: Arrays support random access, which means that we can directly access any element in the array with its index, while linked lists do not support random access and we need to traverse the list to find a specific element.",Linked List,Easy,Medium,0.25
23,"Consider the following function that takes reference to head of a Doubly Linked List as parameter. Assume that a node of doubly linked list has previous pointer as prev and next pointer as next.&nbsp;
        C++
        
        void fun(struct node **head_ref) {
    struct node *temp = NULL;
    struct node *current = *head_ref;

    while (current != NULL) {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }

    if (temp != NULL)
        *head_ref = temp-&gt;prev;
}

        
    
        C
        
        void fun(struct node **head_ref)
{
    struct node *temp = NULL;
    struct node *current = *head_ref;

    while (current !=  NULL)
    {
        temp = current-&gt;prev;
        current-&gt;prev = current-&gt;next;
        current-&gt;next = temp;
        current = current-&gt;prev;
    }

    if(temp != NULL )
        *head_ref = temp-&gt;prev;
}

        
    
        Java
        
        void fun(Node[] head_ref) {
    Node temp = null;
    Node current = head_ref[0];

    while (current != null) {
        temp = current.prev;
        current.prev = current.next;
        current.next = temp;
        current = current.prev;
    }

    if (temp != null)
        head_ref[0] = temp.prev;
}

        
    
        Python
        
        def fun(head_ref):
    temp = None
    current = head_ref[0]

    while current is not None:
        temp = current.prev
        current.prev = current.next
        current.next = temp
        current = current.prev

    if temp is not None:
        head_ref[0] = temp.prev

        
    
        JavaScript
        
        function fun(head_ref) {
    let temp = null;
    let current = head_ref[0];

    while (current !== null) {
        temp = current.prev;
        current.prev = current.next;
        current.next = temp;
        current = current.prev;
    }

    if (temp !== null)
        head_ref[0] = temp.prev;
}

        
    Assume that reference of head of following doubly linked list is passed to above function 1 &lt;--&gt; 2 &lt;--&gt; 3 &lt;--&gt; 4 &lt;--&gt; 5 &lt;--&gt;6. What should be the modified linked list after the function call?",2 &lt;--&gt; 1 &lt;--&gt; 4 &lt;--&gt; 3 &lt;--&gt; 6 &lt;--&gt;5,5 &lt;--&gt; 4 &lt;--&gt; 3 &lt;--&gt; 2 &lt;--&gt; 1 &lt;--&gt;6.,6 &lt;--&gt; 5 &lt;--&gt; 4 &lt;--&gt; 3 &lt;--&gt; 2 &lt;--&gt; 1.,6 &lt;--&gt; 5 &lt;--&gt; 4 &lt;--&gt; 3 &lt;--&gt; 1 &lt;--&gt; 2,C,"This function fun takes a double pointer to the head of a doubly linked list as its argument and reverses the order of the nodes in the list. By performing the following steps: Recursively traverse the&nbsp;doubly linked list until it reaches the last node.While&nbsp;backtracking, reverse the links between the nodes. To reverse the links:Change the&nbsp;next&nbsp;pointer of the&nbsp;current&nbsp;node&nbsp;to point to its&nbsp;previous&nbsp;node.Change the&nbsp;prev&nbsp;pointer of the&nbsp;current&nbsp;node&nbsp;to point to its&nbsp;next&nbsp;node.Adjust the&nbsp;head&nbsp;of the doubly linked list to point to the&nbsp;last&nbsp;node.For more reference: Reverse a Double linked ListHence Option(C) is correct answer.",Linked List,Hard,High,0.25
24,"The following function reverse() is supposed to reverse a singly linked list. There is one line missing at the end of the function.&nbsp;
        C++
        
        // Link list node
struct node
{
    int data;
    struct node* next;
};

// head_ref is a double pointer which points to head (or start) pointer 
of linked list
static void reverse(struct node** head_ref)
{
    struct node* prev   = NULL;
    struct node* current = *head_ref;
    struct node* next;
    while (current != NULL)
    {
        next  = current-&gt;next;  
        current-&gt;next = prev;   
        prev = current;
        current = next;
    }
     // MISSING STATEMENT HERE
}

        
    
        C
        
        /* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* head_ref is a double pointer which points to head (or start) pointer 
  of linked list */
static void reverse(struct node** head_ref)
{
    struct node* prev   = NULL;
    struct node* current = *head_ref;
    struct node* next;
    while (current != NULL)
    {
        next  = current-&gt;next;  
        current-&gt;next = prev;   
        prev = current;
        current = next;
    }
    /*MISSING STATEMENT HERE*/
}
 

        
    
        Java
        
        // Link list node
class Node {
    int data;
    Node next;
    Node(int d) { data = d; next = null; }
}

// head_ref is a reference to the head pointer of linked list
static void reverse(Node[] head_ref) {
    Node prev = null;
    Node current = head_ref[0];
    Node next;
    while (current != null) {
        next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    // MISSING STATEMENT HERE
}

        
    
        Python
        
        # Link list node
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# head_ref is a reference to the head pointer of linked list
def reverse(head_ref):
    prev = None
    current = head_ref
    while current is not None:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
     # MISSING STATEMENT HERE

        
    
        JavaScript
        
        // Link list node
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// head_ref is a reference to the head pointer of linked list
function reverse(head_ref) {
    let prev = null;
    let current = head_ref;
    let next;
    while (current !== null) {
        next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    // MISSING STATEMENT HERE
}

        
    What should be added in place of ""/*ADD A STATEMENT HERE*/"", so that the function correctly reverses a linked list.",Set the value of head_ref to prev;,Set the value of head_ref to current;,Set the value of head_ref to next;,Set the value of head_ref to NULL;,A,"The missing statement should sets the value of *head_ref (which is a double pointer) to the value of prev, which is the new head of the reversed list.Hence correct option is (A).",Linked List,Medium,High,0.25
25,"What is the output of following function in which start is pointing to the first node of the following linked list 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 ?
        C++
        
        #include &lt;iostream&gt;
using namespace std;

struct node {
    int data;
    node* next;
};

void fun(node* start) {
    if (start == NULL)
        return;
    cout &lt;&lt; start-&gt;data &lt;&lt; &quot;  &quot;;
    
    if (start-&gt;next != NULL)
        fun(start-&gt;next-&gt;next);
    cout &lt;&lt; start-&gt;data &lt;&lt; &quot;  &quot;;
}

        
    
        C
        
        void fun(struct node* start)
{
  if(start == NULL)
    return;
  printf(&quot;%d  &quot;, start-&gt;data); 
 
  if(start-&gt;next != NULL )
    fun(start-&gt;next-&gt;next);
  printf(&quot;%d  &quot;, start-&gt;data);
}

        
    
        Java
        
        class Node {
    int data;
    Node next;
    Node(int d) { data = d; next = null; }
}

void fun(Node start) {
    if (start == null)
        return;
    System.out.print(start.data + &quot;  &quot;);
    
    if (start.next != null)
        fun(start.next.next);
    System.out.print(start.data + &quot;  &quot;);
}

        
    
        Python
        
        class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


def fun(start):
    if start is None:
        return
    print(start.data, end=&#39;  &#39;)
    
    if start.next is not None:
        fun(start.next.next)
    print(start.data, end=&#39;  &#39;)

        
    
        JavaScript
        
        class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function fun(start) {
    if (start === null)
        return;
    console.log(start.data + &#39;  &#39;);
    
    if (start.next !== null)
        fun(start.next.next);
    console.log(start.data + &#39;  &#39;);
}",1 4 6 6 4 1,1 3 5 1 3 5,1 2 3 5,1 3 5 5 3 1,D,"The function prints the data of the current node and then recursively calls itself with the second next node (i.e., start-&gt;next-&gt;next).So, it prints the data of every alternate node of the linked list i.e 1 3 5, and then, since the next-&gt;next of 5 is null, it returns and prints the data of the current node, so it then prints 5 3 1.Therefore, for the given linked list 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6, the function would print 1 3 5 5 3 1.",Linked List,Hard,High,0.25
26,"The following C function takes a simply-linked list as input argument. It modifies the list by moving the last element to the front of the list and returns the modified list. Some part of the code is left blank. Choose the correct alternative that contain the correct pseudocode for the blank line.&nbsp;
        C++
        
        #include &lt;iostream&gt;
struct Node {
    int value;
    Node *next;
};

Node* move_to_front(Node *head) {
    Node *p, *q;
    if (head == NULL || head-&gt;next == NULL)
        return head;
    q = NULL; p = head;
    while (p-&gt;next != NULL) {
        q = p;
        p = p-&gt;next;
    }
    __________________________________
    return head;
}

        
    
        C
        
        typedef struct node 
{
  int value;
  struct node *next;
}Node;
 
Node *move_to_front(Node *head) 
{
  Node *p, *q;
  if ((head == NULL: || (head-&gt;next == NULL)) 
    return head;
  q = NULL; p = head;
  while (p-&gt; next !=NULL) 
  {
    q = p;
    p = p-&gt;next;
  }
  _______________________________
  return head;
}

        
    
        Java
        
        class Node {
    int value;
    Node next;
    Node(int value) {
        this.value = value;
        this.next = null;
    }
}

Node moveToFront(Node head) {
    Node p, q;
    if (head == null || head.next == null)
        return head;
    q = null; p = head;
    while (p.next != null) {
        q = p;
        p = p.next;
    }
    _____________________________________
    return head;
}

        
    
        Python
        
        class Node:
    def __init__(self, value):
        self.value = value
        self.next = None


def move_to_front(head):
    if head is None or head.next is None:
        return head
    p = head
    q = None
    while p.next is not None:
        q = p
        p = p.next
    ______________________________
    return head

        
    
        JavaScript
        
        class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

function moveToFront(head) {
    if (head === null || head.next === null)
        return head;
    let p = head;
    let q = null;
    while (p.next !== null) {
        q = p;
        p = p.next;
    }
   _____________________________
    return head;
}",q = NULL; next of p = head; head = p;,next of q = NULL; head = p; next of p = head;,head = p; next of p = q; next of q = NULL;,next of q = NULL; next of p = head; head = p;,D,"To move the last element to the front of the list, we need to do the following steps:Make the second last node as the last node (i.e., set its next pointer to NULL).Set the next pointer of the current last node (which is now the second last node) to the original head node.Make the current last node as the new head node.",Linked List,Hard,High,0.25
27,"The following &nbsp;function takes a single-linked list of integers as a parameter and rearranges the elements of the list. The function is called with the list containing the integers 1, 2, 3, 4, 5, 6, 7 in the given order. What will be the contents of the list after the function completes execution?&nbsp;
        C++
        
        class Node {
public:
    int value;
    Node* next;
};

void rearrange(Node* list) {
    Node* p;
    Node* q;
    int temp;
    if (list == nullptr || list-&gt;next == nullptr) {
        return;
    }
    p = list;
    q = list-&gt;next;
    while (q != nullptr) {
        temp = p-&gt;value;
        p-&gt;value = q-&gt;value;
        q-&gt;value = temp;
        p = q-&gt;next;
        q = (p != nullptr) ? p-&gt;next : nullptr;
    }
}

        
    
        C
        
        struct Node {
    int value;
    struct Node* next;
};

void rearrange(struct Node* list) {
    struct Node* p;
    struct Node* q;
    int temp;
    if (list == NULL || list-&gt;next == NULL) {
        return;
    }
    p = list;
    q = list-&gt;next;
    while (q != NULL) {
        temp = p-&gt;value;
        p-&gt;value = q-&gt;value;
        q-&gt;value = temp;
        p = q-&gt;next;
        q = (p != NULL) ? p-&gt;next : NULL;
    }
}

        
    
        Java
        
        class Node {
    int value;
    Node next;
}

void rearrange(Node list) {
    Node p, q;
    int temp;
    if (list == null || list.next == null) {
        return;
    }
    p = list;
    q = list.next;
    while (q != null) {
        temp = p.value;
        p.value = q.value;
        q.value = temp;
        p = q.next;
        q = p != null ? p.next : null;
    }
}

        
    
        Python
        
        class Node:
    def __init__(self, value):
        self.value = value
        self.next = None


def rearrange(head):
    if head is None or head.next is None:
        return
    p = head
    q = head.next
    while q is not None:
        p.value, q.value = q.value, p.value
        p = q.next
        q = p.next if p is not None else None

        
    
        JavaScript
        
        class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

function rearrange(list) {
    if (list === null || list.next === null) {
        return;
    }
    let p = list;
    let q = list.next;
    while (q !== null) {
        [p.value, q.value] = [q.value, p.value];
        p = q.next;
        q = p !== null ? p.next : null;
    }
}","1,2,3,4,5,6,7","2,1,4,3,6,5,7","1,3,2,5,4,7,6","2,3,4,5,6,7,1",B,"The function rearrange() exchanges data of every node with its next node. It starts exchanging data from the first node itself.For eg. 3,5,7,9,11answer:- 5,3,9,7,11",Linked List,Hard,High,0.25
28,"Suppose each set is represented as a linked list with elements in arbitrary order. Which of the operations among union, intersection, membership, cardinality will be the slowest? (GATE CS 2004)",union&nbsp;,&nbsp;membership,cardinality,"&nbsp;union, intersection",D,"Cardinality and membership are definitely not the slowest one. For cardinality, just count the number of nodes in a list. For membership, just traverse the list and look for a matchFor getting intersection of L1 and L2, search for each element of L1 in L2 and print the elements we find in L2.&nbsp;There can be many ways for getting union of L1 and L2. One of them is as follows&nbsp;a) Print all the nodes of L1 and print only those which are not present in L2.&nbsp;b) Print nodes of L2.",Linked List,Medium,Medium,0.25
29,"Consider the function f defined below.&nbsp;
        C++
        
        #include &lt;iostream&gt;

struct item {
    int data;
    struct item *next;
};

int f(struct item *p) {
    return (
        (p == NULL) || 
        (p-&gt;next == NULL) || 
        ((p-&gt;data &lt;= p-&gt;next-&gt;data) &amp;&amp; f(p-&gt;next))
    );
}

        
    
        c
        
        struct item 
{ 
  int data; 
  struct item * next; 
}; 

int f(struct item *p) 
{ 
  return (
          (p == NULL) || 
          (p-&gt;next == NULL) || 
          (( p-&gt;data &lt;= p-&gt;next-&gt;data) &amp;&amp; f(p-&gt;next))
         ); 
} 

        
    
        Java
        
        class Item {
    int data;
    Item next;

    Item(int data) {
        this.data = data;
        this.next = null;
    }
}

public class Main {
    public static boolean f(Item p) {
        return (
            (p == null) || 
            (p.next == null) || 
            ((p.data &lt;= p.next.data) &amp;&amp; f(p.next))
        );
    }
}

        
    
        Python
        
        class Item:
    def __init__(self, data):
        self.data = data
        self.next = None


def f(p):
    return (
        p is None or 
        p.next is None or 
        (p.data &lt;= p.next.data and f(p.next))
    )

        
    
        JavaScript
        
        class Item {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function f(p) {
    return (
        p === null || 
        p.next === null || 
        (p.data &lt;= p.next.data &amp;&amp; f(p.next))
    );
}

        
    For a given linked list p, the function f returns 1 if and only if (GATE CS 2003)",not all elements in the list have the same data value.,the elements in the list are sorted in non-decreasing order of data value,the elements in the list are sorted in non-increasing order of data value,None of them,B,"The function checks if the current element is less than or equal to the next element, and recursively applies the same check to the next element. If the end of the list is reached (i.e., p-&gt;next is NULL), or the next element is less than the current element, the function returns 1. Otherwise, it returns 0. Therefore, the function returns 1 only if the linked list is sorted in non-decreasing order.",Linked List,Medium,High,0.25
30,A circularly linked list is used to represent a Queue. A single variable p is used to access the Queue. To which node should p point such that both the operations enQueue and deQueue can be performed in constant time? (GATE 2004)&nbsp;,rear node,front node,not possible with a single pointer,node next to front,A,"Answer is not ""(b) front node"", as we can not get rear from front in O(1), but if p is rear we can implement both enQueue and deQueue in O(1) because from rear we can get front in O(1). Below are sample functions. Note that these functions are just sample are not working. Code to handle base cases is missing.&nbsp;
        C
        
        /* p is pointer to address of rear (double pointer).  This function adds new 
   node after rear and updates rear which is *p to point to new node  */
void  enQueue(struct node **p, struct node *new_node)
{
    /* Missing code to handle base cases like *p is NULL */
     
     new_node-&gt;next = (*p)-&gt;next;
     (*p)-&gt;next = new_node;
     (*p) = new_node /* new is now rear */
     /* Note that p-&gt;next is again front and  p is rear */

 }

/* p is pointer to rear. This function removes the front element and 
    returns the dequeued element from the queue */
struct node *deQueue(struct node *p)
{
    /* Missing code to handle base cases like p is NULL,
        p-&gt;next is NULL,...  etc */

    struct node *temp = p-&gt;next;
    p-&gt;next = p-&gt;next-&gt;next;
    return temp;
    /* Note that p-&gt;next is again front and  p is rear */
}

        
    &nbsp;",Linked List,Hard,High,0.25
31,"What are the time complexities of finding 8th element from beginning and 8th element from end in a singly linked list? Let n be the number of nodes in linked list, you may assume that n &gt; 8.",O(1) and O(n),O(1) and O(1),O(n) and O(1),O(n) and O(n),A,"Finding the 8th element from the beginning of a singly linked list requires traversing the first 8 nodes of the list, which takes O(8) time, or simply O(1) time since it's a constant time operation.Finding the 8th element from the end of a singly linked list requires traversing the list until we reach the 8th node from the end. One way to do this is to first traverse the list once to determine its length, and then traverse the list again until we reach the node at position n-8. This takes O(n) time for the first traversal, and then O(n-8) time for the second traversal. Therefore, the time complexity of finding the 8th element from the end of a singly linked list is O(n).",Linked List,Medium,High,0.25
32,Is it possible to create a doubly linked list using only one pointer with every node.,Not Possible,"Yes, possible by storing XOR of addresses of previous and next nodes.","Yes, possible by storing XOR of current node and next node","Yes, possible by storing XOR of current node and previous node",B,"Yes, it is possible to implement a doubly linked list using a single pointer per node, by storing the XOR of the addresses of the previous and next nodes.",Linked List,Hard,High,0.25
33,"Given pointer to a node X in a singly linked list. Only one pointer is given, pointer to head node is not given, can we delete the node X from given linked list?",Possible if X is not last node. Use following two steps (a) Copy the data of next of X to X. (b)Update the pointer of node X to the node after the next node. Delete next of X.,Possible if size of linked list is even.,Possible if size of linked list is odd,Possible if X is not first node. Use following two steps (a) Copy the data of next of X to X. (b) Delete next of X.,A,Following are simple steps.    struct node *temp  = X-&gt;next;    X-&gt;data  = temp-&gt;data;    X-&gt;next  = temp-&gt;next;    free(temp);,Linked List,Hard,High,0.25
34,Which of the following is an application of XOR-linked lists?,Implementing stacks,Implementing queues,Memory-efficient linked list representation,Caching data structures,C,"XOR linked lists are a memory-efficient representation of linked lists. They store the XOR combination of the addresses of the previous and next nodes, reducing the memory overhead compared to traditional linked lists.",Linked List,Medium,Medium,0.25
35,"Consider the following function to traverse a linked list.&nbsp;
        C++
        
        // C++ version of traverse function
void traverse(Node *head) {
    while (head != NULL) {
        printf(&quot;%d  &quot;, head-&gt;data);
        head = head-&gt;next;
    }
}

        
    
        C
        
        void traverse(struct Node *head)
{
   while (head-&gt;next != NULL)
   {
       printf(&quot;%d  &quot;, head-&gt;data);
       head = head-&gt;next;
   }
}

        
    
        Java
        
        // Java version of traverse function
void traverse(Node head) {
    while (head != null) {
        System.out.print(head.data + &quot;  &quot;);
        head = head.next;
    }
}

        
    
        Python
        
        # Python 3 version of traverse function
def traverse(head):
    while head is not None:
        print(head.data, end=&#39;  &#39;)
        head = head.next

        
    
        JavaScript
        
        // JavaScript version of traverse function
function traverse(head) {
    while (head !== null) {
        console.log(head.data + &#39;  &#39;);
        head = head.next;
    }
}

        
    Which of the following is FALSE about above function?",The function may crash when the linked list is empty,The function doesn't print the last node when the linked list is not empty,The function is implemented incorrectly because it changes head,None of the above,C,"This statement is false because it is common for a function that traverses a linked list to change the head pointer, in order to move through the list. In the given function, the head pointer is initially passed in as a parameter, and then it is updated to point to the next node in the list during each iteration of the while loop. This is a standard approach to traversing a linked list.",Linked List,Easy,Low,0.25
36,"N items are stored in a sorted doubly linked list. For a delete operation, a pointer is provided to the record to be deleted. For a decrease-key operation, a pointer is provided to the record on which the operation is to be performed. An algorithm performs the following operations on the list in this order: Θ(N) delete, O(log N) insert, O(log N) find, and Θ(N) decrease-key What is the time complexity of all these operations put together?",O(Log2N),O(N),O(N Log N),Θ(N2 Log N),C,"The time complexity of all these operations put together is O(N log N).The delete operation takes Θ(N) time because we need to traverse the list to find the record to be deleted.The insert and find operations take O(log N) time each because the list is sorted and we can use binary search to locate the correct position for the new record or to find an existing record.The decrease-key operation takes Θ(N) time because we need to traverse the list to find the record on which the operation is to be performed.Assuming that there are M total operations (M = Θ(N) + O(log N) + O(log N) + Θ(N) = O(N)), the total time complexity of all operations is O(M log N) = O(N log N), because the operations take varying amounts of time but they are all performed on a list of size N.",Linked List,Hard,High,0.25
37,What are the application(s) of linked list?,Implementation of stacks and queues.,Maintaining a directory of names,None of the above,Both a and b,D,Both a and b are the implementations of linked list.,Linked List,Easy,Low,0.25
38,The concatenation of two lists is to be performed in O(1) time. Which of the following implementations of a list should be used?,singly linked list,doubly linked list,circular doubly linked list,array implementation of lists,C,As list concatenation requires traversing at least one list to the end. So singly linked list and doubly linked list requires O(n) time complexity whereas circular doubly linked list required O(1) time.&nbsp;,Linked List,Medium,Medium,0.25
39,"Consider the following piece of 'C' code fragment that removes duplicates from an ordered list of integers.
        C++
        
        #include &lt;stdio.h&gt;

Node *remove_duplicates(Node *head, int *j) {
    Node *t1, *t2;
    *j = 0;
    t1 = head;
    if (t1 != NULL) t2 = t1-&gt;next;
    else return head;
    *j = 1;
    if (t2 == NULL)
        return head;
    while (t2 != NULL) {
        if (t1-&gt;val != t2-&gt;val) { // S1
            (*j)++; t1-&gt;next = t2; t1 = t2; // S2
        }
        t2 = t2-&gt;next;
    }
    t1-&gt;next = NULL;
    return head;
}

        
    
        C
        
        #include &lt;stdio.h&gt;

Node  *remove-duplicates(Node *head, int *j)
{
    Node *t1, *t2;
    *j=0;
    t1 = head;
    if (t1! = NULL) t2 = t1 →next;
    else return head;
    *j = 1;
    if(t2 == NULL)
        return head;
    while t2 != NULL)
    {
        if (t1.val != t2.val) --------------------------→ (S1)
        {
            (*j)++; t1 -&gt; next = t2; t1 = t2: ----------→ (S2)
        }
        t2 = t2 →next;
    }
    t1 →next = NULL;
    return head;
}

        
    
        Java
        
        public Node removeDuplicates(Node head, int[] j) {
    Node t1, t2;
    j[0] = 0;
    t1 = head;
    if (t1 != null) t2 = t1.next;
    else return head;
    j[0] = 1;
    if (t2 == null)
        return head;
    while (t2 != null) {
        if (t1.val != t2.val) { // S1
            j[0]++; t1.next = t2; t1 = t2; // S2
        }
        t2 = t2.next;
    }
    t1.next = null;
    return head;
}

        
    
        Python
        
        def remove_duplicates(head, j):
    t1 = head
    j[0] = 0
    if t1 is not None:
        t2 = t1.next
    else:
        return head
    j[0] = 1
    if t2 is None:
        return head
    while t2 is not None:
        if t1.val != t2.val:  # S1
            j[0] += 1         # S2
            t1.next = t2      # S2
            t1 = t2           # S2
        t2 = t2.next
    t1.next = None
    return head

        
    
        JavaScript
        
        function removeDuplicates(head, j) {
    let t1 = head;
    j[0] = 0;
    if (t1 !== null) t2 = t1.next;
    else return head;
    j[0] = 1;
    if (t2 === null)
        return head;
    while (t2 !== null) {
        if (t1.val !== t2.val) { // S1
            j[0]++; t1.next = t2; t1 = t2; // S2
        }
        t2 = t2.next;
    }
    t1.next = null;
    return head;
}

        
    Assume the list contains n elements (n≥2) in the following questions. a). How many times is the comparison in statement S1 made? b). What is the minimum and the maximum number of times statements marked S2 get executed? c). What is the significance of the value in the integer pointed to by j when the function completes?","(a). n-1 times, since comparison is pairwise for n elements.(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.(C). j keeps count of distinct nodes in the list.","(a). n times, since comparison is pairwise for n elements.(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.(C). j keeps count of distinct nodes in the list.","(a). n-1 times, since comparison is pairwise for n elements.(b). maximum : n-1 for all distinct elements, minimum: 1 for all same elements.(C). j keeps count of distinct nodes in the list.",None of the above,A,"(a). n-1 times, since comparison is pairwise for n elements.(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.(C). j keeps count of distinct nodes in the list.",Linked List,Hard,High,0.25
40,"Suppose there are two singly linked lists both of which intersect at some point and become a single linked list. The head or start pointers of both the lists are known, but the intersecting node and lengths of lists are not known. What is worst case time complexity of optimal algorithm to find intersecting node from two intersecting linked lists?","Θ(n*m), where m, n are lengths of given lists","Θ(n^2), where m&gt;n and m, n are lengths of given lists","Θ(m+n), where m, n are lengths of given lists","Θ(min(n, m)), where m, n are lengths of given lists",C,"This takes Θ(m+n) time and O(1) space in worst case, where M and N are the total length of the linked lists.Traverse the two linked list to find m and n.Get back to the heads, then traverse |m − n| nodes on the longer list.Now walk in lock step and compare the nodes until you found the common ones.Option (C) is correct.",Linked List,Hard,High,0.25
41,"A queue is implemented using a non-circular singly linked list. The queue has a head pointer and a tail pointer, as shown in the figure. Let n denote the number of nodes in the queue. Let 'enqueue' be implemented by inserting a new node at the head, and 'dequeue' be implemented by deletion of a node from the tail. Which one of the following is the time complexity of the most time-efficient implementation of 'enqueue' and 'dequeue, respectively, for this data structure?","Θ(1), Θ(1)","Θ(1), Θ(n)","Θ(n), Θ(1)","Θ(n), Θ(n)",B,"For Enqueue operation, performs in constant amount of time (i.e., Θ(1)), because it modifies only two pointers, i.e.,Create a Node P.P--&gt;Data = DataP--&gt;Next = HeadHead = PFor Dequeue operation, we need address of second last node of single linked list to make NULL of its next pointer. Since we can not access its previous node in singly linked list, so need to traverse entire linked list to get second last node of linked list, i.e.,temp = head; While( temp-Next--&gt;Next != NULL){        temp = temp-Next;        }temp--&gt;next = NULL;Tail = temp;Since, we are traversing entire linked for each Dequeue, so time complexity will be Θ(n). Option (B) is correct.&nbsp;",Linked List,Hard,High,0.25
42,"In a doubly linked list, the number of pointers affected for an insertion operation will be",5,0,1,None of these,D,"Explanation - Actually , &nbsp;It depends on the position at which the insertion is done .&nbsp;However , there can be at most 3 cases :-1) Insertion at Begin - 3 pointers affected2) Insertion at Middle - 4 pointers affected3) Insertion at End - 3 pointers affected",Linked List,Medium,Medium,0.25
43,"Consider an implementation of unsorted single linked list. Suppose it has its representation with a head and a tail pointer (i.e. pointers to the first and last nodes of the linked list). Given the representation, which of the following operation can not be implemented in O(1) time ?",Insertion at the front of the linked list.,Insertion at the end of the linked list.,Deletion of the front node of the linked list.,Deletion of the last node of the linked list.,D,"Deletion of the last node of the linked list, we need address of second last node of single linked list to make NULL of its next pointer. Since we can not access its previous node in singly linked list, so need to traverse entire linked list to get second last node of linked list. So, option (D) is correct.",Linked List,Medium,High,0.25
44,Consider a single linked list where F and L are pointers to the first and last elements respectively of the linked list. The time for performing which of the given operations depends on the length of the linked list?F-&gt;1-&gt;2-&gt;3-&gt;L,Delete the first element of the list,Interchange the first two elements of the list,Delete the last element of the list,Add an element at the end of the list,C,"If F and L are pointers to the first and last elements respectively of the linked list, then: i) Deleting the first element of the list will not depend on the length of the link list as F = F-&gt;next and delete first node. ii) Interchanging the first two elements of the list will also not require the length of linked list, simply by taking a temp node, swap the two nodes of the list. iii) Deleting the last element of the list will require the length traversal of the list so as to obtain the pointer of the node previous to the last node. iv) Adding an element at the end of the list, can be done by making L-&gt;next = new node So, correct option is (C).",Linked List,Medium,High,0.25
45,The following steps in a linked listp = getnode() info (p) = 10 next (p) = list list = presult in which type of operation?,pop operation in stack,removal of a node,inserting a node at beginning&nbsp;,modifying an existing node,C,"The given steps result in the insertion of a new node at the beginning of a linked list.The first step p = getnode() creates a new node p using the getnode() function (assuming it is defined elsewhere).The second step info (p) = 10 sets the info field of the new node p to the value 10.The third step next (p) = list sets the next field of the new node p to the current head of the linked list, which is pointed to by the list pointer.Finally, the fourth step list = p updates the list pointer to point to the newly inserted node p, effectively making it the new head of the linked list.Therefore, this sequence of steps performs an insertion operation at the beginning of the linked list, also known as a push operation.",Linked List,Easy,Low,0.25
46,"In DNA sequence alignment, which string-matching algorithm is commonly used to identify similarities between two DNA sequences efficiently?",Rabin-Karp algorithm,Knuth-Morris-Pratt algorithm,Z function,None of the above,D,"In DNA sequence alignment, other specialized algorithms like the Smith-Waterman algorithm or Needleman-Wunsch algorithm are commonly used instead of the Rabin-Karp algorithm, Knuth-Morris-Pratt algorithm, or Z function.",Linked List,Hard,High,0.25
47,Which of the following operations is performed more efficiently by doubly linked list than by linear linked list?,Deleting a node whose location is given,Searching an unsorted list for a given item,Inserting a node after the node with a given location,Traversing the list to process each node,A,"Doubly linked lists have a few advantages over linear linked lists when it comes to certain operations. Specifically, the following operation is performed more efficiently by a doubly linked list than by a linear linked listDeleting a node given a pointer to the node.In a linear linked list, deleting a node requires traversing the list to find the node to be deleted and its predecessor. Once these nodes have been found, the predecessor's next pointer is updated to skip over the node to be deleted. This operation takes O(n) time in the worst case, where n is the number of nodes in the list.",Linked List,Medium,Medium,0.25
48,The time required to search an element in a linked list of length n is,O (log n),O (n),O (1),O (n2),B,"In the worst case, the element to be searched has to be compared with all elements of linked list, so the time complexity is O(n). Option (B) is correct.",Linked List,Easy,Low,0.25
49,The minimum number of fields with each node of doubly linked list is,1,2,3,4,C,"In general, each node of doubly link list always has 3 fields, i.e., the previous node pointer, the data field, and the next node pointer, see - doubly linked list introduction  So, answer should be option (C) 3.  However, each node of doubly linked list can have only 2 fields, i.e., XOR pointer field, and data field. This XOR pointer field can points both previous node and next node, this is the best case with data field. This is called as memory efficient doubly linked list, see - XOR linked list – a memory efficient doubly linked list | set 1    Also, if we remove data node from the XOR linked list, then each node of this doubly linked list can have only 1 field, i.e., XOR pointer field. But, this is without data field so, this doubly linked list does not make sense.",Linked List,Easy,Low,0.25
50,"A doubly linked list is declared as
        C++
        
        struct Node {
       int Value;
       struct Node *Fwd;
       struct Node *Bwd;
);

        
    
        C
        
        // Struct definition in C
struct Node {
    int Value;
    struct Node *Fwd;
    struct Node *Bwd;
};

        
    
        Java
        
        // Struct definition in Java
class Node {
    int Value;
    Node Fwd;
    Node Bwd;
}

        
    
        Python
        
        # Class definition in Python
class Node:
    def __init__(self, value):
        self.Value = value
        self.Fwd = None
        self.Bwd = None

        
    
        JavaScript
        
        // Class definition in JavaScript
class Node {
    constructor(value) {
        this.Value = value;
        this.Fwd = null;
        this.Bwd = null;
    }
}

        
    Where Fwd and Bwd represent forward and backward link to the adjacent elements of the list. Which of the following segments of code deletes the node pointed to by X from the doubly linked list, if it is assumed that X points to neither the first nor the last node of the list?",X-&gt;Bwd-&gt;Fwd = X-&gt;Fwd; X-&gt;Fwd-&gt;Bwd = X-&gt;Bwd ;,X-&gt;Bwd.Fwd = X-&gt;Fwd ; X.Fwd-&gt;Bwd = X-&gt;Bwd ;,X.Bwd-&gt;Fwd = X.Bwd ; X-&gt;Fwd.Bwd = X.Bwd ;,X-&gt;Bwd-&gt;Fwd = X-&gt;Bwd ; X-&gt;Fwd-&gt;Bwd = X-&gt;Fwd;,A,"To delete a node from a doubly linked list, we need to update the links of the previous and next nodes to point to each other, effectively removing the node to be deleted from the list.",Linked List,Medium,High,0.25
51,Consider a singly linked list of the form where F is a pointer to the first element in the linked list and L is the pointer to the last element in the list. The time of which of the following operations depends on the length of the list?,Delete the last element of the list,Delete the first element of the list,Add an element after the last element of the list,Interchange the first two elements of the list,A,"Interchange the first two elements of the list: To interchange the first two elements of the list, we can simply update the head pointer of the list to point to the second element and update the next pointer of the second element to point to the first element. This can be done in constant time, regardless of the length of the list.",Linked List,Medium,Medium,0.25
52,Which of the following sorting algorithms can be used to sort a random linked list with minimum time complexity?,Insertion Sort,Quick Sort,Heap Sort,Merge Sort,D,"Both Merge sort and Insertion sort can be used for linked lists. The slow random-access performance of a linked list makes other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible. Since worst case time complexity of Merge Sort is O(nLogn) and Insertion sort is O(n^2), merge sort is preferred. See following for implementation of merge sort using Linked List.",Linked List,Hard,High,0.25
53,"In the worst case, the number of comparisons needed to search a singly linked list of length n for a given element is",log(2*n),n/2,log(2*n) -1,n,D,"In the worst case, the given element may not be present in the singly linked list of length n. Therefore, the search algorithm would need to traverse the entire list to determine that the element is not present.Therefore, the number of comparisons needed to search a singly linked list of length n in the worst case is equal to n, which is the length of the list.",Linked List,Easy,Low,0.25
54,Let P be a singly linked list. Let Q be the pointer to an intermediate node x in the list. What is the worst-case time complexity of the best known algorithm to delete the node Q from the list?,O(n),O(log2 n),O(logn),O(1),A,"To delete a node Q from a singly linked list, we need to modify the next pointer of the node that precedes Q to point to the node that follows Q. However, in a singly linked list, we cannot traverse the list backwards from a given node, so we need to start from the beginning of the list to find the node that precedes Q.Therefore, the worst-case time complexity of the best known algorithm to delete the node Q from the list is O(n), where n is the length of the list. This is because we may need to traverse the entire list to find the node that precedes Q.However, if we have a pointer to the node that precedes Q, the deletion operation can be performed in O(1) time complexity, since we can simply modify the next pointer of that node to skip over Q. But, if we do not have a pointer to the node that precedes Q, we need to start from the beginning of the list and traverse the list to find it, which takes O(n) time complexity in the worst case.",Linked List,Hard,High,0.25
55,"What is the worst case time complexity of inserting n elements into an empty linked list, if the linked list needs to be maintained in sorted order ?",Θ(n),Θ(n log n),Θ(n2),Θ(1),C,"If we want to insert n elements into an empty linked list that needs to be maintained in sorted order, the worst-case time complexity would be O(n^2). This is because we would need to traverse the list for each element we want to insert, to find the correct position for the element in the sorted list.&nbsp;",Linked List,Hard,High,0.25
56,"Consider the following conditions:&nbsp;(a)The solution must be feasible, i.e. it must satisfy all the supply and demand constraints.&nbsp;(b)The number of positive allocations must be equal to m1n21, where m is the number of rows and n is the number of columns.&nbsp;(c)All the positive allocations must be in independent positions.&nbsp;The initial solution of a transportation problem is said to be non-degenerate basic feasible solution if it satisfies: Codes:",(a) and (b) only,(a) and (c) only,(b) and (c) only,"(a), (b) and (c)",D,"The correct answer is (a) and (b) and (c)A basic feasible solution (BFS) satisfies the following conditions:The solution is feasible, i.e., it satisfies all the supply and demand constraints.The number of positive allocations is equal to the number of rows plus the number of columns minus one (m + n - 1).All the positive allocations are in independent positions.A non-degenerate basic feasible solution (NDBFS) is a basic feasible solution that satisfies conditions (a) and (b) above, but also satisfies the additional condition that no three or more variables are simultaneously zero in any nondegenerate square submatrix of the allocation matrix. This condition is used to ensure uniqueness of the solution. However, it is not explicitly mentioned in the given options.",Linked List,Hard,High,0.25
57,Consider the following statements:i.   First-in-first out types of computations are efficiently supported by STACKS.ii.  Implementing LISTS on linked lists is more efficient than implementing LISTS on an array for almost all the basic LIST operations.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.iv.  Last-in-first-out type of computations are efficiently supported by QUEUES.Which of the following is correct?,(ii) is true,(i) and (ii) are true,(iii) is true,(ii) and (iv) are true,C,"The correct statement is:iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.Explanation:i. STACKS are used to implement Last-in-First-Out (LIFO) operations, not First-in-First-out (FIFO) operations. Therefore, statement i is incorrect.ii. Implementing LISTS on a linked list is more efficient for some operations, such as adding or removing elements in the middle of the list, but it is less efficient for other operations, such as accessing elements by index. Therefore, the statement is incorrect.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices. This is because with a circular array, the front and rear indices wrap around when they reach the end of the array, making it more efficient toenqueue and dequeue elements. Therefore, the statement is correct.iv. QUEUES are used to implement First-in-First-out (FIFO) operations, not Last-in-First-out (LIFO) operations. Therefore, statement iv is incorrect.Hence Option (C) is the correct answer.",Linked List,Medium,Medium,0.25
58,"Consider the problem of reversing a singly linked list. To take an example, given the linked list below,&nbsp;the reversed linked list should look like&nbsp;Which one of the following statements is TRUE about the time complexity of algorithms that solve the above problem in O(1) space?",The best algorithm for the problem takes&nbsp;[Tex]\theta (n)&nbsp;&nbsp;&nbsp;&nbsp;[/Tex]&nbsp;time in the worst case,The best algorithm for the problem takes&nbsp;[Tex]\theta(nlogn)&nbsp;&nbsp;&nbsp;&nbsp;[/Tex]&nbsp;time in the worst case.&nbsp;,The best algorithm for the problem takes&nbsp;[Tex]\theta(n^{2})&nbsp;&nbsp;&nbsp;&nbsp;[/Tex]&nbsp;time in the worst case,It is not possible to reverse a singly linked list in O(1) space.&nbsp;,A,"Reversing a linked list only requires one traversal of entire linked list of N elements and Change the appropriate Pointers. The Time complexity is&nbsp;Θ(n).So, option A is the correct answer.&nbsp;",Linked List,Medium,High,0.25
59,"Consider the queues Q1 containing four elements and Q2 containing none (shown as the Initial State in the figure). The only operations allowed on these two queues are Enqueue(Q, element) and Dequeue(Q). The minimum number of Enqueue operations on Q1 required to place the elements of Q1 in Q2 in reverse order (shown as the Final State in the figure) without using any additional storage is___________.&nbsp;",12,9,4,0,D,"Understanding the Operation usedEnq(Qx, Deq(Qy)) means that we dequeue an element from the queue Qy and enqueue an element into the queue Qx.The operation does not take any extra space as the value returned from one function is immediately passed as an argument to another function. Remember that a function's return value and arguments are stored in the function stack frame, so no extra space is taken, i.e. space to keep this data is included in the function-call/operation itself.Solution StepsThis question can be solved by following the given set of instructions :Step No.OperationState of Queues (after performing the operation)0.-Original State1.Enq(Q2, Deq(Q1))&nbsp;2.Enq(Q2, Deq(Q1))&nbsp;3.Enq(Q2, Deq(Q2))&nbsp;4.Enq(Q2, Deq(Q1))&nbsp;5.Enq(Q2, Deq(Q2))&nbsp;6.&nbsp;Enq(Q2, Deq(Q2))&nbsp;7.Enq(Q2, Deq(Q1))&nbsp;8.Enq(Q2, Deq(Q2))&nbsp;9.Enq(Q2, Deq(Q2))&nbsp;10.Enq(Q2, Deq(Q2))Solution StateThe minimum number of Enqueue operations on Q1 required to place the elements of Q1 in Q2 in reverse order (shown as the Final State in the figure) without using any additional storage is 0.",Linked List,Hard,High,0.25
60,"Find the functionality of the given code-
        C++
        
        void function(int data)
{
    int flag = 0;
    if (head != null) {
        Node temp = head.getNext();
        while ((temp != head)
               &amp;&amp; (!(temp.getItem() == data))) {
            temp = temp.getNext();
            flag = 1;
            break;
        }
    }
    if (flag)
        System.out.println(&quot;success&quot;);
    else
        System.out.println(&quot;fail&quot;);
}",Print success if a particular element is not found,Print fail if a particular element is not found,Print success if a particular element is equal to 1,Print fail if the list is empty,D,"The function checks if the linked list is empty. If it is, it will print ""fail.""If the list is not empty, it checks the first node. If the first node's item does not match the data, it will print ""success"" due to the break statement, which is misleading because it suggests a match was found when it wasn't.Therefore, ""Print fail if a particular element is not found"" is not accurate because it only checks the first element and the output can be misleading.So, the most appropriate answer reflecting the functionality of the code is ""Print fail if the list is empty.""",Linked List,Medium,Medium,0.25
61,What is the time complexity of searching for an element in a circular linked list?,O(n),O(nlogn),O(1),O(n2),A,"In the worst case, you have to traverse through the entire list of n elements.",Linked List,Easy,Low,0.25
62,Choose the code snippet which inserts a node to the head of the list?,public void insertHead(int data){Node temp = new Node(data);Node cur = head;while(cur.getNext() != head)&nbsp;cur = cur.getNext()if(head == null){&nbsp;head = temp;&nbsp;head.setNext(head);}else{&nbsp;temp.setNext(head);&nbsp;head = temp;&nbsp;cur.setNext(temp);}size++;}&nbsp;,public void insertHead(int data){Node temp = new Node(data);while(cur != head)&nbsp;cur = cur.getNext()if(head == null){&nbsp;head = temp;&nbsp;head.setNext(head);}else{&nbsp;temp.setNext(head.getNext());&nbsp;cur.setNext(temp);}size++;},public void insertHead(int data){Node temp = new Node(data);if(head == null){&nbsp;head = temp;&nbsp;head.setNext(head);}else{&nbsp;temp.setNext(head.getNext());&nbsp;head = temp;}size++;},public void insertHead(int data){Node temp = new Node(data);if(head == null){&nbsp;head = temp;&nbsp;head.setNext(head.getNext());}else{&nbsp;temp.setNext(head.getNext());&nbsp;head = temp;}size++;},A,"If the list is empty make the new node as ‘head’, otherwise traverse the list to the end and make its ‘next’ pointer point to the new node, set the new node’s next point to the current head and make the new node as the head.",Linked List,Medium,High,0.25
63,"What is the functionality of the following code? Choose the most appropriate answer.
        C++
        
        int function()
{
    if (head == null)
        return Integer.MIN_VALUE;
    int var;
    Node temp = head;
    while (temp.getNext() != head)
        temp = temp.getNext();
    if (temp == head) {
        var = head.getItem();
        head = null;
        return var;
    }
    temp.setNext(head.getNext());
    var = head.getItem();
    head = head.getNext();
    return var;
}",Return data from the end of the list,Returns the data and deletes the node at the end of the list,Returns the data from the beginning of the list,Returns the data and deletes the node from the beginning of the list,D,"First traverse through the list to find the end node, then manipulate the ‘next’ pointer such that it points to the current head’s next node, returns the data stored in the head and make this next node as the head.Hence Option(D) is the correct answer.",Linked List,Hard,High,0.25
64,Consider a small circular linked list. How to detect the presence of cycles in this list effectively?,Keep one node as head and traverse another temp node till the end to check if its ‘next points to head,Have fast and slow pointers with the fast pointer advancing two nodes at a time and slow pointer advancing by one node at a time,"Cannot determine, you have to pre-define if the list contains cycles",Circular linked list itself represents a cycle. So no new cycles cannot be generated,B,Advance the pointers in such a way that the fast pointer advances two nodes at a time and slow pointer advances one node at a time and check to see if at any given instant of time if the fast pointer points to slow pointer or if the fast pointer’s ‘next’ points to the slow pointer. This is applicable for smaller lists.Below is the implementation of the above approach: bool isCircular() {        if (head == nullptr) {            return false;        }        Node* slow = head;        Node* fast = head-&gt;next;        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) {            if (slow == fast) {                return true;            }            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        }        return false;    }Hence (B) is the correct answer.,Linked List,Medium,High,0.25
65,Which of the following application makes use of a circular linked list?,Undo Operation,Recursive function calls,Allocating CPU to resources,Implement Hash Tables,C,"Applications of circular linked lists:Multiplayer games use this to give each player a chance to play.A circular linked list can be used to organize multiple running applications on an operating system. These applications are iterated over by the OS.Circular linked lists can be used in resource allocation problems.Circular linked lists are commonly used to implement circular buffers,Circular linked lists can be used in simulation and gaming.Hence Option (C) is the correct answer.&nbsp;",Linked List,Easy,Low,0.25
66,"In a circular linked list, How many nodes are containing NULL as the address?",Only one node,Only Two node,Every Node,"No, any node",D,"In a circular linked list, there is no any node containing NULL as their address.Circular linked listFollowing are some properties of the circular linked list:&nbsp;A node always points to another node, so NULL assignment is not necessary.Any node can be set as the starting point.Nodes are traversed quickly from the first to the last.Hence Option(D) is the correct answer.",Linked List,Easy,Low,0.25
67,What is the time complexity to insert a node at the beginning of the list?,O(LogN),O(N),O(1),None,C,"To insert a node at the beginning of the Circular linked list, there is no need to traverse the list so it takes constant time.To insert a node at the beginning of the list, follow these steps:&nbsp;Create a node, say T.&nbsp;Make T -&gt; next = last -&gt; next.&nbsp;last -&gt; next = T.&nbsp;Circular linked listAnd then,&nbsp;Circular linked listHence Option(A) is the correct answer.",Linked List,Easy,Low,0.25
68,"Consider the below program, and identify which Operation is performed.
        C++
        
        int solve(struct Node* head)
{
    if (head == NULL)
        return 1;
    struct Node* ptr;
    ptr = head-&gt;next;
    while (ptr != NULL &amp;&amp; ptr != head)
        ptr = ptr-&gt;next;
    return (ptr == head);
}",Checking for List is empty of not,Checking for the list is Circular or not,count the number of elements in the list,None,B,"In the above program, we are just checking whether the linked list is circular or not. The idea is to store the head of the linked list and traverse it. If the iterator reaches NULL, the linked list is not circular. else If it reaches the head again, then the linked list is circular.&nbsp;A linked list is called circular if it is not NULL-terminated and all nodes are connected in the form of a cycle. Below is an example of a circular linked list.&nbsp;Hence (B) is the correct answer.",Linked List,Medium,Medium,0.25
69,Which of the following Statement is correct about Circular Linked List?P1: Every Node has a successor.P2: TIme complexity for deleting the first node is O(N).P3: Last Node points to the NULL.P4: Every Node contains the data and a next pointer to traverse the list.,Only P4,Only P1,P1 and P2,P1 and P4.,D,"In the above statement, P1 and P4 are correct about the linked list.P1: &nbsp;Every Node has a successor node in a circular form.P2: TIme complexity for deleting the first node is O(N). this statement is incorrect because deleting the first node will take O(1) time.P3:Last Node points to the NULL. this statement is also incorrect because the last node points to the first node in a circular linked list.P4: Every Node contains the data and a next pointer to traverse the list., this statement is also correct.Therefore, P1 and P4 are the correct statements.Hence (D) is the correct answer.&nbsp;",Linked List,Medium,Medium,0.25
70,"Following is a pseudo code of a function that takes a number as an argument, and uses a stack S to do processing.  
        Python
        
        def fun(n):
    S = []  # Say it creates an empty stack S
    while n &gt; 0:
        # This line pushes the value of n%2 to stack S
        S.append(n % 2)
        n = n // 2

    # Run while Stack S is not empty
    while S:
        print(S.pop(), end=&#39; &#39;)  # pop an element from S and print it

        
    What does the above function do in general?",Prints binary representation of n in reverse order,Prints binary representation of n,Prints the value of Logn,Prints the value of Logn in reverse order,B,"The given code is recursive method to print binary representation of ‘NUM’.&nbsp;step 1) if NUM &gt; 1    a) push NUM on stack    b) recursively call function with 'NUM / 2'step 2)    a) pop NUM from stack, divide it by 2 and print it's remainder.Read in Detail :  Binary representation of a number for explanation.",Stack,Medium,High,0.25
71,"Consider the following pseudocode that uses a stack&nbsp;
        Python
        
        # Declare a stack of characters
word = &quot;example&quot;  # Replace with the word you want to read
char_stack = []

# While there are more characters in the word to read
for c in word:
    char_stack.append(c)  # Push the character on the stack

# While the stack is not empty
while char_stack:
    c = char_stack.pop()  # Pop a character off the stack
    print(c, end=&#39;&#39;)  # Write the character to the screen

        
    What is output for input ""geeksquiz""?",geeksquizgeeksquiz,ziuqskeeg,geeksquiz,ziuqskeegziuqskeeg,B,"Since the stack data structure follows LIFO order. When we pop() items from stack, they are popped in reverse order of their insertion (or push())",Stack,Easy,Low,0.25
72,"Following is an incorrect pseudocode for the algorithm which is supposed to determine whether a sequence of parentheses is balanced:&nbsp;


        C
        
           declare a character stack 
   while ( more input is available)
   {
      read a character
      if ( the character is a &#39;(&#39; ) 
         push it on the stack
      else if ( the character is a &#39;)&#39; and the stack is not empty )
         pop a character off the stack
      else
         print &quot;unbalanced&quot; and exit
    }
    print &quot;balanced&quot;

        
    

Which of these unbalanced sequences does the above code think is balanced?&nbsp;",((()),())((),(()())),(()))(),B,"At the end of while loop, we must check whether the stack is empty or not. For input ((()), the stack doesn't remain empty after the loop. See http://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/ for details.",Stack,Medium,High,0.25
73,The following postfix expression with single digit operands is evaluated using a stack:8 2 3 ^ / 2 3 * + 5 1 * -  Note that ^ is the exponentiation operator. The top two elements of the stack after the first * is evaluated are:,"6, 1","5, 7","3, 2","1, 5",A,"The algorithm for evaluating any postfix expression is fairly straightforward: 1. While there are input tokens left    o Read the next token from input.    o If the token is a value       + Push it onto the stack.    o Otherwise, the token is an operator       (operator here includes both operators, and functions).       * It is known a priori that the operator takes n arguments.       * If there are fewer than n values on the stack        (Error) The user has not input sufficient values in the expression.       * Else, Pop the top n values from the stack.       * Evaluate the operator, with the values as arguments.       * Push the returned results, if any, back onto the stack.2. If there is only one value in the stack    o That value is the result of the calculation.3. If there are more values in the stack    o (Error)  The user input has too many values. Source for algorithm:&nbsp;http://en.wikipedia.org/wiki/Reverse_Polish_notation#The_postfix_algorithm  Let us run the above algorithm for the given expression. First three tokens are values, so they are simply pushed. After pushing 8, 2 and 3, the stack is as follows     8, 2, 3 When ^ is read, top two are popped and power(2^3) is calculated     8, 8 When / is read, top two are popped and division(8/8) is performed     1 Next two tokens are values, so they are simply pushed. After pushing 2 and 3, the stack is as follows     1, 2, 3 When * comes, top two are popped and multiplication is performed.     1, 6",Stack,Hard,High,0.25
74,"Let S be a stack of size n &gt;= 1. Starting with the empty stack, suppose we push the first n natural numbers in sequence, and then perform n pop operations. Assume that Push and Pop operation take X seconds each, and Y seconds elapse between the end of one such stack operation and the start of the next operation. For m &gt;= 1, define the stack-life of m as the time elapsed from the end of Push(m) to the start of the pop operation that removes m from S. The average stack-life of an element of this stack is",n(X+ Y),3Y + 2X,n(X + Y)-X,Y + 2X,C,"Example: Let's n = 31  ( Pushed in Stack ) : Time take = X 2  ( Pushed in Stack ) : Time take = X 3  ( Pushed in Stack ) : Time take = X 3  ( Popped Out of Stack ) : Time take = X 2  ( Popped Out of Stack ) : Time take = X 1   ( Popped Out of Stack ) : Time take = X Stack Life of 3 = yStack Life of 2 = 3(x + y ) - xStack Life of 1 =  5(x + y ) - xAverage Stack Lifge of Element = ( Y + (3(X + Y ) - X ) + (5(X + Y ) - X) ) /3 = ( 6X + 9Y )/3 = 2X + 3YFor n= 3 the average stack life is 2X +3YSimiliarly for n elements, the average stack life will be n( X + Y ) -Y",Stack,Hard,High,0.25
75,"A single array A[1..MAXSIZE] is used to implement two stacks. The two stacks grow from opposite ends of the array. Variables top1 and top2 (topl&lt; top 2) point to the location of the topmost element in each of the stacks. If the space is to be used efficiently, the condition for “stack full” is:",(top1 = MAXSIZE/2) and (top2 = MAXSIZE/2+1),top1 + top2 + 1 = MAXSIZE,(top1= MAXSIZE/2) or (top2 = MAXSIZE),top1= top2 -1,D,If we are to use space efficiently then size of the any stack can be more than MAXSIZE/2.   Both stacks will grow from both ends and if any of the stack top reaches near to the other top then stacks are full. So the condition will be top1 = top2 -1 (given that top1 &lt; top2),Stack,Hard,High,0.25
76,"Assume that the operators +, -, × are left associative and ^ is right associative. The order of precedence (from highest to lowest) is ^, x , +, -. The postfix expression corresponding to the infix expression a + b × c - d ^ e ^ f is",abc × + def ^ ^ -,abc × + de ^ f ^ -,ab + c × d - e ^ f ^,- + a × bc ^ ^ def,B,"Start scanning from left to right.Use a stack to keep track of operators.If the scanned symbol is an operand (in this case, 'a', 'b', 'c', 'd', 'e', 'f'), append it to the postfix expression.If the scanned symbol is an operator, pop and output all operators from the stack which have equal or higher precedence than the current operator. Then push the current operator onto the stack.If the scanned symbol is an opening parenthesis '(', push it onto the stack.If the scanned symbol is a closing parenthesis ')', pop and output operators from the stack until an opening parenthesis '(' is encountered. Pop '(' from the stack (but don't output it).Repeat steps 3-6 until all symbols are scanned.Given the infix expression a + b × c - d ^ e ^ f, the corresponding postfix expression is:a b c x + d e f ^ ^ -",Stack,Hard,High,0.25
77,To evaluate an expression without any embedded function calls :&nbsp;,As many stacks as the height of the expression tree are needed,One stack is enough,Two stacks are needed,A Turing machine is needed in the general case,C,"Any expression can be converted into Postfix or Prefix form.&nbsp;Prefix and postfix evaluation can be done using a single stack.&nbsp;For example : Expression '10 2 8 * + 3 -' is given.&nbsp;PUSH 10 in the stack.&nbsp;PUSH 2 in the stack.&nbsp;PUSH 8 in the stack.&nbsp;When operator '*' occurs, POP 2 and 8 from the stack.&nbsp;PUSH 2 * 8 = 16 in the stack.&nbsp;When operator '+' occurs, POP 16 and 10 from the stack.&nbsp;PUSH 10 * 16 = 26 in the stack.&nbsp;PUSH 3 in the stack.&nbsp;When operator '-' occurs, POP 26 and 3 from the stack.&nbsp;PUSH 26 - 3 = 23 in the stack.&nbsp;So, 23 is the answer obtained using single stack.&nbsp;Thus, option (B) is correct.&nbsp;",Stack,Medium,Medium,0.25
78,The result evaluating the postfix expression 10 5 + 60 6 / * 8 –  is,284,213,142,71,C,"Step 1: Postfix Expression Evaluation RulesOperands (numbers) are pushed onto a stack.When an operator is encountered, the required number of operands is popped from the stack, the operation is performed, and the result is pushed back onto the stack.Step 2: Evaluate the ExpressionLet's evaluate step by step:Expression: 10 5 + 60 6 / ∗ 8 −Push 10: Stack = [10]Push 5: Stack = [10, 5]Encounter +: Pop 10 and 5, add them: 10+5 = 15. Push result back: Stack=[15]Push 60: Stack = [15, 60]Push 6: Stack = [15, 60, 6]Encounter /: Pop 60 and 6, divide them: 60/6=10. Push result back: Stack = [15,10]Encounter *: Pop 15 and 10, multiply them: 15×10=150. Push result back: Stack=[150]Push 8: Stack = [150, 8]Encounter -: Pop 150 and 8, subtract them: 150−8=142. Push result back: Stack=[142].Step 3: The final result in the stack is: 142",Stack,Medium,High,0.25
79,"A function f defined on stacks of integers satisfies the following properties. f(∅) = 0 and f (push (S, i)) = max (f(S), 0) + i for all stacks S and integers i. If a stack S contains the integers 2, -3, 2, -1, 2 in order from bottom to top, what is f(S)?",6,4,3,2,D,"Since a stack follows LIFO (Last In, First Out), we process elements from top to bottom:Stack (Top to Bottom): [2, -1, 2, -3, 2]Start with f(∅) = 0Push 2: f = 2Push -1: f = 2 - 1 = 1Push 2: f = 1 + 2 = 3Push -3: f = 3 - 3 = 0Push 2: f = 0 + 2 = 2Final result: 2",Stack,Hard,High,0.25
80,"Consider the following program:  
        C++
        
        #include &lt;iostream&gt;
#include &lt;cctype&gt;
#include &lt;stack&gt;

#define EOF -1

std::stack&lt;int&gt; s;

void push(int value) { s.push(value); } /* push the argument on the stack */
int pop(void) { if (s.empty()) return EOF; int value = s.top(); s.pop(); return value; }  /* pop the top of the stack */
void flagError() { std::cerr &lt;&lt; &quot;Error!&quot; &lt;&lt; std::endl; exit(1); }

int main() {
    int c, m, n, r;
    while ((c = std::cin.get()) != EOF) {
        if (isdigit(c))
            push(c - &#39;0&#39;);
        else if ((c == &#39;+&#39;) || (c == &#39;*&#39;)) {
            m = pop();
            n = pop();
            r = (c == &#39;+&#39;) ? n + m : n * m;
            push(r);
        } else if (c != &#39; &#39;)
            flagError();
    }
    std::cout &lt;&lt; pop() &lt;&lt; std::endl;
}

        
    
        C
        
        #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

#define EOF -1

#define MAX_STACK_SIZE 100
int s[MAX_STACK_SIZE];
int top = -1;

void push(int value) { if (top &lt; MAX_STACK_SIZE - 1) s[++top] = value; } /* push the argument on the stack */
int pop(void) { if (top == -1) return EOF; return s[top--]; }  /* pop the top of the stack */
void flagError() { fprintf(stderr, &quot;Error!\n&quot;); exit(1); }

int main() {
    int c, m, n, r;
    while ((c = getchar()) != EOF) {
        if (isdigit(c))
            push(c - &#39;0&#39;);
        else if ((c == &#39;+&#39;) || (c == &#39;*&#39;)) {
            m = pop();
            n = pop();
            r = (c == &#39;+&#39;) ? n + m : n * m;
            push(r);
        } else if (c != &#39; &#39;)
            flagError();
    }
    printf(&quot;%d\n&quot;, pop());
}

        
    
        Java
        
        import java.util.*;

public class Main {
    static Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

    static void push(int value) { stack.push(value); } /* push the argument on the stack */
    static int pop() { return stack.isEmpty() ? -1 : stack.pop(); }  /* pop the top of the stack */
    static void flagError() { System.err.println(&quot;Error!&quot;); System.exit(1); }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int c, m, n, r;
        while ((c = scanner.next().charAt(0)) != -1) {
            if (Character.isDigit(c))
                push(c - &#39;0&#39;);
            else if (c == &#39;+&#39; || c == &#39;*&#39;) {
                m = pop();
                n = pop();
                r = (c == &#39;+&#39;) ? n + m : n * m;
                push(r);
            } else if (c != &#39; &#39;)
                flagError();
        }
        System.out.println(pop());
    }
}

        
    
        Python
        
        class Stack:
    def __init__(self):
        self.items = []
    def push(self, item):
        self.items.append(item)  # push the argument on the stack
    def pop(self):
        return self.items.pop() if self.items else -1  # pop the top of the stack

def flagError():
    print(&quot;Error!&quot;)
    exit(1)

s = Stack()

while True:
    try:
        c = input()
        if c == &#39;&#39;:
            break
        c = ord(c)
        if c &gt;= ord(&#39;0&#39;) and c &lt;= ord(&#39;9&#39;):
            s.push(c - ord(&#39;0&#39;))
        elif c == ord(&#39;+&#39;) or c == ord(&#39;*&#39;):
            m = s.pop()
            n = s.pop()
            r = n + m if c == ord(&#39;+&#39;) else n * m
            s.push(r)
        elif c != ord(&#39; &#39;):
            flagError()
    except EOFError:
        break
print(s.pop())

        
    
        JavaScript
        
        class Stack {
    constructor() {
        this.items = [];
    }
    push(item) { this.items.push(item); } /* push the argument on the stack */
    pop() { return this.items.length === 0 ? -1 : this.items.pop(); }  /* pop the top of the stack */
}

function flagError() { console.error(&#39;Error!&#39;); process.exit(1); }

const stack = new Stack();

process.stdin.on(&#39;data&#39;, function (data) {
    const input = data.toString();
    for (let c of input) {
        if (!isNaN(c)) {
            stack.push(parseInt(c));
        } else if (c === &#39;+&#39; || c === &#39;*&#39;) {
            const m = stack.pop();
            const n = stack.pop();
            const r = (c === &#39;+&#39;) ? n + m : n * m;
            stack.push(r);
        } else if (c !== &#39; &#39;) {
            flagError();
        }
    }
});

process.stdin.on(&#39;end&#39;, function () {
    console.log(stack.pop());
});

        
    What is the output of the program for the following input ? 5 2 * 3 3 2 + * +",15,25,30,150,B,"&nbsp;The function of the program is:-1) If the current character is a digit it pushes into stack2) Else if the current character is operator,&nbsp; it pops two elements and then performs the operation.Finally it pushes the resultant element into stack.Initially stack s is empty. 5 2 * 3 3 2 + * + 1) 5 -&gt; It pushes into s 2) 2 -&gt; It pushes into s 3) * -&gt; It pops two elements n = 2, m=5 n*m = 10 It pushes 10 into s4) 3 -&gt; It pushes into s 5) 3 -&gt; It pushes into s6) 2 -&gt; It pushes into s7) + -&gt; n=2, m=3 n+m=5 It pushes 5 into s8) * -&gt; n=5, m=3 n*m=15 It pushes 15 into s 9) + -&gt; n=15, m=10 n+m = 25 It pushes 25 into s.Result = 25",Stack,Hard,High,0.25
81,Suppose a stack is to be implemented with a linked list instead of an array. What would be the effect on the time complexity of the push and pop operations of the stack implemented using linked list (Assuming stack is implemented efficiently)?,O(1) for insertion and O(n) for deletion,O(1) for insertion and O(1) for deletion,O(n) for insertion and O(1) for deletion,O(n) for insertion and O(n) for deletion,C,Stack can be implemented using link list having O(1) bounds for both insertion as well as deletion by inserting and deleting the element from the beginning of the list.,Stack,Easy,Low,0.25
82,"Consider n elements that are equally distributed in k stacks. In each stack, elements of it are arranged in ascending order (min is at the top in each of the stack and then increasing downwards). 

Given a queue of size n in which we have to put all n elements in increasing order. What will be the time complexity of the best known algorithm?",O(n logk),O(nk),O(n2),O(k2),B,"In nlogk it can be done by creating a min heap of size k and adding all the top - elements of all the stacks. After extracting the min , add the next element from the stack from which we have got our 1st minimum.
Time Complexity = O(k) (For Creating Heap of size k) + (n-k)log k (Insertions into the heap).",Stack,Hard,High,0.25
83,"A priority queue Q is used to implement a stack S that stores characters. PUSH(C) is implemented as INSERT(Q, C, K) where K is an appropriate integer key chosen by the implementation. POP is implemented as DELETEMIN(Q). For a sequence of operations, the keys chosen are in",Non-increasing order,Non-decreasing order,strictly increasing order,strictly decreasing order,E,"We are implementing a STACK using Priority Queue. Note that Stack implementation is always last in first out (LIFO) order. As given ""POP is implemented as DELETEMIN(Q)"" that means Stack returns minimum element always. So, we need to implement PUSH(C) using INSERT(Q, C, K) where K is key chosen from strictly-decreasing order(only this order will ensure stack will return minimum element when we POP an element). That will satisfy Last In First Out (LIFO) property of stack. That is answer, option (D) is true. Option (A) non-increasing order can not be true because two same (identical) numbers can not have same priority as priority should be distinguishable for each number.",Stack,Hard,High,0.25
84,"Which of the following permutation can be obtained in the same order using a stack assuming that input is the sequence 5, 6, 7, 8, 9 in that order?","7, 8, 9, 5, 6","5, 9, 6, 7, 8","7, 8, 9, 6, 5","9, 8, 7, 5, 6",D,"The sequence given in option (C) is one of the only possible sequence which can be obtained.
We can obtain the sequence by performing operations in the manner:
Push 5
Push 6
Push 7
Pop 7
Push 8
Pop 8
Push 9
Pop 9
Pop 6
Pop 5.
hence the sequence will be 7,8,9,6,5.",Stack,Hard,High,0.25
85,The best data structure to check whether an arithmetic expression has balanced parenthesis is a,Queue,Stack,Tree,List,C,"Stacks can check equal pair/ balanced pair of parenthesis efficiently. Whenever we get an opening parenthesis we can push it on the stack and when we get the corresponding closing parenthesis, we can pop it. After performing all push and pop operations, if at the end of the expression stack becomes empty then the expression has a balanced parenthesis.",Stack,Easy,Low,0.25
86,"The seven elements A, B, C, D, E, F and G are pushed onto a stack in reverse order, i.e., starting from G. The stack is popped five times and each element is inserted into a queue.Two elements are deleted from the queue and pushed back onto the stack. Now, one element is popped from the stack. The popped item is ________.",A,B,F,G,C,"In fig:-1 elements are inserted into a stack then in fig:-2 top 5 elements are popped and these 5 elements are inserted into a queue which is shown in fig:-3, now first two elements are deleted from queue and pushed into stack one by one which is shown in fig:-5.
At top of the stack element B is presented.
So, option (B) is correct.",Stack,Hard,High,0.25
87,"If the sequence of operations - push (1), push (2), pop, push (1), push (2), pop, pop, pop, push (2), pop are performed on a stack, the sequence of popped out values","2,2,1,1,2","2,2,1,2,2","2,1,2,2,1","2,1,2,2,2",B,"Let's simulate the sequence of operations on a stack:Push(1): Stack = [1]Push(2): Stack = [1, 2]Pop: Pop 2, Stack = [1]Push(1): Stack = [1, 1]Push(2): Stack = [1, 1, 2]Pop: Pop 2, Stack = [1, 1]Pop: Pop 1, Stack = [1]Pop: Pop 1, Stack = []Push(2): Stack = [2]Pop: Pop 2, Stack = []The sequence of popped out values is: 2, 2, 1, 1, 2.",Stack,Medium,High,0.25
88,"The five items: A, B, C, D, and E are pushed in a stack, one after other starting from A. The stack is popped four items and each element is inserted in a queue. The two elements are deleted from the queue and pushed back on the stack. Now one item is popped from the stack. The popped item is",A,B,C,D,E,"When five items: A, B, C, D, and E are pushed in a stack: Order of stack becomes: A, B, C, D, and E (A at the bottom and E at the top.) stack is popped four items and each element is inserted in a queue: Order of queue: B, C, D, E (B at rear and E at the front) Order of stack after pop operations = A. Two elements deleted from the queue and pushed back on the stack: New order of stack = A, E, D(A at the bottom, D at the top) As D is on the top so when pop operation occurs D will be popped out. So, correct option is (D).",Stack,Hard,High,0.25
89,Consider the following operations performed on a stack of size 5 : Push (a); Pop() ; Push(b); Push(c); Pop(); Push(d); Pop();Pop(); Push (e) Which of the following statements is correct?,Underflow occurs,Stack operations are performed smoothly,Overflow occurs,None of the above,C,"All Stack operations are performed smoothly. So, option (B) is correct.",Stack,Easy,Low,0.25
90,Which of the following is not an inherent application of stack?,Implementation of recursion,Evaluation of a postfix expression,Job scheduling,Reverse a string,D,"We can use stack for string reversal, evaluation of postfix expression and most important is implementation of recursion but job scheduling is not done by stack. So, option (C) is correct.",Stack,Easy,Low,0.25
91,Convert the following infix expression into its equivalent post fix expression (A + B^ D) / (E – F) + G,ABD^ + EF – / G+,ABD + ^EF – / G+,ABD + ^EF / – G+,ABD^ + EF / – G+,B,"(A + B^ D) / (E – F) + G
= (A + B^ D)(E – F)/ + G
=  (A + B^ D)(E – F)/G+
= A + BD^(E – F)/G+
= ABD^+EF-/G+
So, option (A) is correct.",Stack,Hard,High,0.25
92,Consider the following sequence of operations on an empty stack.Push(54);push(52);pop();push(55);push(62);s=pop(); Consider the following sequence of operations on an empty queue.enqueue(21);enqueue(24);dequeue();enqueue(28);enqueue(32);q=dequeue(); The value of s+q is ___________.,86,68,24,94,A,"Let's construct an empty stack and do the operations. Stack follows LIFO order. Push(54) // (54) Push(52) // (54,52) Pop() // (54) Push(55) //(54,55) Push(62) //(54,55,62) s=pop() // (54,55) s=62Let's construct an empty queue and do the operations. Queue follows FIFO order. Enqueue(21) // [21] Enqueue(24) // [21,24] Dequeue() // [24] Enqueue(28) // [24,28] Enqueue(32) // [24,28,32] q=Dequeue() // [28,32] q=24; s+q=62+24 So, s+q=86 .&nbsp; Alternative Way : Stack is last in first out data structure, so s = pop() = 62 Queue is first in first out data structure, so q = dequeue() = 24 Therefore, s+q = 62+24 = 86.",Stack,Medium,High,0.25
93,Which of the following is true about linked list implementation of stack?,"In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end.","In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from the beginning.",Both of the above,None of the above,E,"To keep the Last In First Out order, a stack can be implemented using linked list in two ways:

a) In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from beginning.

b) In push operation, if new nodes are inserted at the end of linked list, then in pop operation, nodes must be removed from end.",Stack,Medium,Medium,0.25
94,Which one of the following is an application of Stack Data Structure?,Managing function calls,The stock span problem,Arithmetic expression evaluation,All of the above,E,See http://en.wikipedia.org/wiki/Stack_(abstract_data_type)#Applications,Stack,Easy,Low,0.25
95,"The five items: A, B, C, D, and E are pushed in a stack, one after other starting from A. The stack is popped four items and each element is inserted in a queue. The two elements are deleted from the queue and pushed back on the stack. Now one item is popped from the stack. The popped item is",A,B,C,D,E,"When five items: A, B, C, D, and E are pushed in a stack: Order of stack becomes: A, B, C, D, and E (A at the bottom and E at the top.) stack is popped four items and each element is inserted in a queue: Order of queue: B, C, D, E (B at rear and E at the front) Order of stack after pop operations = A. Two elements deleted from the queue and pushed back on the stack: New order of stack = A, E, D(A at the bottom, D at the top) As D is on the top so when pop operation occurs D will be popped out. So, correct option is (D).",Stack,Hard,High,0.25
96,"Stack A has the entries a, b, c (with a on top). Stack B is empty. An entry popped out of stack A can be printed immediately or pushed to stack B. An entry popped out of the stack B can be only be printed. In this arrangement, which of the following permutations of a, b, c are not possible?",b a c,b c a,c a b,a b c,D,"Option (A):
Pop a from stack A
Push a to stack B
Print b
Print a from stack B
Print c from stack A
Order = b a c

Option (B):
Pop a from stack A
Push a to stack B
Print b from stack A
Print c from stack A
Print a from stack A
Order = b c a

Option (C):
Pop a from stack A
Push a to stack B
Pop b from stack A
Push b to stack B
Print c from stack A
Now, printing a will not be possible.
So, option (C) is incorrect.",Stack,Hard,High,0.25
97,"The five items: A, B, C, D, and E are pushed in a stack, one after other starting from A. The stack is popped four items and each element is inserted in a queue. The two elements are deleted from the queue and pushed back on the stack. Now one item is popped from the stack. The popped item is",A,B,C,D,E,"When five items: A, B, C, D, and E are pushed in a stack:
Order of stack becomes: A, B, C, D, and E (A at the bottom and E at the top.)
stack is popped four items and each element is inserted in a queue:
Order of queue: B, C, D, E (B at rear and E at the front)
Order of stack after pop operations = A
Two elements deleted from the queue and pushed back on the stack:
New order of stack = A, E, D(A at the bottom, D at the top)
As D is on the top so when pop operation occurs D will be popped out.

So, correct option is (D).",Stack,Hard,High,0.25
98,Consider the following statements:i.   First-in-first out types of computations are efficiently supported by STACKS.ii.  Implementing LISTS on linked lists is more efficient than implementing LISTS on an array for almost all the basic LIST operations.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.iv.  Last-in-first-out type of computations are efficiently supported by QUEUES.Which of the following is correct?,(ii) is true,(i) and (ii) are true,(iii) is true,(ii) and (iv) are true,C,"The correct statement is:iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.Explanation:i. STACKS are used to implement Last-in-First-Out (LIFO) operations, not First-in-First-out (FIFO) operations. Therefore, statement i is incorrect.ii. Implementing LISTS on a linked list is more efficient for some operations, such as adding or removing elements in the middle of the list, but it is less efficient for other operations, such as accessing elements by index. Therefore, the statement is incorrect.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices. This is because with a circular array, the front and rear indices wrap around when they reach the end of the array, making it more efficient toenqueue and dequeue elements. Therefore, the statement is correct.iv. QUEUES are used to implement First-in-First-out (FIFO) operations, not Last-in-First-out (LIFO) operations. Therefore, statement iv is incorrect.Hence Option (C) is the correct answer.",Stack,Medium,Medium,0.25
99,The minimum number of stacks needed to implement a queue is,3,1,2,4,C,"Two stacks S1 &amp; S2 are required to implement a queue.This method makes sure that newly entered element is always at the top of stack 1, so that DeQueue operation just pops from stack1. To put the element at top of stack1, stack2 is used.Hence Option (C) is the correct answer.",Stack,Medium,High,0.25
100,"Following is pseudo code of a function that takes a Queue as an argument, and uses a stack S to do processing.&nbsp;
        C++
        
        void fun(Queue *Q) {
    Stack S;  // Say it creates an empty stack S

    // Run while Q is not empty
    while (!isEmpty(Q)) {
        // deQueue an item from Q and push the dequeued item to S
        push(&amp;S, deQueue(Q));
    }

    // Run while Stack S is not empty
    while (!isEmpty(&amp;S)) {
        // Pop an item from S and enqueue the popped item to Q
        enQueue(Q, pop(&amp;S));
    }
}

        
    
        C
        
        void fun(Queue *Q)
{
    Stack S;  // Say it creates an empty stack S

    // Run while Q is not empty
    while (!isEmpty(Q))
    {
        // deQueue an item from Q and push the dequeued item to S
        push(&amp;S, deQueue(Q));
    }

    // Run while Stack S is not empty
    while (!isEmpty(&amp;S))
    {
      // Pop an item from S and enqueue the popped item to Q
      enQueue(Q, pop(&amp;S));
    }
}

        
    
        Java
        
        void fun(Queue Q) {
    Stack S = new Stack();  // Say it creates an empty stack S

    // Run while Q is not empty
    while (!Q.isEmpty()) {
        // deQueue an item from Q and push the dequeued item to S
        S.push(Q.deQueue());
    }

    // Run while Stack S is not empty
    while (!S.isEmpty()) {
        // Pop an item from S and enqueue the popped item to Q
        Q.enQueue(S.pop());
    }
}

        
    
        Python
        
        def fun(Q):
    S = []  # Say it creates an empty stack S

    # Run while Q is not empty
    while not Q.is_empty():
        # deQueue an item from Q and push the dequeued item to S
        S.append(Q.deQueue())

    # Run while Stack S is not empty
    while S:
        # Pop an item from S and enqueue the popped item to Q
        Q.enQueue(S.pop())

        
    
        JavaScript
        
        function fun(Q) {
    let S = [];  // Say it creates an empty stack S

    // Run while Q is not empty
    while (!Q.isEmpty()) {
        // deQueue an item from Q and push the dequeued item to S
        S.push(Q.deQueue());
    }

    // Run while Stack S is not empty
    while (S.length &gt; 0) {
        // Pop an item from S and enqueue the popped item to Q
        Q.enQueue(S.pop());
    }
}

        
    What does the above function do in general?",Removes the last from Q,Keeps the Q same as it was before the call,Makes Q empty,Reverses the Q,D,"The function takes a queue Q as an argument. It dequeues all items of Q and pushes them to a stack S. Then pops all items of S and enqueues the items back to Q. Since the stack is LIFO order, all items of the queue are reversed.Hence option (D) is the correct answer.",Queue,Medium,High,0.25
101,"How many stacks are needed to implement a queue. Consider the situation where no other data structure like arrays, linked list is available to you.",1,2,3,4,B,A queue can be implemented using two stacks.Refer this for more reference:https://www.geeksforgeeks.org/queue-using-stacks/Hence Option(B) is the correct answer.,Queue,Medium,High,0.25
102,Which of the following operations on a queue data structure has a time complexity of O(1)?&nbsp;A) Enqueue&nbsp;B) Dequeue&nbsp;C) Peek&nbsp;D) Clear,A and B,B only,C only,A and D&nbsp;,B,"In a queue data structure, dequeueing (removing an element from the front of the queue) typically has a time complexity of O(1) because it involves removing the first element and adjusting the front pointer.&nbsp;Hence, Option B is the correct option.",Queue,Easy,Low,0.25
103,A priority queue can efficiently implemented using which of the following data structures? Assume that the number of insert and peek (operation to see the current highest priority item) and extraction (remove the highest priority item) operations are almost same.,Array,Linked List,"Heap Data Structures like Binary Heap, Fibonacci Heap",None of the above,C,"A priority queue can be efficiently implemented using a data structure called a binary heap or Fibonacci Heap. A binary heap is a complete binary tree that satisfies the heap property. Binary heaps provide excellent time complexity for these operations, making them an efficient choice for implementing priority queues when the number of insert and peek/extraction operations is roughly equal.Hence option(C) is the correct answer.",Queue,Medium,High,0.25
104,Which of the following is true about linked list implementation of queue?,"In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end.","In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from the beginning.",Both of the above,None of the above,C,"To keep the First In First Out order, a queue can be implemented using a linked list in any of the given two ways.Hence option (C) is the correct answer.",Queue,Medium,Medium,0.25
105,"A Priority-Queue is implemented as a Max-Heap. Initially, it has 5 elements. The level-order traversal of the heap is given below: 10, 8, 5, 3, 2 Two new elements ”1‘ and ”7‘ are inserted in the heap in that order. The level-order traversal of the heap after the insertion of the elements is:","10, 8, 7, 5, 3, 2, 1","10, 8, 7, 2, 3, 1, 5","10, 8, 7, 1, 2, 3, 5","10, 8, 7, 3, 2, 1, 5",D,"The output will be 10, 8, &nbsp;7, 3, 2, 1, 5.Refer the image for clarification:&nbsp;Hence Option(D) is the correct answer.",Queue,Hard,High,0.25
106,"An implementation of a queue Q, using two stacks S1 and S2, is given below:&nbsp;Function Insert(Q, x):    Push x onto stack S1Function Delete(Q):    If stack S2 is empty:        If stack S1 is also empty:            Print ""Q is empty""            Return        Else:            While stack S1 is not empty:                Pop element from stack S1 and store it in x                Push x onto stack S2    Pop element from stack S2 and store it in x    Return x  // Or process the popped element (if needed)Let n insert and m (&lt;=n) delete operations be performed in an arbitrary order on an empty queue Q. Let x and y be the number of push and pop operations performed respectively in the process. Which one of the following is true for all m and n?",n+m &lt;= x &lt; 2n and 2m &lt;= y &lt;= n+m,n+m &lt;= x &lt; 2n and 2m&lt;= y &lt;= 2n,2m &lt;= x &lt; 2n and 2m &lt;= y &lt;= n+m,2m &lt;= x &lt;2n and 2m &lt;= y &lt;= 2n,A,"The order in which insert and delete operations are performed matters here. The best case: Insert and delete operations are performed alternatively. In every delete operation, 2 pop and 1 push operations are performed. So, total m+ n push (n push for insert() and m push for delete()) operations and 2m pop operations are performed. The worst case: First n elements are inserted and then m elements are deleted. In first delete operation, n + 1 pop operations and n push operation are performed. Other than first, in all delete operations, 1 pop operation is performed. So, total m + n pop operations and 2n push operations are performed (n push for insert() and n push for delete())Hence Option (A) is the correct answer.",Queue,Hard,High,0.25
107,"Consider the following operation along with Enqueue and Dequeue operations on queues, where k is a global parameter.MultiDequeue(Q){
   m = k
   while (Q is not empty and m  &gt; 0) {
      Dequeue(Q)
      m = m - 1
   }
}
What is the worst case time complexity of a sequence of n MultiDequeue() operations on an initially empty queue? (A)&nbsp;[Tex]\\Theta(n)&nbsp;&nbsp;[/Tex](B)&nbsp;[Tex]\\Theta(n + k)&nbsp;&nbsp;[/Tex](C)&nbsp;[Tex]\\Theta(nk)&nbsp;&nbsp;[/Tex](D)&nbsp;[Tex]\\Theta(n^2)&nbsp;[/Tex]",A,B,C,D,A,"Since the queue is empty initially, the condition of while loop never becomes true. So the time complexity is&nbsp;[Tex]\\Theta(n)&nbsp;&nbsp;[/Tex].Hence Option (A) is the correct answer.",Queue,Hard,High,0.25
108,"Consider the following pseudo-code. Assume that IntQueue is an integer queue. What does the function fun do?&nbsp;fun(int n)
{    IntQueue q = new IntQueue();
    q.enqueue(0);    q.enqueue(1);
    for (int i = 0; i &lt; n; i++)
    { 
       int a = q.dequeue();
        int b = q.dequeue();
        q.enqueue(b);
        q.enqueue(a + b);
        print(a);
    }
}",Prints numbers from 0 to n-1,Prints numbers from n-1 to 0,Prints first n Fibonacci numbers,Prints first n Fibonacci numbers in reverse order.,C,The function prints first n Fibonacci Numbers. Note that 0 and 1 are initially there in q. In every iteration of the loop sum of the two queue items is enqueued and the front item is dequeued.Hence option (C) is the correct answer.,Queue,Medium,High,0.25
109,Which of the following is NOT a common operation in a queue data structure?&nbsp;,Enqueue&nbsp;,Dequeue&nbsp;,Peek&nbsp;,Shuffle&nbsp;,D,Shuffle is NOT a common operation in a queue data structure.Hence Option (D) is the correct answer.,Queue,Easy,Low,0.25
110,"Suppose a stack implementation supports an instruction REVERSE, which reverses the order of elements on the stack, in addition to the PUSH and POP instructions. Which one of the following statements is TRUE with respect to this modified stack?",A queue cannot be implemented using this stack.,A queue can be implemented where ENQUEUE takes a single instruction and DEQUEUE takes a sequence of two instructions.,A queue can be implemented where ENQUEUE takes a sequence of three instructions and DEQUEUE takes a single instruction.,A queue can be implemented where both ENQUEUE and DEQUEUE take a single instruction each.,C,"To DEQUEUE an item, simply POP. To ENQUEUE an item, we can do following 3 operations 1) REVERSE 2) PUSH 3) REVERSEHence Option (C) is the correct answer.",Queue,Hard,High,0.25
111,A queue is implemented using an array such that ENQUEUE and DEQUEUE operations are performed efficiently. Which one of the following statements is CORRECT (n refers to the number of items in the queue)?,Both operations can be performed in O(1) time,At most one operation can be performed in O(1) time but the worst case time for the other operation will be Ω(n),The worst case time complexity for both operations will be Ω(n),Worst case time complexity for both operations will be Ω(log n),A,"Time Complexity AnalysisENQUEUE Operation:The rear pointer is updated in O(1) time.The element is inserted at the position indicated by the rear pointer.Time Complexity: O(1).DEQUEUE Operation:The front pointer is updated in O(1) time.The element is removed from the position indicated by the front pointer.Time Complexity: O(1).Worst Case Consideration:Both operations (ENQUEUE and DEQUEUE) involve pointer updates and accessing elements in the array, which can be done in constant time.No Ω(n) or Ω(log⁡n) operations are required.Hence Option (A) is the correct answer.",Queue,Medium,High,0.25
112,Let Q denote a queue containing sixteen numbers and S be an empty stack. Head(Q) returns the element at the head of the queue Q without removing it from Q. Similarly Top(S) returns the element at the top of S without removing it from S. Consider the algorithm given below.  The maximum possible number of iterations of the while loop in the algorithm is______ [This Question was originally a Fill-in-the-Blanks question],16,32,256,64,C,"The worst case happens when the queue is sorted in decreasing order. In worst case, loop runs n*n times.Queue: 4 3 2 1Stack: Empty3 2 143 2 1 4Empty2 1 432 1 4 3Empty1 4 321 4 3 2Empty4 3 213 21 43 2 412 41 32 4 314 31 23 1 2 43 4 1 241 2 3Empty1 2 3 4Hence Option (C) is the correct answer.",Queue,Hard,High,0.25
113,"Suppose you are given an implementation of a queue of integersConsider the following function:&nbsp;
        C++
        
        void f(queue&lt;int&gt; &amp;Q) {
    int i;
    if (!Q.empty()) {
        i = Q.front();
        Q.pop();
        f(Q);
        Q.push(i);
    }
}

        
    
        C
        
        void f(queue Q)
{
    int i;
    if (!isEmpty(Q))
    {
        i = delete (Q);
        f(Q);
        insert(Q, i);
    }
}

        
    
        Java
        
        void f(Queue&lt;Integer&gt; Q) {
    if (!Q.isEmpty()) {
        int i = Q.poll();
        f(Q);
        Q.add(i);
    }
}

        
    
        Python
        
        def f(Q):
    if Q:
        i = Q.pop(0)
        f(Q)
        Q.append(i)

        
    
        JavaScript
        
        function f(Q) {
    if (Q.length &gt; 0) {
        let i = Q.shift();
        f(Q);
        Q.push(i);
    }
}

        
    What operation is performed by the above function f ?",Leaves the queue Q unchanged,Reverses the order of the elements in the queue Q,Deletes the element at the front of the queue Q and inserts it at the rear keeping the other elements in the same order,Empties the queue Q,B,"As it is recursive call, and removing from front while inserting from end, that means last element will be deleted at last and will be inserted 1st in the new queue. And like that it will continue till first call executes insert(Q,i) function.So, the queue will be in reverse.Hence Option (B) is the correct answer.",Queue,Hard,High,0.25
114,"Consider a standard Circular Queue 'q' implementation (which has the same condition for Queue Full and Queue Empty) whose size is 11 and the elements of the queue are q[0], q[1], q[2].....,q[10].
The front and rear pointers are initialized to point at q[2] . In which position will the ninth element be added?",q[0],q[1],q[9],q[10],A,"Circular queue whose total size is 11, front and rear pointers are initialized to point at q[2]:    Therefore, 9th element will be added at pointer q[0].  So, option (A) is correct.",Queue,Hard,High,0.25
115,Circular queue is also called -----.,Ring Buffer,Rectangular Buffer,Square Buffer,None,A,A Circular Queue is an extended version of a normal queue where the last element of the queue is connected to the first element of the queue forming a circle. The operations are performed based on FIFO (First In First Out) principle. It is also called ‘Ring Buffer’.&nbsp;&nbsp;Hence Option (A) is the correct answer.,Queue,Easy,Low,0.25
116,"A queue is implemented using a non-circular singly linked list. The queue has a head pointer and a tail pointer, as shown in the figure. Let n denote the number of nodes in the queue. Let 'enqueue' be implemented by inserting a new node at the head, and 'dequeue' be implemented by deletion of a node from the tail. Which one of the following is the time complexity of the most time-efficient implementation of 'enqueue' and 'dequeue, respectively, for this data structure?","Θ(1), Θ(1)","Θ(1), Θ(n)","Θ(n), Θ(1)","Θ(n), Θ(n)",B,"For Enqueue operation, performs in constant amount of time (i.e., Θ(1)), because it modifies only two pointers, i.e.,Create a Node P.P--&gt;Data = DataP--&gt;Next = HeadHead = PFor Dequeue operation, we need address of second last node of single linked list to make NULL of its next pointer. Since we can not access its previous node in singly linked list, so need to traverse entire linked list to get second last node of linked list, i.e.,temp = head; While( temp-Next--&gt;Next != NULL){        temp = temp-Next;        }temp--&gt;next = NULL;Tail = temp;Since, we are traversing entire linked for each Dequeue, so time complexity will be Θ(n). Option (B) is correct.&nbsp;",Queue,Hard,High,0.25
117,Which one of the following is an application of Queue Data Structure?,When a resource is shared among multiple consumers.,When data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes,Load Balancing,All of the above,D,"(A) When a resource is shared among multiple consumers: In scenarios where a resource (such as a printer, CPU time, or database connection) needs to be shared among multiple consumers or processes, a queue data structure can be used. Each consumer can enqueue their requests for the resource, and the resource can be allocated to them in the order of their requests by dequeuing from the queue. This ensures fair access to the shared resource and prevents conflicts or resource contention.(B) When data is transferred asynchronously between two processes: When data is transferred asynchronously between two processes or systems, a queue can be used as a buffer or intermediary storage. One process enqueues the data to be sent, while the other process dequeues and processes the received data. The queue allows for decoupling the rate of data production from data consumption, ensuring smooth and efficient communication between the processes.(C) Load Balancing: Load balancing is the practice of distributing workloads across multiple resources to optimize performance and utilization. A queue data structure can be used in load-balancing algorithms to manage incoming requests or tasks. The requests are enqueued in the queue, and the load balancer can dequeue and assign them to available resources based on various criteria (e.g., round-robin, least connections). This helps distribute the workload evenly across the resources, preventing overload and maximizing throughput.Hence (D) is the correct option.&nbsp;",Queue,Medium,Medium,0.25
118,Consider the following statements:i.   First-in-first out types of computations are efficiently supported by STACKS.ii.  Implementing LISTS on linked lists is more efficient than implementing LISTS on an array for almost all the basic LIST operations.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.iv.  Last-in-first-out type of computations are efficiently supported by QUEUES.Which of the following is correct?,(ii) is true,(i) and (ii) are true,(iii) is true,(ii) and (iv) are true,C,"The correct statement is:iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.Explanation:i. STACKS are used to implement Last-in-First-Out (LIFO) operations, not First-in-First-out (FIFO) operations. Therefore, statement i is incorrect.ii. Implementing LISTS on a linked list is more efficient for some operations, such as adding or removing elements in the middle of the list, but it is less efficient for other operations, such as accessing elements by index. Therefore, the statement is incorrect.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices. This is because with a circular array, the front and rear indices wrap around when they reach the end of the array, making it more efficient toenqueue and dequeue elements. Therefore, the statement is correct.iv. QUEUES are used to implement First-in-First-out (FIFO) operations, not Last-in-First-out (LIFO) operations. Therefore, statement iv is incorrect.Hence Option (C) is the correct answer.",Queue,Medium,Medium,0.25
119,Which of the following option is not correct?,"If the queue is implemented with a linked list, keeping track of a front pointer, Only rear pointer s will change during an insertion into an non-empty queue.",Queue data structure can be used to implement least recently used (LRU) page fault algorithm and Quick short algorithm.,Queue data structure can be used to implement Quick short algorithm but not least recently used (LRU) page fault algorithm.,Both (A) and (C),C,"If the queue is implemented with a linked list, keeping track of a front pointer, Only rear pointer s will change during an insertion into an non-empty queue. Queue data structure can be used to implement least recently used (LRU) page fault algorithm and Quick short algorithm. Only option (C) is not correct.",Queue,Medium,Medium,0.25
120,"Suppose a circular queue of capacity (n – 1) elements is implemented with an array of n elements. Assume that the insertion and deletion operation are carried out using REAR and FRONT as array index variables, respectively. Initially, REAR = FRONT = 0. The conditions to detect queue full and queue empty are","Full: (REAR+1) mod n == FRONT, empty: REAR == FRONT","Full: (REAR+1) mod n == FRONT, empty: (FRONT+1) mod n == REAR","Full: REAR == FRONT, empty: (REAR+1) mod n == FRONT","Full: (FRONT+1) mod n == REAR, empty: REAR == FRONT",A,"Suppose we start filling the queue.Let the maxQueueSize ( Capacity of the Queue) is 4.So the size of the array which is used to implement this circular queue is 5, which is n. In the beginning when the queue is empty, FRONT and REAR point to 0 index in the array. REAR represents insertion at the REAR index. FRONT represents deletion from the FRONT index.enqueue(""a""); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 1)enqueue(""b""); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 2)enqueue(""c""); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 3)enqueue(""d""); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 4)Now the queue size is 4 which is equal to the maxQueueSize. Hence overflow condition is reached.Now, we can check for the conditions.When Queue Full :( REAR+1)%n = (4+1)%5 = 0FRONT is also 0. Hence ( REAR + 1 ) %n is equal to FRONT.When Queue Empty :REAR was equal to FRONT when empty ( because in the starting before filling the queue FRONT = REAR = 0 )Hence Option A is correct.&nbsp;",Queue,Hard,High,0.25
121,The minimum number of stacks needed to implement a queue is,3,1,2,4,C,"Two stacks S1 &amp; S2 are required to implement a queue.This method makes sure that newly entered element is always at the top of stack 1, so that DeQueue operation just pops from stack1. To put the element at top of stack1, stack2 is used.Hence Option (C) is the correct answer.",Queue,Medium,High,0.25
122,"Which data structure is commonly used to implement the event-driven simulation of complex systems, such as in computer network simulations or traffic simulations?",Stack,Tree,Array,Queue,D,"The data structure commonly used to implement the event-driven simulation of complex systems, such as computer network simulations or traffic simulations, is a queue. In event-driven simulations, events occur at specific times, and these events need to be processed in the order of their occurrence. A queue follows the First-In-First-Out (FIFO) principle, which makes it suitable for maintaining the order of events.Hence Option (D) is the correct answer.",Queue,Medium,Medium,0.25
123,The deque which stores elements in strictly increasing order or in strictly decreasing order is called ------.,Priority &nbsp;Queue,Double ended Queue,Monotonic Deque,None,C,"Monotonic Deque :&nbsp;It is deque which stores elements in strictly increasing order or in strictly decreasing order&nbsp;To maintain monotonicity, we need to delete elementsFor example – Consider monotonic(decreasing) deque dq = &nbsp;{5, 4, 2, 1}&nbsp;Insert 3 into dqSo we need to delete elements till dq.back() &lt; 3 &nbsp; to insert 3 into dq &nbsp;(2,1 are the deleted elements)Resulting dq = {5, 4, 3}Hence Option (C) is the correct answer.",Queue,Hard,High,0.25
124,"Consider the below program, and identify what the function is doing.
        C++
        
        #include &lt;iostream&gt;
#include &lt;queue&gt;

class Node {
public:
    int data;
    Node* left;
    Node* right;
    Node(int item) {
        data = item;
        left = right = nullptr;
    }
};

void function(Node* root) {
    if (root == nullptr)
        return;
    std::queue&lt;Node*&gt; q;

    q.push(root);

    while (!q.empty()) {
        Node* node = q.front();
        q.pop();
        std::cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;

        if (node-&gt;left != nullptr)
            q.push(node-&gt;left);

        if (node-&gt;right != nullptr)
            q.push(node-&gt;right);
    }
}

        
    
        C
        
        #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

struct Node* newNode(int item) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node-&gt;data = item;
    node-&gt;left = node-&gt;right = NULL;
    return node;
}

void function(struct Node* root) {
    if (root == NULL)
        return;
    struct Node** q = (struct Node**)malloc(100 * sizeof(struct Node*));
    int front = 0, rear = 0;

    q[rear++] = root;

    while (front &lt; rear) {
        struct Node* node = q[front++];
        printf(&quot;%d &quot;, node-&gt;data);

        if (node-&gt;left != NULL)
            q[rear++] = node-&gt;left;

        if (node-&gt;right != NULL)
            q[rear++] = node-&gt;right;
    }
    free(q);
}

        
    
        Java
        
        import java.util.LinkedList;
import java.util.Queue;

class Node {
    int data;
    Node left, right;
    Node(int item) {
        data = item;
        left = right = null;
    }
}

void function(Node root) {
    if (root == null)
        return;
    Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();

    q.add(root);

    while (!q.isEmpty()) {
        Node node = q.poll();
        System.out.print(node.data + &quot; &quot;);

        if (node.left != null)
            q.add(node.left);

        if (node.right != null)
            q.add(node.right);
    }
}

        
    
        Python
        
        class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

from collections import deque

def function(root):
    if root is None:
        return
    q = deque()

    q.append(root)

    while q:
        node = q.popleft()
        print(node.data, end=&#39; &#39;)

        if node.left is not None:
            q.append(node.left)

        if node.right is not None:
            q.append(node.right)

        
    
        JavaScript
        
        class Node {
    constructor(data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
}

function function(root) {
    if (root === null)
        return;
    let q = [];

    q.push(root);

    while (q.length &gt; 0) {
        let node = q.shift();
        console.log(node.data);

        if (node.left !== null)
            q.push(node.left);

        if (node.right !== null)
            q.push(node.right);
    }
}",In order traversal of a tree,Normal traversal of a tree,Level order traversal of &nbsp;a tree,None,C,"The above code is the level order traversal of the tree using Queue. We need to visit the nodes in a lower level before any node in a higher level, this idea is quite similar to that of a queue. Push the nodes of a lower level in the queue. When any node is visited, pop that node from the queue and push the child of that node in the queue.This ensures that the node of a lower level is visited prior to any node of a higher level.Hence Option (C) is the correct answer.",Queue,Medium,High,0.25
125,Which of the following is/are advantages of circular Queue?,Memory Management,Traffic system,CPU Scheduling,All of the above,D,"Applications of Circular Queue:Memory Management: The unused memory locations in the case of ordinary queues can be utilized in circular queues.Traffic system: In computer controlled traffic system, circular queues are used to switch on the traffic lights one by one repeatedly as per the time set.CPU Scheduling: Operating systems often maintain a queue of processes that are ready to execute or that are waiting for a particular event to occur.Hence option(D) is the correct answer.",Queue,Medium,Medium,0.25
126,which data structure is used to implement deque?,Stack,Doubly linked &nbsp;list,circular array,Both B and C,D,"A Deque can be implemented either using a doubly-linked list or a circular array. In both implementations, we can implement all operations in O(1) time.Hence Option (D) is the correct answer.",Queue,Medium,Medium,0.25
127,Which of the following is the type of priority Queue?,Ascending Order Priority Queue,Descending order Priority Queue&nbsp;,Deque,Both A and B.,D,"Types of Priority Queue:1) Ascending Order Priority Queue: As the name suggests, in ascending order priority queue, the element with a lower priority value is given a higher priority in the priority list.2) Descending order Priority Queue: The root node is the maximum element in a max heap, as you may know. It will also remove the element with the highest priority first.Priority QueueHence Option(D) is the correct answer.",Queue,Easy,Low,0.25
128,"What is wrong in the below code of printing Right View of a binary tree using the Queue data structure?
        C++
        
        #include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

class Node {
public:
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

void printRightView(Node* root) {
    if (root == nullptr) return;

    queue&lt;Node*&gt; q;
    q.push(root);
    while (!q.empty()) {
        int n = q.size();
        for (int i = 0; i &lt; n; i++) {
            Node* x = q.front();
            q.pop();
            if (i == n - 1) {
                cout &lt;&lt; x-&gt;data &lt;&lt; &quot; &quot;;
            }
            if (x-&gt;left) {
                q.push(x-&gt;left);
            }
            if (x-&gt;right) {
                q.push(x-&gt;right);
            }
        }
    }
}

        
    
        C
        
        #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

void printRightView(struct Node* root) {
    if (root == NULL) return;

    struct Node** queue = (struct Node**)malloc(100 * sizeof(struct Node*));
    int front = 0, rear = 0;
    queue[rear++] = root;
    while (front &lt; rear) {
        int n = rear - front;
        for (int i = 0; i &lt; n; i++) {
            struct Node* x = queue[front++];
            if (i == n - 1) {
                printf(&quot;%d &quot;, x-&gt;data);
            }
            if (x-&gt;left) {
                queue[rear++] = x-&gt;left;
            }
            if (x-&gt;right) {
                queue[rear++] = x-&gt;right;
            }
        }
    }
    free(queue);
}

        
    
        Java
        
        import java.util.LinkedList;
import java.util.Queue;

class Node {
    int data;
    Node left, right;
    Node(int val) {
        data = val;
        left = right = null;
    }
}

public class Main {
    public static void printRightView(Node root) {
        if (root == null) return;

        Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();
        q.add(root);
        while (!q.isEmpty()) {
            int n = q.size();
            for (int i = 0; i &lt; n; i++) {
                Node x = q.poll();
                if (i == n - 1) {
                    System.out.print(x.data + &quot; &quot;);
                }
                if (x.left != null) {
                    q.add(x.left);
                }
                if (x.right != null) {
                    q.add(x.right);
                }
            }
        }
    }
}

        
    
        Python
        
        from collections import deque

class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def printRightView(root):
    if root is None:
        return

    q = deque([root])
    while q:
        n = len(q)
        for i in range(n):
            x = q.popleft()
            if i == n - 1:
                print(x.data, end=&#39; &#39;)
            if x.left:
                q.append(x.left)
            if x.right:
                q.append(x.right)

        
    
        JavaScript
        
        class Node {
    constructor(data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
}

function printRightView(root) {
    if (root === null) return;

    let q = [root];
    while (q.length) {
        let n = q.length;
        for (let i = 0; i &lt; n; i++) {
            let x = q.shift();
            if (i === n - 1) {
                process.stdout.write(x.data + &#39; &#39;);
            }
            if (x.left) q.push(x.left);
            if (x.right) q.push(x.right);
        }
    }
}",We have not initialized anything in the Queue,Queue will never be empty.,left and right nodes of the tree are null.,None,A,"We have to add the root node into the queue to access tree node's value. The correct code will look like this.void printRightView(Node* root){    if (root == NULL)        return;    queue&lt;Node*&gt; q;    q.push(root);    while (!q.empty()) {        int n = q.size();        while (n--) {            Node* x = q.front();            q.pop();            if (n == 0) {                cout &lt;&lt; x-&gt;data &lt;&lt; "" "";            }            if (x-&gt;left)                q.push(x-&gt;left);            if (x-&gt;right)                q.push(x-&gt;right);        }    }}Hence (A) is the correct option.",Queue,Hard,High,0.25
129,"Given a queue with a linked list implementation. the Rear pointer points to the rear node of the queue. and the front node of the queue points to the front node of the queue, Which of the following operations is impossible to do in O(1) time?&nbsp;",Delete the front item from the list.,Delete the rear from the list.,insert at the front of the list.,None,B,"A Queue is defined as a linear data structure that is open at both ends and the operations are performed in First In First Out (FIFO) order.&nbsp;Linked listIt takes O(N) time to traverse the complete list in order to delete the node at the end, as its predecessor node must be changed to NULL.Hence (B) is the correct option.",Queue,Hard,High,0.25
130,"Following function is supposed to calculate the maximum depth or height of a Binary tree -- the number of nodes along the longest path from the root node down to the farthest leaf node.


        C
        
        int maxDepth(struct node* node)
{
   if (node==NULL)
       return 0;
   else
   {
       /* compute the depth of each subtree */
       int lDepth = maxDepth(node-&gt;left);
       int rDepth = maxDepth(node-&gt;right);
 
       /* use the larger one */
       if (lDepth &gt; rDepth)
           return X;
       else return Y;
   }
}

        
    

What should be the values of X and Y so that the function works correctly?","X  = lDepth, Y = rDepth","X  = lDepth + 1, Y = rDepth + 1","X  = lDepth - 1, Y = rDepth -1",None of the above,C,"If a tree is not empty, height of tree is 
MAX(Height of Left Subtree, Height of Right Subtree) + 1

See program to Find the Maximum Depth or Height of a Tree for more details.",Tree,Medium,High,0.25
131,"What is common in three different types of traversals (Inorder, Preorder and Postorder)?",Root is visited before right subtree,Left subtree is always visited before right subtree,Root is visited after left subtree,All of the above,C,"The order of inorder traversal is 
LEFT ROOT RIGHT

The order of preorder traversal is
ROOT LEFT RIGHT

The order of postorder traversal is
LEFT RIGHT ROOT


In all three traversals, LEFT is traversed before RIGHT",Tree,Easy,Low,0.25
132,"The inorder and preorder traversal of a binary tree are d b e a f c g and a b d e c f g, respectively. The postorder traversal of the binary tree is:",d e b f g c a,e d b g f c a,e d b f g c a,d e f g b c a,B,"Below is the given tree.
                              a
                           /    \\
                        /          \\
                      b             c
                   /   \\          /   \\
                 /       \\      /       \\
               d         e    f          g",Tree,Hard,High,0.25
133,"What does the following function do for a given binary tree?


        C
        
        int fun(struct node *root)
{
   if (root == NULL)
      return 0;
   if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
      return 0;
   return 1 + fun(root-&gt;left) + fun(root-&gt;right);
}",Counts leaf nodes,Counts internal nodes,Returns height where height is defined as number of edges on the path from root to deepest node,Return diameter where diameter is number of edges on the longest path between any two nodes.,C,"The function counts internal nodes.
1) If root is NULL or a leaf node, it returns 0.
2) Otherwise returns, 1 plus count of internal nodes in left subtree, plus count of internal nodes in right subtree.

See the following complete program.

        C
        
        #include &lt;stdio.h&gt;

struct node
{
  int key;
  struct node *left, *right;
};

int fun(struct node *root)
{
   if (root == NULL)
      return 0;
   if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
      return 0;
   return 1 + fun(root-&gt;left) + fun(root-&gt;right);
}

/* Helper function that allocates a new node with the
   given key and NULL left and right pointers. */
struct node* newNode(int key)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;key = key;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* Driver program to test above functions*/
int main()
{

  /* Constructed binary tree is
            1
          /   \\
        2      3
      /  \\    /
    4     5  8
  */
  struct node *root = newNode(1);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  root-&gt;left-&gt;left  = newNode(4);
  root-&gt;left-&gt;right = newNode(5);
  root-&gt;right-&gt;left = newNode(8);

  printf(&quot;%d&quot;, fun(root));

  getchar();
  return 0;
}",Tree,Medium,High,0.25
134,Which of the following pairs of traversals is not sufficient to build a binary tree from the given traversals?,Preorder and Inorder,Preorder and Postorder,Inorder and Postorder,None of the Above,C,See  http://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/ for details.,Tree,Medium,High,0.25
135,Consider two binary operators '[Tex]\uparrow[/Tex] ' and '[Tex]\downarrow[/Tex]' with the precedence of operator [Tex]\downarrow[/Tex] being lower than that of the [Tex]\uparrow[/Tex] operator. Operator [Tex]\uparrow[/Tex] is right associative while operator [Tex]\downarrow[/Tex] is left associative. Which one of the following represents the parse tree for expression (7 [Tex]\downarrow[/Tex] 3 ­[Tex]\uparrow[/Tex] 4 ­[Tex]\uparrow[/Tex] 3 [Tex]\downarrow[/Tex] 2)? (GATE CS 2011),A,B,C,D,B,"Let us consider the given expression ([Tex]7 \downarrow 3 \uparrow 4 \uparrow 3 \downarrow 2[/Tex]).  Since the precedence of [Tex]\uparrow[/Tex] is higher, the sub-expression ([Tex]3 \uparrow 4 \uparrow 3[/Tex]) will be evaluated first. In this sub-expression, [Tex]4 \uparrow 3[/Tex] would be evaluated first because [Tex]\uparrow[/Tex] is right to left associative. So the expression is evaluated as [Tex]((7 \downarrow (3 \uparrow (4 \uparrow 3))) \downarrow 2)[/Tex]. Also, note that among the two [Tex]\downarrow [/Tex] operators, first one is evaluated before the second one because the associativity of [Tex]\downarrow[/Tex] is left to right.",Tree,Hard,High,0.25
136,Which traversal of tree resembles the breadth first search of the graph?,Preorder,Inorder,Postorder,Level order,E,Breadth first search visits all the neighbors first and then deepens into each neighbor one by one. The level order traversal of the tree also visits nodes on the current level and then goes to the next level.,Tree,Easy,Low,0.25
137,Which of the following tree traversal uses a queue data structure?,Preorder,Inorder,Postorder,Level order,E,Level order traversal uses a queue data structure to visit the nodes level by level.,Tree,Easy,Low,0.25
138,Which of the following cannot generate the full binary tree?,Inorder and Preorder,Inorder and Postorder,Preorder and Postorder,None of the above,E,"To generate a binary tree, two traversals are necessary and one of them must be inorder. But, a full binary tree can be generated from preorder and postorder traversals. Read the algorithm here.
Read Can tree be constructed from given traversals?",Tree,Medium,High,0.25
139,"Consider the following C program segment


        c
        
        struct CellNode
{
  struct CelINode *leftchild;
  int element;
  struct CelINode *rightChild;
}

int Dosomething(struct CelINode *ptr)
{
    int value = 0;
    if (ptr != NULL)
    {
      if (ptr-&gt;leftChild != NULL)
        value = 1 + DoSomething(ptr-&gt;leftChild);
      if (ptr-&gt;rightChild != NULL)
        value = max(value, 1 + DoSomething(ptr-&gt;rightChild));
    }
    return (value);
}

        
    

The value returned by the function DoSomething when a pointer to the root of a non-empty tree is passed as argument is  (GATE CS 2004)",The number of leaf nodes in the tree,The number of nodes in the tree,The number of internal nodes in the tree,The height of the tree,E,"Explanation: DoSomething() returns max(height of left child + 1, height of right child + 1).  So given that pointer to root of tree is passed to DoSomething(), it will return height of the tree. Note that this implementation follows the convention where height of a single node is 0.",Tree,Hard,High,0.25
140,"Let LASTPOST, LASTIN and LASTPRE denote the last vertex visited in a postorder, inorder and preorder traversal. Respectively, of a complete binary tree. Which of the following is always true? (GATE CS 2000)",LASTIN = LASTPOST,LASTIN = LASTPRE,LASTPRE = LASTPOST,None of the above,E,"It is given that the given tree is complete binary tree. For a complete binary tree, the last visited node will always be same for inorder and preorder traversal.  None of the above is true even for a complete binary tree. The option (a) is incorrect because the last node visited in Inorder traversal is right child and last node visited in Postorder traversal is root.The option (c) is incorrect because the last node visited in Preorder traversal is right child and last node visited in Postorder traversal is root.For option (b), see the following counter example. Thanks to Hunaif Muhammed for providing the correct explanation.
     1
   /    \\
  2      3
 / \\    /
4   5  6  

Inorder traversal is 4 2 5 1 6 3
Preorder traversal is 1 2 4 5 3 6",Tree,Hard,High,0.25
141,The array representation of a complete binary tree contains the data in sorted order. Which traversal of the tree will produce the data in sorted form?,Preorder,Inorder,Postorder,Level order,E,The level order traversal of a binary tree prints the data in the same order as it is stored in the array representation of a complete binary tree.,Tree,Easy,Low,0.25
142,"Consider the following rooted tree with the vertex P labeled as root



The order in which the nodes are visited during in-order traversal is",SQPTRWUV,SQPTURWV,SQPTWUVR,SQPTRUWV,B,"Algorithm Inorder(tree) - Use of Recursion
Steps:
1. Traverse the left subtree, 
   i.e., call Inorder(left-subtree)
2. Visit the root.
3. Traverse the right subtree, 
   i.e., call Inorder(right-subtree)

Understanding this algorithm requires the basic 
understanding of Recursion

Therefore, We begin in the above tree with root as
the starting point, which is P.

# Step 1( for node P) :
Traverse the left subtree of node or root P.
So we have node Q on left of P.

-> Step 1( for node Q)
Traverse the left subtree of node Q.
So we have node S on left of Q.

* Step 1 (for node S)
Now again traverse the left subtree of node S which is 
NULL here.

* Step 2(for node S)
Visit the node S, i.e print node S as the 1st element of 
inorder traversal.

* Step 3(for node S)
Traverse the right subtree of node S.
Which is NULL here.

Now move up in the tree to Q which is parent
of S.( Recursion, function of Q called for function of S).
Hence we go back to Q.

-> Step 2( for node Q):
Visit the node Q, i.e print node Q as the 2nd
element of inorder traversal.

-> Step 3 (for node Q)
Traverse the right subtree of node Q.
Which is NULL here.

Now move up in the tree to P which is parent
of Q.( Recursion, function of P called for function of Q).
Hence we go back to P.

# Step 2(for node P)
Visit the node P, i.e print node S as the 3rd
element of inorder traversal.

# Step 3 (for node P)
Traverse the right subtree of node P.
Node R is at the right of P.

Till now we have printed SQP as the inorder of the tree. 
Similarly other elements can be obtained by traversing 
the right subtree of P.

The final correct order of Inorder traversal would 
be SQPTRWUV.",Tree,Medium,High,0.25
143,"Consider the pseudocode given below. The function DoSomething() takes as argument a pointer to the root of an arbitrary tree represented by the leftMostChild-rightSibling representation.
Each node of the tree is of type treeNode.


        C
        
        typedef struct treeNode* treeptr;
struct treeNode
{
    treeptr leftMostChild, rightSibling;
};
int DoSomething (treeptr tree)
{
    int value=0;
    if (tree != NULL)
    {
        if (tree-&gt;leftMostChild == NULL)
            value = 1;
        else
            value = DoSomething(tree-&gt;leftMostChild);
        value = value + DoSomething(tree-&gt;rightSibling);
    }
    return(value);
}

        
    

When the pointer to the root of a tree is passed as the argument to DoSomething, the value returned by the function corresponds to the",number of internal nodes in the tree.,height of the tree.,number of nodes without a right sibling in the tree.,number of leaf nodes in the tree.,E,"The function counts leaf nodes for a tree represented using leftMostChild-rightSibling representation.

Below is function with comments added to demonstrate how function works.


        C
        
        int DoSomething (treeptr tree)
{
    // If tree is empty, 0 is returned
    int value = 0;

    // IF tree is not empty
    if (tree != NULL)
    {
        // IF this is a leaf node, then values is initialized as 1
        if (tree-&gt;leftMostChild == NULL)
            value = 1;

        // Else value is initialized as the value returned by leftmost
        // child which in turn calls for the other children of this node
        // Using last call &quot;value = value + DoSomething(tree-&gt;rightSibling);&quot;
        else
            value = DoSomething(tree-&gt;leftMostChild);

        // Add value returned by right sibling
        value = value + DoSomething(tree-&gt;rightSibling);
    }
    return(value);
}",Tree,Hard,High,0.25
144,Level order traversal of a rooted tree can be done by starting from the root and performing,preorder traversal,inorder traversal,depth first search,breadth first search,D,"Level order traversal of a rooted tree, also known as breadth-first traversal, can be done by starting from the root and visiting each level of the tree from left to right. Here's how it can be performed:1. Enqueue the root node into a queue.2. While the queue is not empty, repeat steps 3-5:   3. Dequeue a node from the front of the queue and visit it.   4. Enqueue all the children (if any) of the dequeued node from left to right.   5. Repeat until all nodes at the current level are visited.6. Continue until all levels of the tree are traversed.Here's a pseudocode representation of the algorithm:```levelOrderTraversal(root):    if root is NULL:        return    create an empty queue    enqueue root into the queue    while queue is not empty:        current = dequeue from the front of the queue        visit current node        for each child of current (if any):            enqueue child into the queue```This algorithm ensures that nodes at each level of the tree are visited before proceeding to the next level. It effectively traverses the tree in a breadth-first manner, starting from the root.",Tree,Easy,Low,0.25
145,"Consider the label sequences obtained by the following pairs of traversals on a labeled binary tree. Which of these pairs identify a tree uniquely ? 
(i)     preorder and postorder
(ii)    inorder and postorder
(iii)   preorder and inorder
(iv)   level order and postorder",(i) only,"(ii), (iii)",(iii) only,(iv) only,C,"Here, we consider each and every option to check whether it is true or false.

1) Preorder and postorder


For the above trees,

Preorder is AB

Postorder is BA

It shows that preorder and postorder can’t identify a tree uniquely.

2) Inorder and postorder define a tree uniquely

3) Preorder and Inorder also define a tree uniquely

4) Levelorder and postorder can’t define a tree uniquely. For the above example,

Level order is AB

Postorder is BA

See http://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/ for details


This solution is contributed by Anil Saikrishna Devarasetty",Tree,Hard,High,0.25
146,"Let LASTPOST, LASTIN and LASTPRE denote the last vertex visited in a postorder, inorder and preorder traversal, respectively, of a complete binary tree. Which of the following is always true?",LASTIN = LASTPOST,LASTIN = LASTPRE,LASTPRE = LASTPOST,None of the above,E,See question 1 of http://www.geeksforgeeks.org/data-structures-and-algorithms-set-1/,Tree,Hard,High,0.25
147,"Which one of the following binary trees has its inorder and preorder traversals as BCAD  and ABCD, respectively?",A,B,C,D,E,"Inorder Traversal: Left -Root -RightPreOrder Traversal: Root-Left-Right
    InOrder  PreOrder

A.   BADC   ABCD

B.   BCAD   ACBD

C.   ACBD   ABCD
D.    BCAD  ABCDTherefore, D is Correct",Tree,Hard,High,0.25
148,"The numbers 1, 2, .... n are inserted in a binary search tree in some order. In the resulting tree, the right subtree of the root contains p nodes. The first number to be inserted in the tree must be",p,p + 1,n - p,n - p + 1,D,"Binary Search Tree, is a node-based binary tree data structure which has the following properties:

	The left subtree of a node contains only nodes with keys less than the node’s key.
	The right subtree of a node contains only nodes with keys greater than the node’s key.
	The left and right subtree each must also be a binary search tree.
There must be no duplicate nodes.


So let us say n=10, p=4. According to BST property the root must be 10-4=6 (considering all unique elements in BST)
And according to BST insertion, root is the first element to be inserted in a BST.

Therefore, the answer is (n-p).
&nbsp;",Tree,Hard,High,0.25
149,"A binary search tree contains the numbers 1, 2, 3, 4, 5, 6, 7, 8. When the tree is traversed in pre-order and the values in each node printed out, the sequence of values obtained is 5, 3, 1, 2, 4, 6, 8, 7. If the tree is traversed in post-order, the sequence obtained would be

&nbsp;","8, 7, 6, 5, 4, 3, 2, 1","1, 2, 3, 4, 8, 7, 6, 5","2, 1, 4, 3, 6, 7, 8, 5","2, 1, 4, 3, 7, 8, 6, 5",E,"Please see this link for more details

http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/",Tree,Hard,High,0.25
150,"Consider the following sequence of nodes for the undirected graph given below.

a b e f d g c
a b e f c g d
a d g e b c f
a d b c g e f
A Depth First Search (DFS) is started at node a. The nodes are listed in the order they are first visited. Which all of the above is (are) possible output(s)?",1 and 3 only,2 and 3 only,"2, 3 and 4 only","1, 2, and 3",C,"1: abef->c or g should be covered
4: adbc->e or f should be covered 
2: abefcgd  correct
3: adgebcf correct",Tree,Hard,High,0.25
151,Which of the following statement is false?,A tree with n nodes has (n-1) edges.,A labeled rooted binary tree can be uniquely constructed given its postorder and preorder traversal results.,A complete binary tree with n internal nodes has (n+1) leaves.,The maximum number of nodes in a binary tree of height h is (2^(h+1)  -1).,C,"Both option (A) and (D) are correct. But option (B) is false because ""a labeled rooted binary tree can not be uniquely constructed given using its postorder and preorder traversal results"". It need inorder and preorder/postorder for uniquely constructed binary tree.

Option (C) is also false, take counter example in given tree :


Therefore, both option (B) and (C) are false.",Tree,Medium,Medium,0.25
152,"A complete n-ary tree is one in which every node has 0 or n sons. If x is the number of internal nodes of a complete n-ary tree, the number of leaves in it is given by",x(n-1)+1,xn-1,xn+1,x(n+1),B,,Tree,Hard,High,0.25
153,"Which of the following sequences denotes the post order traversal sequence of the given tree?
         a
       /   \\
      b     e
     / \\   /
    c  d  f
   /
  g",f e g c d b a,g c b d a f e,g c d b f e a,f e d g c b a,D,,Tree,Medium,Medium,0.25
154,Which of following option is not correct regarding depth first searching?,"In a depth-first traversal of a graph G with V vertices, E edges are marked as tree edges. The number of connected components in G is (E - V).",Depth-first search requires O(V^2) time if implemented with an adjacency matrix.,Depth-first search requires O(V + E) time if implemented with adjacency lists,None of these,B,"In a depth-first traversal of a graph G with V vertices, E edges are marked as tree edges. The number of connected components in G is (V - E).
Only option (A) is false.",Tree,Hard,High,0.25
155,"The post-order traversal of a binary search tree is given by 2, 7, 6, 10, 9, 8, 15, 17, 20, 19, 16, 12.
Then the pre-order traversal of this tree is:","2, 6, 7, 8, 9, 10, 12, 15, 16, 17, 19, 20","7, 6, 2, 10, 9, 8, 15, 16, 17, 20, 19, 12","7, 2, 6, 8, 9, 10, 20, 17, 19, 15, 16, 12","12, 8, 6, 2, 7, 9, 10, 16, 15, 19, 17, 20",E,"Since given tree is binary tree, so inorder traversal will be always sorted order, i.e., 2, 6, 7, 8, 9, 10, 12, 15, 16, 17, 19, 20. 
Now we can draw that binary search tree using given postorder and inorder traversal. Final tree will be:



Therefore, preorder traversal will be : 12, 8, 6, 2, 7, 9, 10, 16, 15, 19, 17, 20. 

Option (D) is correct.",Tree,Hard,High,0.25
156,"Let G be a simple undirected graph. Let TD be a depth first search tree of G. Let TB be a breadth first search tree of G. Consider the following statements. (I) No edge of G is a cross edge with respect to TD. (A cross edge in G is between two nodes neither of which is an ancestor of the other in TD). (II) For every edge (u, v) of G, if u is at depth i and v is at depth j in TB, then ∣i − j∣ = 1. Which of the statements above must necessarily be true?",I only,II only,Both I and II,Neither I nor II,A,"There are four types of edges can yield in DFS. These are tree, forward, back, and cross edges. In undirected connected graph, forward and back edges are the same thing. A cross edge in a graph is an edge that goes from a vertex v to another vertex u such that u is neither an ancestor nor descendant of v. Therefore, cross edge is not possible in undirected graph. So, statement (I) is correct. For statement (II) take counterexample of complete graph of three vertices, i.e., K3 with XYZ, where X is source and Y and Z are in same level. Also,there is an edge between vertices Y and Z, i.e., |i-j| = 0 ≠ 1 in BFS. So, statement became false. Option (A) is correct.",Tree,Medium,High,0.25
157,"Suppose the numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree. The binary search tree uses the reversal ordering on natural numbers i.e. 9 is assumed to be smallest and 0 is assumed to be largest. The in-order traversal of the resultant binary search tree is","9, 8, 6, 4, 2, 3, 0, 1, 5, 7","0, 1, 2, 3, 4, 5, 6, 7, 8, 9","0, 2, 4, 3, 1, 6, 5, 9, 8, 7","9, 8, 7, 6, 5, 4, 3, 2, 1, 0",E,"Inorder traversal of a binary search tree always produces the keys in increasing order. In this question Reverse ordering of natural numbers are used i.e. 9 is assumed to be the smallest and 0 to be the largest. So the sequence in increasing order will be 9, 8, 7, 6, 5, 4, 3, 2, 1, 0.
So, option (D) is correct.",Tree,Hard,High,0.25
158,The in-order and pre-order traversal of a binary tree are d b e a f c g and a b d e c f g respectively. The post order traversal of a binary tree is,e d b g f c a,e d b f g c a,d e b f g c a,d e f g b c a,D,"Refer:  GATE-CS-2007 | Question 39 

Option (C) is correct.",Tree,Hard,High,0.25
159,"Consider the following tree



If the post order traversal gives ab-cd*+ then the label of the nodes 1,2,3,… will be","+,-,*,a,b,c,d","a,-,b,+,c,*,d","a,b,c,d,-,*,+","-,a,b,+,*,c,d",B,"Postorder traversal of the given binary tree will give the following sequence: 4 5 2 6 7 3 1.
Now comparing the sequence with a b - c d * + we get 1 = +, 2 = -, 3 = *, 4 = a, 5 = b, 6 = c and 7 = d.
So, option (A) is correct.",Tree,Hard,High,0.25
160,"Choose the equivalent prefix form of the following expression
(a + (b − c))* ((d − e)/(f + g − h))",* +a − bc /− de − +fgh,* +a −bc − /de − +fgh,* +a − bc /− ed + −fgh,* +ab − c /− ed + −fgh,B,"We can write the prefix form of the expression as:
(a + (b − c))* ((d − e) / (f + g − h))
= (a + (- b c)) * ((- d e) / ( + f g - h))
= (+ a - b c) * ((- d e) / (- + f g h)
= (+ a - b c) * (/ - d e - + f g h)
= * + a - b c / - d e - + f g h",Tree,Hard,High,0.25
161,"The number of rotations required to insert a sequence of elements 9,6,5,8,7,10 into an empty AVL tree is?",0,1,2,3,E,"The insertion and rotation of the various elements are shown in the following figure:

 

So, the total number of rotations are 3.",Tree,Medium,Medium,0.25
162,"Consider the following statements: 
(a) Depth - first search is used to traverse a rooted tree. 
(b) Pre - order, Post-order and Inorder are used to list the vertices of an ordered rooted tree. 
(c) Huffman’s algorithm is used to find an optimal binary tree with given weights. 
(d) Topological sorting provides a labelling such that the parents have larger labels than their children. 
Which of the above statements are true?",(a) and (b),(c) and (d),"(a), (b) and (c)","(a), (b), (c) and (d)",E,"Depth - first search is used to traverse a rooted tree. Correct Pre - order, Post-order and Inorder are used to list the vertices of an ordered rooted tree. CorrectHuffman’s algorithm is used to find an optimal binary tree with given weights. CorrectTopological sorting provides a labelling such that the parents have larger labels than their children.Correct
So, option (D) is correct.",Tree,Hard,High,0.25
163,The inorder and preorder Traversal of binary Tree are dbeafcg and abdecfg respectively. The post-order Traversal is __________.,dbefacg,debfagc,dbefcga,debfgca,E,"Inorder and preorder Traversal of binary Tree are dbeafcg and abdecfg respectively. 
From preorder(Parent left right) and inorder ( left parent right) we can easily find post order. 
From preorder(a(bdecfg)), it is clear that a is parent node(root node), Now we will look for left subttree in inorder traversal i.e. dbe and fcg.
To find root node and left subtree and right subtree of these subtree we will do the same process as above:
Now see this scenario in graph:

Now from above tree we can easily find out the post order(left right parent):
i.e. debfgca.
So, option (D) is correct.",Tree,Easy,Low,0.25
164,Level order Traversal of a rooted Tree can be done by starting from root and performing:,Breadth First Search,Depth First Search,Root Search,Deep Search,B,"Level order Traversal of a rooted Tree can be done by starting from root and performing Breadth First Search.
For more information on Level order Traversal Refer:Level Order Tree Traversal
Option (A) is correct.",Tree,Hard,High,0.25
165,The in-order traversal of a tree resulted in FBGADCE. Then the pre-order traversal of that tree would result in,FGBDECA,ABFGCDE,BFGCDEA,AFGBDEC,C,"The Inorder traversal of the tree can be seen as:



So, the preorder traversal of the following tree is ABFGCDE.

Option (B) is correct.",Tree,Medium,High,0.25
166,"Suppose the numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree. The binary search tree uses the usual ordering on natural numbers. What is the inorder traversal sequence of the resultant tree?",7 5 1 0 3 2 4 6 8 9,0 2 4 3 1 6 5 9 8 7,0 1 2 3 4 5 6 7 8 9,9 8 6 4 2 3 0 1 5 7,D,"The numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree with the usual ordering on natural numbers. The inorder sequence of such a binary search tree always yields to the numbers arranged in ascending order. 
So, option (C) is correct.",Tree,Hard,High,0.25
167,"Assume that the operators +, −, × are left associative and ^ is right associative. The order of precedence (from highest to lowest) is ^, ×, +, −. The postfix expression corresponding to the infix expression is
a + b × c − d ^ e ^ f",abc x  + def ^ ^ −,abc x + de ^ f ^ −,ab + c × d − e^f^,− + a × b c^^ def,B,"The postfix expression:
a + b × c − ( d ^( e ^ f))
a + b × c − ( d ^( e f ^ ))
a + b × c − ( d e f ^ ^)
(a + (b × c)) − d  e f ^ ^
(a + (b c x)) − d  e f ^ ^
(a (b c x) +) − d  e f ^ ^
(a b c x +) - (d e f ^ ^)
(a b c x +) - (d e f ^ ^)
a b c x + d e f ^ ^ -

So, option (A) is correct.",Tree,Hard,High,0.25
168,"If Tree-1 and Tree-2 are the trees indicated below :  Which traversals of Tree-1 and Tree-2, respectively, will produce the same sequence?","Preorder, postorder","Postorder, inorder","Postorder, preorder","Inorder, preorder",C,"Postorder, Inorder will be correct answer here.",Tree,Medium,Medium,0.25
169,"If all the edge weights of an undirected graph are positive, then any subset of edges that connects all the vertices and has minimum total weight is a

&nbsp;",Hamiltonian cycle,grid,hypercube,tree,E,"&nbsp;

As here we want subset of edges that connects all the vertices and has minimum total weight i.e. Minimum Spanning Tree
Option A - includes cycle, so may or may not connect all edges.
Option B - has no relevance to this question.
Option C - includes cycle, so may or may not connect all edges.

Related:
http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/
http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/

This solution is contributed by Mohit Gupta.

&nbsp;",Tree,Hard,High,0.25
170,"The following three are known to be the preorder, inorder and postorder sequences of a binary tree. But it is not known which is which.
MBCAFHPYK
KAMCBYPFH
MABCKYFPH
Pick the true statement from the following.","I and II are preorder and inorder sequences, respectively","I and III are preorder and postorder sequences, respectively","II is the inorder sequence, but nothing more can be said about the other two sequences","II and III are the preorder and inorder sequences, respectively",E,"The approach to solve this question is to first find 2 sequences whose first and last element is same. The reason being first element in the Pre-order of any binary tree is the root and last element in the Post-order of any binary tree is the root.
Looking at the sequences given, 
Pre-order   =   KAMCBYPFH
Post-order  =  MBCAFHPYK
Left-over sequence  MABCKYFPH will be in order.
Since we have all the traversals identified, let's try to draw the binary tree if possible.



I. Post order
II. Pre order
III. Inorder


This solution is contributed by Pranjul Ahuja.",Tree,Hard,High,0.25
171,"When searching for the key value 60 in a binary search tree, nodes containing the key values 10, 20, 40, 50, 70 80, 90 are traversed, not necessarily in the order given. How many different orders are possible in which these key values can occur on the search path from the root to the node containing the value 60?",35,64,128,5040,B,"There are two set of values, smaller than 60 and greater than 60. Smaller values 10, 20, 40 and 50 are visited, means they are visited in order. Similarly, 90, 80 and 70 are visited in order. 
= 7!/(4!3!)
= 35",Tree,Medium,Medium,0.25
172,Which of the following is true about Binary Trees?,Every binary tree is either complete or full.,Every complete binary tree is also a full binary tree.,Every full binary tree is also a complete binary tree.,No binary tree is both complete and full.,F,"A full binary tree (sometimes proper binary tree or 2-tree or strictly binary tree) is a tree in which every node other than the leaves has two children. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. A) is incorrect. For example, the following Binary tree is neither complete nor full     12
   /  
  20
 /
30
B) is incorrect. The following binary tree is complete but not full     12
   /   \\
  20    30
 /
30
C) is incorrect. Following Binary tree is full, but not complete     12
   /   \\
  20    30
       /  \\  
      20   40
D) is incorrect. Following Binary tree is both complete and full      12
    /   \\
   20    30
  /  \\  
 10   40",Tree,Medium,Medium,0.25
173,"If arity of operators is fixed, then which of the following notations can be used to parse expressions without parentheses? a) Infix Notation (Inorder traversal of a expression tree) b) Postfix Notation (Postorder traversal of a expression tree) c) Prefix Notation (Preorder traversal of a expression tree)",b and c,Only b,"a, b and c",None of them,B,Preorder and Postorder notations are used to parse expressions without parentheses.,Tree,Medium,Medium,0.25
174,"What are the main applications of tree data structure?Manipulate hierarchical data&nbsp;Make information easy to search &nbsp;Manipulate sorted lists of data&nbsp;Router algorithms&nbsp;Form of a multi-stage decision-making, like Chess Game.&nbsp;As a workflow for compositing digital images for visual effects","1, 2, 3, 4 and 6","1, 2, 3, 4 and 5","1, 3, 4, 5 and 6","1, 2, 3, 4, 5 and 6",E,Tree data structure is used to study or tabulate hierarchical data. Searching of data becomes easy using the tree traversals. Using BST we can easily analyze sorted data. Decision making to reach an objective becomes easy due to decision tree creation. Trees are used in router algorithms. They can be beneficial as a workflow for compositing digital images for visual effects.,Tree,Medium,Medium,0.25
175,"Level of a node is distance from root to that node. For example, level of root is 1 and levels of left and right children of root is 2. The maximum number of nodes on level i of a binary tree is 

In the following answers, the operator '^' indicates power.",2^(i-1),2^i,2^(i+1),2^[(i+1)/2],B,"Number of nodes of binary tree will be maximum only when tree is full complete, therefore answer is 2^(i)-1
So, option (A) is true.",Tree,Hard,High,0.25
176,"In a complete k-ary tree, every internal node has exactly k children or no child. The number of leaves in such a tree with n internal nodes is:",nk,(n – 1) k+ 1,n( k – 1) + 1,n(k – 1),D,"For an k-ary tree where each node has k children or no children, following relation holdsL = (k-1)*n + 1Where L is the number of leaf nodes and n is the number of internal nodes.Let us see following for example 
             o
        /    |    \\
      o      o      o
   / | \\          / | \\
  o  o  o        o  o  o
                  / | \\
                 o  o  o

k = 3
Number of internal nodes n = 4
Number of leaf nodes = (k-1)*n  + 1
                     = (3-1)*4 + 1
                     = 9",Tree,Medium,Medium,0.25
177,The maximum number of binary trees that can be formed with three unlabelled nodes is:,1,5,4,3,C,"Certainly, here's the revised presentation of the unlabeled binary trees:&nbsp;Note that nodes are unlabeled. If the nodes are labeled, we get more trees. We can find the number of binary tree by Catalan numbers. Here n = 3 Number of binary tree = (2nCn)/ n+1 = (2*3C3)/ 3+1 = 5. So, option (B) is correct.",Tree,Hard,High,0.25
178,"The number of leaf nodes in a rooted tree of n nodes, with each node having 0 or 3 children is:",n/2,(n-1)/3,(n-1)/2,(2n+1)/3,E,"In a tree with nodes, some having 0 or 3 children:Let's call:n - as the total number of nodes.L -the number of leaf nodes.I - as the number of internal nodes.Now, here's the deal: each internal node with 3 children gives us 2 internal nodes and 1 leaf node. The root node doesn't play a role here, so we can say (L = 2I + 1).And we know that the total number of nodes n is just the sum of leaf nodes L and internal nodes I: n = L + INow, if we substitute the L value from the first equation into the second one, we get n = (2I + 1) + I, which simplifies to n = 3I + 1.Solving this for I, we find I = (n-1)/3Now, plug this back into the L equation, and we get L = 2((n-1)/3) + 1, which simplifies to L = (2n+1)/3.So, in simple terms, the number of leaf nodes L in a tree with nodes having 0 or 3 children is (2n+1)/3.",Tree,Hard,High,0.25
179,A weight-balanced tree is a binary tree in which for each node. The number of nodes in the left sub tree is at least half and at most twice the number of nodes in the right sub tree. The maximum possible height (number of nodes on the path from the root to the farthest leaf) of such a tree on n nodes is best described by which of the following? a) \\log_2 n b) \\log_{4/3} n c) \\log_3 n d) \\log_{3/2} n,A,B,C,D,E,"A weight-balanced tree is a binary tree where the number of nodes in the left subtree is at least half and at most twice the number of nodes in the right subtree for each node. To determine the maximum possible height of such a tree on n nodes, let's analyze the options:a) &nbsp;This represents the height of a perfectly balanced binary tree. In a weight-balanced tree, the left subtree can have at most twice the number of nodes in the right subtree, so it won't necessarily be perfectly balanced. Therefore, option a is not the best description.b)This option seems to be a non-standard logarithmic base. It's not a common logarithmic base used in tree height analysis. It is not a typical representation for the height of a binary tree.c) This represents the height of a perfectly balanced ternary tree. Similar to option a, this doesn't consider the constraints of a weight-balanced tree.d) &nbsp;This option is interesting because it suggests a growth factor in the number of nodes in the left subtree compared to the right subtree. It is a non-standard base but seems to reflect the constraints of a weight-balanced tree.In a weight-balanced tree, the number of nodes in the left subtree is at least half and at most twice the number of nodes in the right subtree. Therefore, option (d) is the best description of the maximum possible height of a weight-balanced tree on n nodes.",Tree,Hard,High,0.25
180,"A complete n-ary tree is a tree in which each node has n children or no children. Let I be the number of internal nodes and L be the number of leaves in a complete n-ary tree. If L = 41, and I = 10, what is the value of n?",6,3,4,5,E,"For an n-ary tree where each node has n children or no children, following relation holds    L = (n-1)*I + 1
Where L is the number of leaf nodes and I is the number of internal nodes.Let us find out the value of n for the given data.  L = 41 , I = 10
  41 = 10*(n-1) + 1
  (n-1) = 4
  n = 5",Tree,Medium,Medium,0.25
181,The height of a binary tree is the maximum number of edges in any root to leaf path. The maximum number of nodes in a binary tree of height h is:,2^h -1,2^(h-1) – 1,2^(h+1) -1,2*(h+1),D,"Maximum number of nodes will be there for a complete tree.
Number of nodes in a complete tree of height h = 1 + 2 + 2^2 + 2*3 + …. 2^h = 2^(h+1) – 1",Tree,Hard,High,0.25
182,"A scheme for storing binary trees in an array X is as follows. Indexing of X starts at 1 instead of 0. the root is stored at X[1]. For a node stored at X[i], the left child, if any, is stored in X[2i] and the right child, if any, in X[2i+1]. To be able to store any binary tree on n vertices the minimum size of X should be. (GATE CS 2006)",log2n,n,2n + 1,2^n — 1,E,"For a right skewed binary tree, number of nodes will be 2^n -  1.  For example, in below binary tree, node 'A' will be stored at index 1, 'B' at index 3, 'C' at index 7 and 'D' at index 15.
A
 \
   \
    B
      \
        \
         C
           \
             \
              D",Tree,Hard,High,0.25
183,"Postorder traversal of a given binary search tree, T produces the following sequence of keys 
        10, 9, 23, 22, 27, 25, 15, 50, 95, 60, 40, 29
Which one of the following sequences of keys can be the result of an in-order traversal of the tree T? (GATE CS 2005)","9, 10, 15, 22, 23, 25, 27, 29, 40, 50, 60, 95","9, 10, 15, 22, 40, 50, 60, 95, 23, 25, 27, 29","29, 15, 9, 10, 25, 22, 23, 27, 40, 60, 50, 95","95, 50, 60, 40, 27, 23, 22, 25, 10, 9, 15, 29",B,"Inorder traversal of a BST always gives elements in increasing order.  Among all four options, a) is the only increasing order sequence.",Tree,Medium,High,0.25
184,"Consider the following nested representation of binary trees: (X Y Z) indicates Y and Z are the left and right sub stress, respectively, of node X. Note that Y and Z may be NULL, or further nested. Which of the following represents a valid binary tree?",(1 2 (4 5 6 7)),(1 (2 3 4) 5 6) 7),(1 (2 3 4)(5 6 7)),(1 (2 3 NULL) (4 5)),D,"C is fine.
(1 (2 3 4)(5 6 7))  represents following binary tree
      1
   /    \\
  2      5 
 / \\    / \\
3   4  6   7
A) (1 2 (4 5 6 7)) is not fine as there are 4 elements in one bracket.B)  (1 (2 3 4) 5 6) 7) is not fine as there are 2 opening brackets and 3 closing.D)  (1 (2 3 NULL) (4 5)) is not fine one bracket has only two entries (4 5)",Tree,Hard,High,0.2
185,"Consider a node X in a Binary Tree.  Given that X has two children, let Y be Inorder successor of X. Which of the following is true about Y?",Y has no right child,Y has no left child,Y has both children,None of the above,C,"Since X has both children, Y must be leftmost node in right child of X.",Tree,Hard,High,0.25
186,"In a binary tree with n nodes, every node has an odd number of descendants. Every node is considered to be its own descendant. What is the number of nodes in the tree that have exactly one child?",0,1,(n-1)/2,n-1,B,"It is mentioned that each node has odd number of descendants including node itself, so all nodes must have even number of descendants 0, 2, 4 so on.   Which means each node should have either 0 or 2 children. So there will be no node with 1 child.  Hence 0 is answer.Following are few examples. 
       a
    /    \\
   b      c


      a
    /   \\
   b     c  
  /  \\
 d    e
  Such a binary tree is full binary tree (a binary tree where every node has 0 or 2 children).",Tree,Medium,High,0.25
187,The height of a binary tree is the maximum number of edges in any root to leaf path. The maximum number of nodes in a binary tree of height h is:,2h−1,2h−1 -1,2h+1-1,2h+1,D,See Question 1 http://www.geeksforgeeks.org/data-structures-and-algorithms-set-10/,Tree,Easy,Medium,0.3
188,The height of a tree is the length of the longest root-to-leaf path in it. The maximum and minimum number of nodes in a binary tree of height 5 are,"63 and 6, respectively","64 and 5, respectively","32 and 6, respectively","31 and 5, respectively",A,"Number of nodes is maximum for a perfect binary tree.A perfect binary tree of height h has 2h+1 - 1 nodesNumber of nodes is minimum for a skewed binary tree.A perfect binary tree of height h has h+1 nodes.So according to the question and after analyzing the options, Option (A) is correct.",Tree,Medium,High,0.25
189,A binary tree T has 20 leaves. The number of nodes in T having two children is,18,19,17,Any number between 10 and 20,C,"Sum of all degrees = 2 * |E|. Here considering tree as a k-ary tree :

Sum of degrees of leaves + Sum of degrees for Internal Node except root + Root's degree = 2 * (No. of nodes - 1).

Putting values of above terms,

L + (I-1)*(k+1) + k = 2 * (L + I - 1)

L + k*I - k + I -1 + k = 2*L + 2I - 2

L + K*I + I - 1 = 2*L + 2*I - 2

K*I + 1 - I = L

(K-1)*I + 1 = L

Given k = 2, L=20

==&gt; (2-1)*I + 1 = 20
==&gt; I = 19
==&gt; T has 19 internal nodes which are having two children.",Tree,Hard,High,0.2
190,"An array of integers of size n can be converted into a heap by adjusting the heaps rooted at each internal node of the complete binary tree starting at the node ⌊(n - 1) /2⌋, and doing this adjustment up to the root node (root node is at index 0) in the order ⌊(n - 1)/2⌋, ⌊(n - 3)/ 2⌋, ....., 0. The time required to construct a heap in this manner is",O(log n),O(n),O (n log log n),O(n log n),C,"The above statement is actually&nbsp;algorithm for building a Heap of an input array A.BUILD-HEAP(A) 
    heapsize := size(A); 
    for i := floor(heapsize/2) downto 1 
        do HEAPIFY(A, i); 
    end for 
END
Upper bound of time complexity is O(n) for above algorithm.See- https://www.geeksforgeeks.org/time-complexity-of-building-a-heap/&nbsp;",Tree,Medium,Medium,0.25
191,"In a binary tree, for every node the difference between the number of nodes in the left and right subtrees is at most 2. If the height of the tree is h &gt; 0, then the minimum number of nodes in the tree is:",2h - 1,2h - 1 + 1,2h - 1,2h,C,"Let there be n(h) nodes at height h.

In a perfect tree where every node has exactly 
two children, except leaves, following recurrence holds.

n(h) = 2*n(h-1) + 1

In given case, the numbers of nodes are two less, therefore
n(h) = 2*n(h-1) + 1 - 2
     = 2*n(h-1) - 1

Now if try all options, only option (b) satisfies above recurrence.

Let us see option (B)
n(h) = 2h - 1 + 1

So if we substitute 
n(h-1) = 2h-2 + 1, we should get n(h) = 2h-1 + 1

n(h) =  2*n(h-1) - 1
     =  2*(2h-2 + 1) -1
     =  2h-1 + 1.",Tree,Hard,High,0.2
192,"Breadth First Search (BFS) is started on a binary tree beginning from the root vertex. There is a vertex t at a distance four from the root. If t is the n-th vertex in this BFS traversal, then the maximum possible value of n is ________

[This Question was originally a Fill-in-the-blanks Question]",15,16,31,32,D,"It would be node number 31 for given distance 4.For example if we consider at distance 2, below highlighted node G can be the farthest node at position 7.  
            A
         /    \\
        B       C
       / \\     / \\
      D   E   F   G

Alternative Solution :t is the n-th vertex in this BFS traversal at distance four from the root. So height of tree is 4.Max number of nodes = 2^{h+1} − 1 = 2^{5} − 1 = 31At distance four, last node is 31. option (C).",Tree,Medium,High,0.25
193,"In a binary tree, the number of internal nodes of degree 1 is 5, and the number of internal nodes of degree 2 is 10. The number of leaf nodes in the binary tree is

&nbsp;",10,11,12,15,C,"In a binary tree, the number of leaf nodes is always 1 more than number of internal nodes with 2 children, refer http://www.geeksforgeeks.org/handshaking-lemma-and-interesting-tree-properties/
So,
Number of Leaf Nodes = Number of Internal nodes with 2 children + 1
Number of Leaf Nodes = 10 + 1
Number of Leaf Nodes = 11",Tree,Medium,High,0.25
194,"The following three are known to be the preorder, inorder and postorder sequences of a binary tree. But it is not known which is which.
MBCAFHPYK
KAMCBYPFH
MABCKYFPH
Pick the true statement from the following.","I and II are preorder and inorder sequences, respectively","I and III are preorder and postorder sequences, respectively","II is the inorder sequence, but nothing more can be said about the other two sequences","II and III are the preorder and inorder sequences, respectively",E,"The approach to solve this question is to first find 2 sequences whose first and last element is same. The reason being first element in the Pre-order of any binary tree is the root and last element in the Post-order of any binary tree is the root.
Looking at the sequences given, 
Pre-order   =   KAMCBYPFH
Post-order  =  MBCAFHPYK
Left-over sequence  MABCKYFPH will be in order.
Since we have all the traversals identified, let's try to draw the binary tree if possible.



I. Post order
II. Pre order
III. Inorder


This solution is contributed by Pranjul Ahuja.",Tree,Hard,High,0.2
195,"A binary tree with n > 1 nodes has n1, n2 and n3 nodes of degree one, two and three respectively. The degree of a node is defined as the number of its neighbors.

n3 can be expressed as",n1 + n2 - 1,n1 - 2,[((n1 + n2)/2)],n2 - 1,C,,Tree,Hard,High,0.2
196,"A binary tree with n > 1 nodes has n1, n2 and n3 nodes of degree one, two and three respectively. The degree of a node is defined as the number of its neighbors.

Starting with the above tree, while there remains a node v of degree two in the tree, add an edge between the two neighbors of v and then remove v from the tree. How many edges will remain at the end of the process?",2 * n1 - 3,n2 + 2 * n1 - 2,n3 - n2,n2 + n1 - 2,B,With reference to figure of answer of previous question:,Tree,Hard,High,0.2
197,"A binary search tree contains the values 1, 2, 3, 4, 5, 6, 7, 8. The tree is traversed in pre-order and the values are printed out. Which of the following sequences is a valid output?",53124786,53126487,53241678,53124768,E,,Tree,Medium,High,0.25
198,"In the balanced binary tree in the below figure, how many nodes will become unbalanced when a node is inserted as a child of the node “g”?
         a
       /   \\
      b     e
     / \\   /
    c  d  f
   /
  g",1,3,7,8,C,,Tree,Medium,Medium,0.25
199,The number of structurally different possible binary trees with 4 nodes is,14,12,336,168,B,"The total number of structurally different possible binary trees can be found out using the Catalon number which is (2n)!/ (n! *(n+1)!). Here n=4, so, answer is 14.",Tree,Medium,Medium,0.25
200,A strictly binary tree with 10 leaves,cannot have more than 19 nodes,has exactly 19 nodes,has exactly 17 nodes,has exactly 20 nodes,C,"A strict binary tree with ‘n’ leaf nodes always have ‘2n-1’ intermediate nodes. With 10 leaf nodes a strict binary tree will have exactly 19 nodes. So, option (B) is correct.",Tree,Medium,Medium,0.25
201,What is the maximum height of any AVL tree with 7 nodes? Assume that height of tree with single node is 0.,2,3,4,5,C,Refer: Data Structures and Algorithms | Set 16,Tree,Medium,Medium,0.25
202,Which one of the following property is correct for a red-black tree?,Every simple path from a node to a descendant leaf contains the same number of black nodes,"If a node is red, then one children is red and another is black","If a node is red, then both its children are red",Every leaf node (sentinel node) is red,B,"Refer: Red-Black Tree | Set 1 (Introduction)
Option (A) is correct.",Tree,Medium,Medium,0.25
203,"Consider a full binary tree with n internal nodes, internal path length i, and external path length e. The internal path length of a full binary tree is the sum, taken over all nodes of the tree, of the depth of each node. Similarly, the external path length is the sum, taken over all leaves of the tree, of the depth of each leaf. Which of the following is correct for the full binary tree?",e = i+n,e = i+2n,e = 2i+n,e = 2n+i,C,,Tree,Medium,Medium,0.25
204,"The order of a leaf node in a B+ tree is the maximum number of children it can have. Suppose that block size is 1 kilobytes, the child pointer takes 7 bytes long and search field value takes 14 bytes long. The order of the leaf node is ________.",16,63,64,68,B,"Key size = 14 bytes (given)

Child pointer = 7 bytes (given)

We assume the order of B+ tree to be ‘n’.

Block size >= (n – 1) * key size + n * child pointer
512 >= (n – 1) * 14 + n * 7
512 >= 14 * n – 14 + 7 * n 
n <= (1024 + 14) / 20
n <= 1038 / 21
n <= 49.42

So, option (A) is correct.",Tree,Medium,Medium,0.25
205,A complete binary tree with n non-leaf nodes contains,log2 n nodes,n+1 nodes,2n nodes,2n+1 nodes,E,,Tree,Medium,Medium,0.25
206,"Suppose you are given a binary tree with n nodes, such that each node has exactly either zero or two children. The maximum height of the tree will be",n / 2  - 1,n / 2  + 1,(n – 1) / 2,(n + 1) / 2,D,,Tree,Medium,Medium,0.25
207,The number of different binary trees with 6 nodes is ______.,6,42,132,256,D,"The number of different binary trees with 6 nodes is fact(2n) / fact(n+1) * fac(n) where n is no nodes:If n= 6, then  fact(2 * n) / fact(n+1) * fac(n) 
= fact(2 * 6) / fact(6 + 1) * fact(6) 
= fact(12) / fact(7) * fact(6) 
= 12 * 11 * 10 * 9 * 8 * fact(7) / fact(7) * fact(6) 
= 12 * 11 * 10 * 9 * 8  / 6 * 5 * 4 * 3 * 2 
= 6 * 11 * 2 
= 132.
So, option (C) is correct.",Tree,Medium,Medium,0.25
208,Which of the following number of nodes can form a full binary tree?,8,15,14,13,C,"a full binary tree is a binary tree in which all nodes except leaves have two children. In a Full Binary, number of leaf nodes is number of internal nodes plus 1 L = I + 1 Where L = Number of leaf nodes, I = Number of internal nodes So, option (B) is correct.",Tree,Medium,Medium,0.25
209,A complete binary tree with the property that the value at each node is as least as large as the values at its children is known as,Binary search tree,AVL tree,Completely balanced tree,Heap,E,"In a Max. Binary Heap, the key value at each node is as least as large as the values at its children. Similarly in Min Binary Heap, the key at root must be minimum among all keys present in Binary Heap. So, correct option is (D).",Tree,Medium,Medium,0.25
210,A full binary tree with n leaves contains,n nodes,log 2 n nodes,2n –1 node,2 n nodes,D,"A Binary Tree is full if every node has 0 or 2 children. Following are examples of full binary tree. We can also say a full binary tree is a binary tree in which all nodes except leaves have two children. A full binary tree with n leaves contains  2 * n – 1 nodes.
So, option (C) is correct.",Tree,Medium,Medium,0.25
211,Any decision tree that sorts n elements has height,Ω(n),Ω(lgn),Ω(nlgn),Ω(n2),B,,Tree,Medium,Medium,0.25
212,"Find the inorder and postorder of the binary tree with the given preorder:
60, 40, 20, 10, 30, 33, 50, 44, 51, 90, 70, 65, 80, 110, 100, 95, 99, 120.","In order: 110, 100, 99, 90, 80, 70, 65, 60, 51, 50, 44, 40, 33, 30, 20, 10.Postorder: 110, 120, 100, 95, 99, 70, 80, 65, 60, 40, 50, 51, 44, 20, 30,  33, 10","Inorder: 10, 20, 30, 33, 40,  44, 50, 51, 60,  65, 70,  80,  90, 95,  99, 100, 110, 120Postorder: 10, 33, 30, 20, 44, 51, 50, 40,  65, 80, 70, 99, 95, 100, 120, 110, 90, 60","In order: 10, 33, 30, 20, 44, 51, 50, 40, 60, 65, 80, 70, 99, 95, 100, 120, 110,Postorder: 10, 20, 30, 33, 40,  44, 50, 51, 60,  65, 70,  80,  90, 95,  99, 100, 110","In order: 10, 33, 30, 20, 44, 51, 60,  65, 80, 70, 99, 95, 100, 120, 110,Postorder: 110, 100, 99, 90, 80, 70, 65, 60, 51, 50, 44, 40, 33, 30, 20, 10.",C,,Tree,Medium,Medium,0.25
213,A binary search tree in which every non-leaf node has non-empty left and right subtrees is called a strictly binary tree. Such a tree with 19 leaves :,cannot have more than 37 nodes,has exactly 37 nodes,has exactly 35 nodes,cannot have more than 35 nodes,C,"2(n)-1 where n is the for the leaves nodes. So by that way we have exactly 37 nodes.

Option (B) is correct.",Tree,Medium,Medium,0.25
214,Consider a complete binary tree with 7 nodes. Let A denote the set of first 3 elements obtained by performing Breadth-First Search (BFS) starting from the root. Let B denote the set of first 3 elements obtained by performing Depth-First Search (DFS) starting from the root.  The value of ∣A−B∣ is _____________ .,1,2,3,4,A,"In case of BFS if we draw complete binary tree then in Set A we have level1+level2. In DFS we have level1+ level 2 + level 3. Level 1 = 1 element, level 2 = 2 elements, level 3= 4 elements. Total of 7 elements. Set A have: Level 1 = 1st element, Level 2 = 2nd &amp; 3rd element.Set B have: Level 1 = 1 element, level 2 = 2nd element, level 3= 3rd element.L1 x 1 element from L2 (A ∩ B) Element in A not in B.So A-B= remaining element of level 2. |A - B = 1|",Tree,Medium,Medium,0.25
215,"Which of the following sequences denotes the post order traversal sequence of the given tree?
         a
       /   \\
      b     e
     / \\   /
    c  d  f
   /
  g",f e g c d b a,g c b d a f e,g c d b f e a,f e d g c b a,D,,Tree,Medium,Medium,0.25
216,The in-order and pre-order traversal of a binary tree are d b e a f c g and a b d e c f g respectively. The post order traversal of a binary tree is,e d b g f c a,e d b f g c a,d e b f g c a,d e f g b c a,D,"Refer:  GATE-CS-2007 | Question 39 

Option (C) is correct.",Tree,Medium,Medium,0.25
217,"Consider an array representation of an n element binary heap where the elements are stored from index 1 to index n of the array. For the element stored at index i of the array (i&lt;=n), the index of the parent is:&nbsp;&nbsp;",ceiling (i/2),floor (i/2),ceiling ((i+1)/2),floor ((i+1)/2),A,"Refer: GATE-CS-2001 | Question 15&nbsp;To find parent of node at i index we have to find floor(i/2).&nbsp;So, option (C) is correct.&nbsp;",Tree,Medium,Medium,0.25
218,What is the worst-case number of arithmetic operations performed by recursive binary search on a sorted array of size n?,Θ(√n),Θ(log2(n)),Θ(n2),Θ(n),C,Arithmetic operations performed by binary search on sorted data items means computation of mid element required arithmetic operation. So it will be computed log(n) time and Hence option (C) will be correct.,Tree,Medium,Medium,0.25
219,"Consider a binary tree with n nodes, where each node can have at most two children. The height of the tree is defined as the maximum number of edges between the root node and any leaf node. Which of the following statements is true regarding the height h of this binary tree?",The height of the tree is always equal to n-1.,The height of the tree can be greater than or equal to n-1.,The height of the tree is always equal to log₂(n).,The height of the tree can be greater than or equal to log₂(n).,C,"In a binary tree, the height h represents the longest path from the root node to any leaf node. This path can consist of n-1 edges in the worst case, where each node has exactly one child except for the leaf nodes. However, it's also possible for a binary tree to have a height less than n-1, depending on its structure.Consider a binary tree where each parent node has only one child (left or right) while the other child is null. In this case, the height of the tree will be less than n-1. On the other hand, a balanced binary tree, such as a complete binary tree, can have a height equal to n-1 when it contains the maximum number of nodes.Therefore, option b) is correct, as the height of a binary tree can be greater than or equal to n-1, depending on its structure and the arrangement of nodes.",Tree,Medium,Medium,0.25
220,"A size-balanced binary tree is a binary tree in which for every node, the difference between the number of nodes in the left and right subtree is at most 1. The distance of a node from the root is the length of the path from the root to the node. The height of a binary tree is the maximum distance of a leaf node from the root.

a. Prove, by using induction on h, that a size-balance binary tree of height h contains at least 2h nodes.
b. In a size-balanced binary tree of height h≤1, how many nodes are at distance h−1 from the root? Write only the answer without any explanations.",,,,,,,Tree,Hard,High,0.2
221,"Draw the binary tree with node labels a, b, c, d, e, f and g for which the inorder and postorder traversals result in the following sequences:
Inorder       a f b c d g e
Postorder     a f c g e d b",,,,,,,Tree,Medium,Medium,0.25
222,Consider a complete binary tree where the left and the right subtrees of the root are max-heaps. The lower bound for the number of operations to convert the tree to a heap is,Ω(logn),Ω(n),Ω(nlogn),Ω(n2),A,"The answer to this question is simply max-heapify function.  Time complexity of max-heapify is O(Log n) as it recurses at most through height of heap.  // A recursive method to heapify a subtree with root at given index// This method assumes that the subtrees are already heapifiedvoid MinHeap::MaxHeapify(int i){    int l = left(i);    int r = right(i);    int largest = i;    if (l &lt; heap_size &amp;&amp; harr[l] &lt; harr[i])        largest = l;    if (r &lt; heap_size &amp;&amp; harr[r] &lt; harr[smallest])        largest = r;    if (largest != i)    {        swap(&amp;harr[i], &amp;harr[largest]);        MinHeapify(largest);    }}  See  for details.",Tree,Medium,Medium,0.25
223,What is the worst case time complexity of inserting n2 elements into an AVL-tree with n elements initially ?,Θ(n4),Θ(n2),Θ(n2 log n),Θ(n3),C,"Since AVL tree is balanced tree, the height is O(log n). So, time complexity to insert an element in an AVL tree is O(log n) in worst case.   Note:Every insertion of element:Finding place to insert = O(log n)If property not satisfied (after insertion) do rotation = O(log n)So, an AVL insertion take = O(log n) + O(log n) = O(log n) in worst case.   Now, given n2 element need to insert into given AVL tree, therefore, total time complexity will be O(n2 log n).  Alternative method: Time complexity in worst case, 1st insertion time complexity = O(log n)2nd insertion time complexity = O(log(n+1))...n2th insertion time complexity = O(log(n + n2))  So, total time complexity will be, = O(log n) +  O(log n+1)) + .... +  O(log(n + n2))= O(log n*(n+1)*(n+2)*...(n+n2))= O(log nn2)= O(n2 log n)   Option (C) is correct.",Tree,Hard,High,0.2
224,"The degree sequence of a simple graph is the sequence of the degrees of the nodes in the graph in decreasing order. Which of the following sequences can not be the degree sequence of any graph?&nbsp;&nbsp;I. 7, 6, 5, 4, 4, 3, 2, 1
II. 6, 6, 6, 6, 3, 3, 2, 2
III. 7, 6, 6, 4, 4, 3, 2, 2
IV. 8, 7, 7, 6, 4, 2, 1, 1 
&nbsp;",I and II,III and IV,IV only,II and IV,E,Both II and IV cannot be the degree sequence of any graph.,Graph,Easy,Low,0.27
225,The time complexity of computing the transitive closure of a binary relation on a set of n elements is known to be:,O(n),O(nLogn),O(n ^ (3/2)),O(n^3),E,The time complexity of computing the transitive closure of a binary relation on a set of n elements is O(n^3) using the Floyd-Warshall algorithm.,Graph,Hard,High,0.2
226,The most efficient algorithm for finding the number of connected components in an undirected graph on n vertices and m edges has time complexity.,theta(n),theta(m),theta(m + n),theta(mn),D,"Connected components can be found in O(m + n) using Tarjan's algorithm. Once we have connected components, we can count them.",Graph,Easy,Low,0.27
227,"Consider an undirected unweighted graph G. Let a breadth-first traversal of G be done starting from a node r. Let d(r, u) and d(r, v) be the lengths of the shortest paths from r to u and v respectively, in G. lf u is visited before v during the breadth-first traversal, which of the following statements is correct?","d(r, u) &lt; d (r, v)","d(r, u) &gt; d(r, v)","d(r, u) &lt;= d (r, v)",None of the above,D,"d(r, u) and d(r, v) will be equal when u and v are at same level, otherwise d(r, u) will be less than d(r, v)",Graph,Easy,Low,0.27
228,"How many undirected graphs (not necessarily connected) can be constructed out of a given set V= {V 1, V 2,…V n} of n vertices ?",n(n-l)/2,2^n,n!,2^(n(n-1)/2),E,"In an undirected graph, there can be maximum n(n-1)/2 edges. We can choose to have (or not have) any of the n(n-1)/2 edges.  So, total number of undirected graphs with n vertices is 2^(n(n-1)/2).",Graph,Easy,Low,0.27
229,Which of the following statements is/are TRUE for an undirected graph?&nbsp;P: The number of odd-degree vertices is even&nbsp;Q: Sum of degrees of all vertices is even,P Only,Q Only,Both P and Q,Neither P nor Q,D,"P is true for undirected graph as adding an edge always increases degree of two vertices by 1. Q is true: If we consider sum of degrees and subtract all even degrees, we get an even number because every edge increases the sum of degrees by 2. So total number of odd degree vertices must be even.",Graph,Easy,Low,0.27
230,Consider an undirected random graph of eight vertices. The probability that there is an edge between a pair of vertices is 1/2. What is the expected number of unordered cycles of length three?,01-Aug,1,7,8,D,A cycle of length 3 can be formed with 3 vertices. There can be total 8C3 ways to pick 3 vertices from 8. The probability that there is an edge between two vertices is 1/2. So expected number of unordered cycles of length 3 = (8C3)*(1/2)^3 = 7,Graph,Easy,Low,0.27
231,In which scenario would a directed acyclic graph (DAG) be most suitable?,Representing dependencies between tasks in a project schedule,Modeling a social network with friend connections,Finding the shortest path between two nodes in a weighted graph,Performing breadth-first search (BFS) on a graph,B,"Directed acyclic graphs (DAGs) are commonly used to represent dependencies between tasks in a project schedule. DAGs ensure that the tasks are organized in a way that no cycles exist, allowing for efficient scheduling and task sequencing.",Graph,Easy,Low,0.27
232,"How many undirected graphs (not necessarily connected) can be constructed out of a given set V = {v1, v2, ... vn} of n vertices?",n(n-1)/2,2n,n!,2n(n-1)/2,E,"There are total n*(n-1)/2 possible edges.  For every edge, there are to possible options, either we pick it or don't pick.   So total number of possible graphs is 2n(n-1)/2.",Graph,Easy,Low,0.27
233,What is the maximum number of edges in an acyclic undirected graph with n vertices?,n-1,n,n + 1,2n-1,B,"n * (n - 1) / 2 when cyclic. But acyclic graph with the maximum number of edges is actually a spanning tree and therefore, correct answer is n-1 edges.",Graph,Easy,Low,0.27
234,"Q84 Part_B

A sink in a directed graph is a vertex i such that there is an edge from every vertex j ≠ i to i and there is no edge from i to any other vertex. A directed graph G with n vertices is represented by its adjacency matrix A, where A[i] [j] = 1 if there is an edge directed from vertex i to j and 0 otherwise. The following algorithm determines whether there is a sink in the graph G.

i = 0
do {
    j = i + 1;
    while ((j < n) && E1) j++;
    if (j < n) E2;
} while (j < n);

flag = 1;
for (j = 0; j < n; j++)
    if ((j! = i) && E3)
        flag = 0;

if (flag)
    printf(""Sink exists"");
else
    printf(""Sink does not exist"");


Choose the correct expressions for E3

&nbsp;",(A[i][j] && !A[j][i]),(!A[i][j] && A[j][i]),(!A[i][j] | |  A[j][i]),(A[i][j] | | !A[j][i]),E,"Below explanation is for Previous Part of this question:
For vertex i to be a sink, there should be no edge from i to any other vertex.



According the input given in question,

A[i][j] = 1 means there is an edge from vertex i to j.
A[i][j] = 0 means there is no edge from i to j


For a node to i to be sink, 
A[i][j] should be 0 for all j 
A[j][i] should be 1 for all j.


The above pseudo code checks every vertex i for sink, starting from i = 0.  It basically checks every vertex j after i for being a sink.  The trick in pseudo code is, it doesn't check for j smaller than i.  The i picked by this loop may not be sink. It basically makes sure that we don't ignore a potential sink.  The check whether i is actually a sink or not is done later after do while loop.

Vertex i is a potential sink while A[i][j] is zero 
Thus, E1 : !A[i][j] 

If the above condition is false, then i is not a sink. All j < i can also not be a sink because there is no edge from i to j.
Now, the next potential sink can be j. 
So, E2 : i = j

Explanation for this question
The following pseudo code basically checks if the potential sink picked by the code above is actually a sink or not.

flag = 1;
for (j = 0; j < n; j++)
    if ((j! = i) && E3)
        flag = 0;


flag equals to 0 means i is not a sink. The code sets the flag 0 as soon as it finds out that i is not a sink.

A node i is not a sink if either of the following 
two conditions become true for any j not equal to i.
A[i][j] is 1 for any j 
OR
A[j][i] is 0 for any j

E3 : (A[i][j] | | !A[j][i])

Therefore option D is correct",Graph,Easy,Low,0.27
235,"Q85 &nbsp;Part_A  Consider a simple graph with unit edge costs. Each node in the graph represents a router. Each node maintains a routing table indicating the next hop router to be used to relay a packet to its destination and the cost of the path to the destination through that router. Initially, the routing table is empty. The routing table is synchronously updated as follows. In each updation interval, three tasks are performed.  A node determines whether its neighbours in the graph are accessible. If so, it sets the tentative cost to each accessible neighbour as 1. Otherwise, the cost is set to ∞. From each accessible neighbour, it gets the costs to relay to other nodes via that neighbour (as the next hop). Each node updates its routing table based on the information received in the previous two steps by choosing the minimum cost.   For the graph given above, possible routing tables for various nodes after they have stabilized, are shown in the following options. Identify the correct table.   


1)
Table for node A



&nbsp;A
&nbsp;-
&nbsp;-


&nbsp;B
&nbsp;B
&nbsp;1


&nbsp;C
&nbsp;C
&nbsp;1


&nbsp;D
&nbsp;B
&nbsp;3


&nbsp;E
&nbsp;C
&nbsp;3


&nbsp;F
&nbsp;C
&nbsp;4


    2) Table for node C
   &nbsp;A &nbsp;A &nbsp;1   &nbsp;B &nbsp;B &nbsp;1   &nbsp;C &nbsp;- &nbsp;-   &nbsp;D &nbsp;D &nbsp;1   &nbsp;E &nbsp;E &nbsp;1   &nbsp;F &nbsp;E &nbsp;3        3) Table for node B
   &nbsp;A &nbsp;A &nbsp;1   &nbsp;B &nbsp;- &nbsp;-   &nbsp;C &nbsp;C &nbsp;1   &nbsp;D &nbsp;D &nbsp;1   &nbsp;E &nbsp;C &nbsp;2   &nbsp;F &nbsp;D &nbsp;2       4) Table for node D
   &nbsp;A &nbsp;B &nbsp;3   &nbsp;B &nbsp;B &nbsp;1   &nbsp;C &nbsp;C &nbsp;1   &nbsp;D &nbsp;- -   &nbsp;E &nbsp;E &nbsp;1   &nbsp;F &nbsp;F &nbsp;1",A,B,C,D,C,&nbsp;  This solution is contributed by Sandeep Pandey.,Graph,Easy,Low,0.27
236,"Q85 Part_B

Consider a simple graph with unit edge costs. Each node in the graph represents a router. Each node maintains a routing table indicating the next hop router to be used to relay a packet to its destination and the cost of the path to the destination through that router. Initially, the routing table is empty. The routing table is synchronously updated as follows. In each updation interval, three tasks are performed.

A node determines whether its neighbours in the graph are accessible. If so, it sets the tentative cost to each accessible neighbour as 1. Otherwise, the cost is set to ∞.
From each accessible neighbour, it gets the costs to relay to other nodes via that neighbour (as the next hop).
Each node updates its routing table based on the information received in the previous two steps by choosing the minimum cost.


For the graph given above, possible routing tables for various nodes after they have stabilized, are shown in the following options. Identify the correct table.





1)
Table for node A



 A
 -
 -


 B
 B
 1


 C
 C
 1


 D
 B
 3


 E
 C
 3


 F
 C
 4






2)
Table for node C



 A
 A
 1


 B
 B
 1


 C
 -
 -


 D
 D
 1


 E
 E
 1


 F
 E
 3







3)
Table for node B



 A
 A
 1


 B
 -
 -


 C
 C
 1


 D
 D
 1


 E
 C
 2


 F
 D
 2






4)
Table for node D



 A
 B
 3


 B
 B
 1


 C
 C
 1


 D
 -
-


 E
 E
 1


 F
 F
 1







Continuing from the earlier problem, suppose at some time t, when the costs have stabilized, node A goes down. The cost from node F to node A at time (t + 100) is",>100 but finite,∞,3,>3 and ≤100,B,,Graph,Easy,Low,0.27
237,"For the undirected, weighted graph given below, which of the following sequences of edges represents a correct execution of Prim's algorithm to construct a Minimum Span­ning Tree?
&nbsp;","(a, b), (d, f), (f, c), (g, i), (d, a), (g, h), (c, e), (f, h)","(c, e), (c, f), (f, d), (d, a), (a, b), (g, h), (h, f), (g, i)","(d, f), (f, c), (d, a), (a, b), (c, e), (f, h), (g, h), (g, i)","(h, g), (g, i), (h, f), (f, c), (f, d), (d, a), (a, b), (c, e)",D,In prims algorithm we start with any node and keep on exploring minimum cost neighbors of nodes already covered.,Graph,Easy,Low,0.27
238,Consider a directed graph with n vertices and m edges such that all edges have same edge weights. Find the complexity of the best known algorithm to compute the minimum spanning tree of the graph?,O(m+n),O(m logn),O(mn),O(n logm),B,"It’s a special case in which all edge weights are equal, so dfs would work and resultant depth first tree would be the spanning tree. So the answer would be O(m+n).",Graph,Easy,Low,0.27
239,You are given a graph containing n vertices and m edges and given that the graph doesn’t contain cycle of odd length. Time Complexity of the best known algorithm to find out whether the graph is bipartite or not is ?,O(m+n),O(1),O(mn),O(n2),C,"It is by definition that a graph is bipartite if it does not contain odd length cycles. So the answer is O(1).For more background reading, check this link&nbsp;https://proofwiki.org/wiki/Graph_is_Bipartite_iff_No_Odd_Cycles",Graph,Medium,Medium,0.25
240,"Let G be a simple graph with 20 vertices and 8 components. If we delete a vertex in G, then number of components in G should lie between ____.",8 and 20,8 and 19,7 and 19,7 and 20,D,"Case 1: If the vertex we are deleting from G is an isolated vertex, which is a component by itself, then number of components in G becomes 7.
Case 2: If G is a start Graph, then by deleting the cut vertex of G, we get 19 components.
Hence, number of components in G should lie between 7 and 19.",Graph,Easy,Low,0.27
241,Let G be the graph with 100 vertices numbered 1 to 100. Two vertices i and j are adjacent if |i−j|=8&nbsp;or |i−j|=12. The number of connected components in G is,8,4,12,25,C,"When vertices are arranged with difference of 12 the number of components is reduced to 4 as first column will be connected with fifth column, second column will be connected with sixth column, third column will be connected with seventh column and fourth column will be connected with eighth column. No other form of connection exists so total 4 connected components are there.&nbsp;So, option (B) is correct.&nbsp;",Graph,Medium,Medium,0.25
242,"A complete, undirected, weighted graph G is given on the vertex {0, 1,...., n−1} for any fixed ‘n’. Draw the minimum spanning tree of G if

a) the weight of the edge (u,v) is ∣ u−v ∣
b) the weight of the edge (u,v) is u + v",1,2,3,4,D,,Graph,Easy,Low,0.27
243,Which of the following data structure is useful in traversing a given graph by breadth first search?,Stack,List,Queue,None of the above.,D,BFS performs level-order traversal which can be fairly done using a queue. A queue uses FIFO ordering and the nodes that we enqueue first are explored first maintaining the order of traversal.,Graph,Medium,Medium,0.25
244,"In the following graph, discovery time stamps and finishing time stamps of Depth First Search (DFS) are shown as x/y, where x is discovery time stamp and y is finishing time stamp.


It shows which of the following depth first forest?","{a, b, e} {c, d, f, g, h}","{a, b, e} {c, d, h} {f, g}","{a, b, e} {f, g} {c, d} {h}","{a, b, c, d} {e, f, g} {h}",B,,Graph,Medium,Medium,0.25
245,Consider a segment tree built on an array of N elements. What is the minimum number of node updates required to rebuild the entire tree if the original array is reversed?,N,N - 1,2N - 1,N log N,D,"Rebuilding the entire segment tree requires updating each node, and the minimum number of nodes in a segment tree is 2N-1.",Graph,Medium,Medium,0.25
246,Which of the following according to you is incorrect?,Trie is also known as prefix tree,Trie requires less storage space than hashing,Trie allows listing of all the words with same prefix,Tries are collision free,C,"Both the hashing and the trie provides searching in the linear time. But trie requires extra space for storage and it is collision free. And trie allows finding all the strings with same prefix, so it is also called prefix tree. Hence , option B is the correct option.",Graph,Medium,Medium,0.25
247,Which of the following statements about disjoint-set forests is false?,Disjoint-set forests can be used to efficiently detect cycles in a graph.,Disjoint-set forests can handle disconnected components efficiently.,The union operation in disjoint-set forests can be performed in constant time.,Disjoint-set forests are commonly used in minimum spanning tree algorithms.,D,"The union operation in disjoint-set forests, using union by rank and path compression, takes time proportional to the inverse Ackermann function, which is not constant but extremely slow-growing.",Graph,Medium,Medium,0.25
248,"In an undirected connected planar graph G, there are eight vertices and five faces. The number of edges in G is _________.",10,11,12,6,C,"By using Euler’s theorem, the number of regions = e - v + 2 
R = e - v + 2
5 = e - 8 + 2 = e-6
e = 5+6 = 11",Graph,Easy,Low,0.27
249,Consider the following undirected graph with edge weights as shown: The number of minimum-weight spanning trees of the graph is ___________.,3,4,5,2,A,"There are 3 edges between these components to connect them.  According to Kruskal's algorithm edges with weight 0.1 are significantly lighter. So the MST will consist only of edges with weight 0.1.We will include minimum weights edges first if there is no cycle resultant. But we need only one edge to form spanning tree, and we have 3 options for one edge. Hence, number of spanning trees are 3.",Graph,Easy,Low,0.27
250,The cyclomatic complexity of the flow graph of a program provides &nbsp;,an upper bound for the number of tests that must be conducted to ensure that all statements have been executed at most once,a lower bound for the number of tests that must be conducted to ensure that all statements have been executed at most once,an upper bound for the number of tests that must be conducted to ensure that all statements have been executed at least once,a lower bound for the number of tests that must be conducted to ensure that all statements have been executed at least once,D,"Option (C) is correct, because the cyclomatic complexity of the flow graph of a program provides an upper bound for the number of tests that must be conducted to ensure that all statements have been executed at least once.",Graph,Hard,High,0.2
251,What is the largest integer m such that every simple connected graph with n vertices and n edges contains at least m different spanning trees?,1,2,3,n,D,"A graph is connected iff all nodes can be traversed from each node. For a graph with n nodes, there will be n-1 minimum number of edges. 
Given that there are n edges, that means a cycle is there in the graph.
The simplex graph with these conditions may be:



Now we can make a different spanning tree by removing one edge from the cycle, one at a time.
Minimum cycle length can be 3, So, there must be atleast 3 spanning trees in any such Graph.",Graph,Easy,Low,0.27
252,Which of the following is an advantage of adjacency list representation over adjacency matrix representation of a graph?,"In adjacency list representation, space is saved for sparse graphs.",DFS and BSF can be done in O(V + E) time for adjacency list representation. These operations take O(V^2) time in adjacency matrix representation. Here is V and E are number of vertices and edges respectively.,Adding a vertex in adjacency list representation is easier than adjacency matrix representation.,All of the above,E,See http://www.geeksforgeeks.org/graph-and-its-representations/,Graph,Medium,Medium,0.25
253,What is the worst case efficiency for a path compression algorithm?,O(M log N),O(N log N),O(log N),O(N),B,"The worst case efficiency for a path compression algorithm is mathematically found to be O(M log N).
Hence , option A is correct.",Graph,Hard,High,0.2
254,Trie is also known as _____,Treap,Binomial Tree,2-3 Tree,Digital Tree,E,"Trie is also known as Digital tree. Hence , option D is the correct answer.",Graph,Medium,Medium,0.25
255,"Let G be a weighted undirected graph and e be an edge with maximum weight in G. Suppose there is a minimum weight spanning tree in G containing the edge e. Which of the following statements is always TRUE?

&nbsp;",There exists a cutset in G having all edges of maximum weight.,There exists a cycle in G having all edges of maximum weight,Edge e cannot be contained in a cycle.,All edges in G have the same weight,B,"Background :  Given a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the vertices together. 

 A spanning tree has exactly V - 1 edges.
 A single graph can have many different spanning trees. A minimum spanning tree (MST) or minimum weight spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.
 There can be more that one possible spanning trees of a graph. For example, the graph in this question has 6 possible spanning trees.
 MST has lightest edge of every cutset. Remember Prim's algorithm which basically picks the lightest edge from every cutset. 


Choices of this question : 
a) There exists a cutset in G having all edges of maximum weight  : This is correct. If there is a heaviest edge in MST, then there exist a cut with all edges with weight equal to heavies edge.  See point 4 discussed in above background.


b) There exists a cycle in G having all edges of maximum weight :  Not always TRUE. The cutset of heaviest edge may contain only one edge.  In fact there may be overall one edge of heavies weight which is part of MST (Consider a graph with two components which are connected by only one edge and this edge is the heavies)

c) Edge e cannot be contained in a cycle. Not Always True. The curset may form cycle with other edges.

d) All edges in G have the same weight Not always True. As discussed in option b, there can be only one edge of heaviest weight.",Graph,Easy,Low,0.27
256,"Let G be the directed, weighted graph shown in below figure



We are interested in the shortest paths from A.

(a) Output the sequence of vertices identified by the Dijkstra’s algorithm for single source shortest path when the algorithm is started at node A.
(b) Write down sequence of vertices in the shortest path from A to E.
(c) What is the cost of the shortest path from A to E?",,,,,,"According to Dijkstra's algorithm:
(a) Sequence of vertices when algorithm start traversing from A: A -> B -> D -> C -> F -> E
(b) The sequence remain same as answer (a).
(c) Cost of the shortest path from A to E is 84.",Graph,Easy,Low,0.27
257,Consider a segment tree built on an array of N elements. What is the time complexity of updating a range of elements in the segment tree?,O(log N),O(N),"O(log N + K), where K is the number of elements in the range",O(N log N),C,"Updating a range of elements in a segment tree requires visiting each affected node, resulting in a time complexity of O(N).",Graph,Hard,High,0.2
258,Which of the following operations can be efficiently performed using a segment tree?,Finding the longest increasing subsequence in a given range,Finding the most frequent element in a given range,Finding the number of inversions in a given range,Finding the top K elements in a given range,D,A segment tree can efficiently find the number of inversions in a given range by performing a modified merge sort algorithm.,Graph,Medium,Medium,0.25
259,"The following code snippet is the function to insert a string in a trie. Find the missing line.
        C++
        
        void insert(const std::string &amp;str) {
    TrieNode *node = root;
    for (int i = 0; i &lt; str.length(); i++) {
        int index = str[i] - &#39;a&#39;;
        if (node-&gt;children[index] == nullptr)
            node-&gt;children[index] = new TrieNode();
        // ________________________
    }
    node-&gt;isEndOfWord = true;
}

        
    
        C
        
        void insert(char *str) {
    TrieNode *node = root;
    for (int i = 0; i &lt; length; i++) {
        int index = str[i] - &#39;a&#39;;
        if (node-&gt;children[index] == NULL)
            node-&gt;children[index] = (TrieNode *)malloc(sizeof(TrieNode));
        _________________________
    }
    node-&gt;isEndOfWord = 1;
}

        
    
        Java
        
        private void insert(String str){
   TrieNode node = root;
   for (int i = 0; i &lt; length; i++){
       int index = key.charAt(i) - &#39;a&#39;;
       if (node.children[index] == null)
          node.children[index] = new TrieNode();
       ________________________
   }
   node.isEndOfWord = true;
}

        
    
        Python
        
        def insert(self, str):
    node = self.root
    for i in range(len(str)):
        index = ord(str[i]) - ord(&#39;a&#39;)
        if node.children[index] is None:
            node.children[index] = TrieNode()
        ___________________________
    node.isEndOfWord = True

        
    
        JavaScript
        
        insert(str) {
    let node = this.root;
    for (let i = 0; i &lt; str.length; i++) {
        let index = str.charCodeAt(i) - &#39;a&#39;.charCodeAt(0);
        if (node.children[index] === null)
            node.children[index] = new TrieNode();
        ____________________________
    }
    node.isEndOfWord = true;
}",node = node.children[index];,&nbsp;node = node.children[str.charAt(i + 1)];,node = node.children[index++];,node = node.children[index++];,A,"After checking if the current node has a child at the given index, we need to move to the next node in the trie. The missing line moves the current target node to next node after checking the current node. node = node-&gt;children[index]; / node = node.children[index];Hence (A) is the correct option.",Graph,Medium,Medium,0.25
260,Which of the following is not true?,Trie requires less storage space than hashing,Trie allows listing of all the words with same prefix,Tries are collision free,Trie is also known as prefix tree,B,,Graph,Medium,Medium,0.25
261,"Given a disjoint-set forest with N elements, what is the maximum height of the trees in the forest after M union operations if union by rank and path compression techniques are used?",O(M),O(logM),O(N),O(N + M),C,"Using union by rank and path compression, the maximum height of the trees in the forest after M union operations is logarithmic with respect to M, resulting in a time complexity of O(log M).",Graph,Medium,Medium,0.25
262,Which of the following ways can be used to represent a graph?,Adjacency List and Adjacency Matrix,Incidence Matrix&nbsp;,"Adjacency List, Adjacency Matrix and Incidence Matrix",None of the above,D,"Adjacency Matrix, Adjacency List and Incidence Matrix are used to represent a graph.",Graph,Medium,Medium,0.25
263,"For a given graph G having v vertices and e edges which is connected and has no cycles, which of the following statements is true?",v=e&nbsp;,v = e+1,v + 1 = e,v = e-1,C,For any connected graph with no cycles the equation holds true.,Graph,Medium,Medium,0.25
264,Which of the following is true?&nbsp;,A graph may contain no edges and many vertices,A graph may contain many edges and one vertex,A graph may contain no edges and no vertices,A graph may contain no vertices and many edges,C,A graph must contain at least one vertex.,Graph,Medium,Medium,0.25
265,"Time Complexity of DFS is? (V – number of vertices, E – number of edges)",O(V + E),O(V),O(E),O(V*E),B,"The Depth First Search explores every node once and every edge once (in worst case), so it’s time complexity is O(V + E).",Graph,Hard,High,0.2
266,"A person wants to visit some places. He starts from a vertex and then wants to visit every vertex till it finishes from one vertex, backtracks and then explore other vertex from same vertex. What algorithm he should use?",Depth First Search,Breadth First Search,Trim’s algorithm,Kruskal’s Algorithm,B,"This is the definition of the Depth First Search. Exploring a node, then aggressively finding nodes till it is not able to find any node.",Graph,Hard,High,0.2
267,A bridge cannot be a part of&nbsp;,a simple cycle&nbsp;,a tree,a clique with size&gt;=3 whose every edge is a bridge,a graph which contains cycle,B,"In a connected graph, a bridge is an edge whose removal disconnects the graph. In a cycle if we remove an edge, it will still be connected. So, bridge cannot be a part of cycle.",Graph,Medium,Medium,0.25
268,Which of the following is the most commonly used data structure for implementing Dijkstra’s Algorithm?,Max priority queue,Stack,Circular queue,Min priority queue,E,Minimum priority queue is the most commonly used data structure for implementing Dijkstra’s Algorithm because the required operations to be performed in Dijkstra’s Algorithm match with specialty of a minimum priority queue.,Graph,Hard,High,0.2
269,What is the time complexity of Dijkstra’s algorithm?,O(N),O(N3),O(N2),O(logN),D,Time complexity of Dijkstra’s algorithm is O(N2) because of the use of doubly nested for loops. It depends on how the table is manipulated.,Graph,Hard,High,0.2
270,"In most of the cases, topological sort starts from a node which has __________",Maximum Degree,Minimum Degree,Any degree,Zero Degree,E,Topological sort starts with a node which has zero degree. If multiple such nodes exists then it can start with any node.,Graph,Medium,Medium,0.25
271,Topological sort can be implemented by?,Using Depth First Search,Using Breadth First Search,Using Depth and Breadth First Search,Using level ordered search,D,"We can implement topological sort by both BFS and DFS. In BFS, we use queue as data structure and in DFS, we use Linked list (if recursive) or Stack (if not recursive) as data structure.",Graph,Medium,Medium,0.25
272,Which of the following algorithms can be used to most efficiently determine the presence of a cycle in a given graph ?,Depth First Search,Breadth First Search,Prim\'s Minimum Spanning Tree Algorithm,Kruskal\' Minimum Spanning Tree Algorithm,B,"To find cycle in a graph we can use the Depth First Traversal (DFS) technique. It is based on the idea that there is a cycle in a graph only if there is a back edge [i.e., a node points to one of its ancestors] present in the graph.To detect a back edge, we need to keep track of the nodes visited till now and the nodes that are in the current recursion stack [i.e., the current path that we are visiting]. If during recursion, we reach a node that is already in the recursion stack, there is a cycle present in the graph.Hence Option (A) is the correct answer.",Graph,Hard,High,0.2
273,Traversal of a graph is different from tree because,There can be a loop in graph so we must maintain a visited flag for every vertex,"DFS of a graph uses stack, but inorder traversal of a tree is recursive","BFS of a graph uses queue, but a time efficient BFS of a tree is recursive.",All of the above,B,"Depth First Traversal (or DFS) for a graph is similar to Depth First Traversal of a tree. The only catch here is, that, unlike trees, graphs may contain cycles (a node may be visited twice). To avoid processing a node more than once, use a boolean visited array. A graph can have more than one DFS traversal.Hence Option (A) is the correct answer.&nbsp;",Graph,Medium,Medium,0.25
274,"What are the appropriate data structures for following algorithms?

1) Breadth-First Search &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;2) Depth First Search&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;3) Prim's Minimum Spanning Tree &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;4) Kruskal' Minimum Spanning Tree &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;",&nbsp;Stack&nbsp;QueuePriority QueueUnion Find,QueueStackPriority QueueUnion Find,StackQueueUnion FindPriority Queue&nbsp;,Priority QueueQueueStackUnion Find,C,"&nbsp;Breadth First Search uses Queue&nbsp;&nbsp;Depth First Search uses Stack&nbsp;&nbsp;Prim's Minimum Spanning Tree uses Priority Queue.&nbsp;&nbsp;Kruskal' Minimum Spanning Tree uses Union Find.
Hence Option(B) is the correct answer.",Graph,Hard,High,0.2
275,The Breadth First Search algorithm has been implemented using the queue data structure. One possible order of visiting the nodes of the following graph is&nbsp;&nbsp;&nbsp;,MNOPQR,NQMPOR,QMNPRO,QMNPOR,D,"Option (A) is MNOPQR. It cannot be a BFS as the traversal starts with M, but O is visited before N and Q. In BFS all adjacent must be visited before adjacent of adjacent. Option (B) is NQMPOR. It also cannot be BFS, because here, P is visited before O. (C) and (D) match up to QMNP. We see that M was added to the queue before N and P (because M comes before NP in QMNP). Because R is M's neighbor, it gets added to the queue before the neighbor of N and P (which is O). Thus, R is visited before O.

Hence (C) is the correct answer.",Graph,Hard,High,0.2
276,"Let G be an undirected graph. Consider a depth-first traversal of G, and let T be the resulting depth-first search tree. Let u be a vertex in G and let v be the first new (unvisited) vertex visited after visiting u in the traversal. Which of the following statements is always true? (GATE CS 2000)","{u,v} must be an edge in G, and u is a descendant of v in T","{u,v} must be an edge in G, and v is a descendant of u in T","If {u,v} is not an edge in G then u is a leaf in T","If {u,v} is not an edge in G then u and v must have the same parent in T",D,"In DFS, if 'v' is visited
after 'u', then one of the following is true.
1) (u, v) is an edge.
     u
   /   \
  v     w
 /     / \
x     y   z

2) 'u' is a leaf node.
     w
   /   \
  x     v
 /     / \
u     y   z 
In DFS, after visiting a node, we first recur for all unvisited children. If there are no unvisited children (u is leaf), then control goes back to parent and parent then visits next unvisited children.

Hence (C) is the correct answer.",Graph,Easy,Low,0.27
277,"Consider the following graph,




Among the following sequences:
(I) a b e g h f 
(II) a b f e h g
(III) a b f h g e 
(IV) a f g h b e  
Which are depth first traversals of the above graph?","I, II and IV only",I and IV only,"II, III and IV only","I, III and IV only",E,"We can check all DFSs for following properties.

In DFS, if a vertex 'v' is visited
after 'u', then one of the following is true.
1) (u, v) is an edge.
     u
   /   \
  v     w
 /     / \
x     y   z

2) 'u' is a leaf node.
     w
   /   \
  x     v
 /     / \
u     y   z
In DFS, after visiting a node, we first recur for all unvisited children. If there are no unvisited children (u is leaf), then control goes back to parent and parent then visits next unvisited children.",Graph,Medium,Medium,0.25
278,Which of the following condition is sufficient to detect cycle in a directed graph?,There is an edge from currently being visited node to an already visited node.,There is an edge from currently being visited node to an ancestor of currently visited node in DFS forest.,Every node is seen twice in DFS.,None of the above,C,"To find cycle in a directed graph we can use the Depth First Traversal (DFS) technique. It is based on the idea that there is a cycle in a graph only if there is a back edge [i.e., a node points to one of its ancestors] present in the graph.To detect a back edge, we need to keep track of the nodes visited till now and the nodes that are in the current recursion stack [i.e., the current path that we are visiting]. If during recursion, we reach a node that is already in the recursion stack, there is a cycle present in the graph.If the graph is disconnected then get the DFS forest and check for a cycle in individual trees by checking back edges.Hence Option(B) is the correct answer.",Graph,Easy,Low,0.27
279,"Is following statement true/false If a DFS of a directed graph contains a back edge, any other DFS of the same graph will also contain at least one back edge.",TRUE,FALSE,,,B,"A back edge means a cycle in graph. So if there is a cycle, all DFS traversals would contain at least one back edge.",Graph,Easy,Low,0.27
280,Make is a utility that automatically builds executable programs and libraries from source code by reading files called makefiles which specify how to derive the target program. Which of the following standard graph algorithms is used by Make.,Strongly Connected Components,Topological Sorting,Breadth First Search,Dijkstra\'s Shortest Path,C,Make can decide the order of building software using topological sorting. Topological sorting produces the order considering all dependencies provide by makefile. See following for details. Topological SortingHence Option(B) is the correct answer.,Graph,Medium,Medium,0.25
281,"Given two vertices in a graph s and t, which of the two traversals (BFS and DFS) can be used to find if there is path from s to t?",Only BFS,Only DFS,Both BFS and DFS,Neither BFS nor DFS,D,We can use both traversals to find if there is a path from s to t.Hence Option(C) is the correct answer.,Graph,Medium,Medium,0.25
282,"Is the following statement true/false? A DFS of a directed graph always produces the same number of tree edges, i.e., independent of the order in which vertices are considered for DFS.&nbsp;",TRUE,FALSE,,,C,"The statement is false.A Depth-First Search (DFS) of a directed graph can produce a different number of tree edges depending on the order in which vertices are considered for the DFS. The number of tree edges in a DFS tree depends on the specific traversal path taken during the DFS.During a DFS, starting from a particular source vertex, the traversal explores the graph by visiting neighboring vertices in a systematic way. The order in which the neighboring vertices are visited impacts the formation of the DFS tree.Hence (B) is the correct answer.",Graph,Easy,Low,0.27
283,"If the DFS finishing time f[u] &gt; f[v] for two vertices u and v in a directed graph G, and u and v are in the same DFS tree in the DFS forest, then u is an ancestor of v in the depth-first tree.",TRUE,FALSE,,,C,"In a graph with three nodes, r u, and v, with edges (r; u) and (r; v), and r is the starting point for the DFS, u and v are siblings in the DFS tree, neither as the ancestor of the other.Hence the above statement si false.",Graph,Easy,Low,0.27
284,"Consider the DAG with Consider V = {1, 2, 3, 4, 5, 6}, shown below. Which of the following is NOT a topological ordering?&nbsp;",1 2 3 4 5 6,1 3 2 4 5 6,1 3 2 4 6 5,3 2 4 1 6 5,D,"In option D, 1 appears after 2 and 3 which is not possible in Topological Sorting. In the given DAG it is directly visible that there is an outgoing edge from vertex 1 to vertex 2 and 3 hence 2 and 3 cannot come before vertex 1 so clearly option D is an incorrect topological sort. But for questions in which it is not directly visible, we should know how to find a topological sort of a DAG.&nbsp; Hence Option(D) is the correct answer.",Graph,Medium,Medium,0.25
285,Let G be a graph with n vertices and m edges. What is the tightest upper bound on the running time on Depth First Search of G? Assume that the graph is represented using adjacency matrix.,O(n),O(m+n),O(n2),O(mn),D,"Depth First Search of a graph takes O(m+n) time when the graph is represented using adjacency list.

In adjacency matrix representation, graph is represented as an ""n x n"" matrix.  To do DFS, for every vertex, we traverse the row corresponding to that vertex to find all adjacent vertices (In adjacency list representation we traverse only the adjacent vertices of the vertex). Therefore time complexity becomes O(n2)",Graph,Medium,Medium,0.25
286,"Consider the tree arcs of a BFS traversal from a source node W in an unweighted, connected, undirected graph. The tree T formed by the tree arcs is a data structure for computing.",the shortest path between every pair of vertices.,the shortest path from W to every vertex in the graph.,the shortest paths from W to only those nodes that are leaves of T.,the longest path in the graph,C,"Explanation:&nbsp;The correct answer is (B) the shortest path from W to every vertex in the graph. When performing a Breadth First Search (BFS) traversal from a source node W in an unweighted, connected, undirected graph, the tree T formed by the tree arcs represents the shortest path from W to every other vertex in the graph.&nbsp;BFS explores the graph level by level, starting from the source node W. As it traverses the graph, it discovers the vertices in increasing order of their distance from W. The tree arcs in the resulting tree T represent the shortest paths from W to each vertex, as BFS ensures that the vertices are visited in the order of their distance from the source.&nbsp;Option (A) the shortest path between every pair of vertices is not correct because the tree T only represents the shortest path from W to every vertex, not between all pairs of vertices in the graph.&nbsp;Option (C) the shortest paths from W to only those nodes that are leaves of T is also not correct. The tree T formed by BFS includes all vertices reachable from W, not just the leaves of the tree. It represents the shortest path to every vertex, regardless of whether it is a leaf or an internal node in the tree.&nbsp;Option (D) the longest path in the graph is also not correct. BFS does not provide information about the longest path in the graph. It focuses on finding the shortest paths from the source node W to other vertices, not the longest paths. Therefore, the correct answer is (B) the shortest path from W to every vertex in the graph.Quiz of this Question",Graph,Easy,Low,0.27
287,Suppose depth first search is executed on the graph below starting at some unknown vertex. Assume that a recursive call to visit a vertex is made only after first checking that the vertex has not been visited earlier. Then the maximum possible recursion depth (including the initial call) is _________.,17,18,19,20,D,"The following diagram shows the worst case situation where the recursion tree has maximum depth.  



So the recursion depth is 19 (including the first node).",Graph,Medium,Medium,0.25
288,Let T be a depth first search tree in an undirected graph G. Vertices u and n are leaves of this tree T. The degrees of both u and n in G are at least 2. which one of the following statements is true?,There must exist a vertex w adjacent to both u and n in G,There must exist a vertex w whose removal disconnects u and n in G,There must exist a cycle in G containing u and n,There must exist a cycle in G containing u and all its neighbours in G.,E,"Below example shows that A and B are FALSE:


Below example shows C is false:",Graph,Easy,Low,0.27
289,"Let G be an undirected graph. Consider a depth-first traversal of G, and let T be the resulting depth-first search tree. Let u be a vertex in G and let v be the first new (unvisited) vertex visited after visiting u in the traversal. Which of the following statements is always true?","{u,v} must be an edge in G, and u is a descendant of v in T","{u,v} must be an edge in G, and v is a descendant of u in T","If {u,v} is not an edge in G then u is a leaf in T","If {u,v} is not an edge in G then u and v must have the same parent in T",D,"In DFS, if 'v' is visited
after 'u', then one of the following is true.
1) (u, v) is an edge.
     u
   /   \
  v     w
 /     / \
x     y   z

2) 'u' is a leaf node.
     w
   /   \
  x     v
 /     / \
u     y   z 
In DFS, after visiting a node, we first recur for all unvisited children.  If there are no unvisited children (u is leaf), then control goes back to parent and parent then visits next unvisited children.",Graph,Easy,Low,0.27
290,"In a depth-first traversal of a graph G with n vertices, k edges are marked as tree edges. The number of connected components in G is",k,k + 1,n - k - 1,n - k,E,"Tree edges are the edges that are part of DFS tree.  If there are x tree edges in a tree, then  x+1 vertices in the tree.

The output of DFS is a forest if the graph is disconnected.  Let us see below simple example where graph is disconnected.



&nbsp;

The above example matches with D option

More Examples:

1) All vertices  of Graph are connected.  k must be n-1.  We get number of connected components  = n- k =  n - (n-1) = 1

2) No vertex is connected. k must be 0.  We get number of connected components  = n- k =  n - 0 = n",Graph,Medium,Medium,0.25
291,Consider the following directed graph.  The number of different topological orderings of the vertices of the graph is &nbsp; Note : This question was asked as Numerical Answer Type.,1,2,4,6,E,"Following are different 6 Topological Sortingsa-b-c-d-e-f
a-d-e-b-c-f
a-b-d-c-e-f
a-d-b-c-e-f
a-b-d-e-c-f
a-d-b-e-c-f",Graph,Easy,Low,0.27
292,"In an adjacency list representation of an undirected simple graph G = (V, E), each edge (u, v) has two adjacency list entries: [v] in the adjacency list of u, and [u] in the adjacency list of v. These are called twins of each other. A twin pointer is a pointer from an adjacency list entry to its twin. If |E| = m and |V | = n, and the memory size is not a constraint, what is the time complexity of the most efficient algorithm to set the twin pointer in each entry in each adjacency list?",Θ(n2),Θ(m+n),Θ(m2),Θ(n4),C,"First you need to find twins of each node. You can do this using level order traversal (i.e., BFS) once. Time complexity of BFS is Θ(m +n).
And you have to use linked list for representation which is extra space (but memory size is not a constraint here).
Final, time complexity is Θ(m + n) to set twin pointer.

Option (B) is correct.",Graph,Easy,Low,0.27
293,"Let  G = (V, G) be a weighted undirected graph and let T be a Minimum Spanning Tree (MST) of G maintained using adjacency lists. Suppose a new weighed edge (u, v) ∈ V×V is added to G. The worst case time complexity of determining if T is still an MST of the resultant graph is",Θ(∣E∣ + ∣V∣),Θ(∣E∣.∣V∣),Θ(E∣ log ∣V∣),Θ(∣V∣),D,"In a graph with distinct edge weights, BFS cannot be directly applied for this purpose. Here's an alternative approach:For a minimum spanning tree (MST) with V vertices, there are V−1 edges. Traversing the adjacency list has a time complexity of O(V+E), and since we are dealing with V−1 edges, the traversal effectively takes O(V) time.The tree is given instead of the Entire graph and in a tree E=V-1, Hence TC = [Tex]\theta[/Tex](V + E) = [Tex]\Theta[/Tex](V + V-1) = Θ(V)While traversing the adjacency list of T, compare the weight of the newly added edge with the weights of the edges in the MST. If the new edge has a smaller weight, the MST will be updated. Otherwise, no changes are needed.Thus, the time complexity of this process is O(V).",Graph,Easy,Low,0.27
294,An articulation point in a connected graph is a vertex such that removing the vertex and its incident edges disconnects the graph into two or more connected components.&nbsp;Let T be a DFS tree obtained by doing DFS in a connected undirected graph G. Which of the following options is/are correct?,Root of T can never be an articulation point in G.,Root of T is an articulation point in G if and only if it has 2 or more children.,A leaf of T can be an articulation point in G.,"If u is an articulation point in G such that x is an ancestor of u in T and y is a descendent of u in T, then all paths from x to y in G must pass through u.",C,"We check all the options one by one:Option (A): Root of T can never be an articulation point in G. This option is FALSE.Look at the following DFS tree T of a graph G:When root can be an articulation pointWe can clearly see that removing the vertex corresponding to the root of T, will disconnect the graph into two components. Thus the root of T can be an articulation point in G.Option (B): Root of T is an articulation point in G if and only if it has 2 or more children. This option is TRUE.From the above example and the following tree:Root can be an articulation iff there are 2 or more childrenThe root of T has 1 child, and as such removing its corresponding vertex in G does not disconnect the graph into two (or more) components. Thus the root can not be an articulation point in this scenario. Therefore having at least 2 children is a compulsory condition for the root of T to be an articulation point.Option (C): A leaf of T can be an articulation point in G. This option is FALSE.From the tree T below:&nbsp;We can understand that any leaf of T is connected to only one node, i.e. its parent. Thus removing the vertex corresponding to T in the graph will not disconnect the graph into two or more components. So, a leaf of T can never be an articulation point in G.Option (D): If u is an articulation point in G such that x is an ancestor of u in T and y is a descendant of u in T, then all paths from x to y in G must pass through u. This option is FALSE.Let us take an example of a graph G:&nbsp;For this graph G, we can verify that in T (obtained by doing DFS): u is an articulation point in G, x is an ancestor of u and y is a descendent of u. All the conditions are satisfied, yet we have a path from x to y in G (x-&gt;w-&gt;v-&gt;y) that does not pass through u.Thus the only correct option is B.Articulation points in a graph are found using the Depth First Search (https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/).Quiz of this Question",Graph,Easy,Low,0.27
295,Consider the following directed graph:Which of the following is/are correct about the graph?,The graph does not have a topological order,A depth-first traversal starting at vertex S classifies three directed edges as back edges,The graph does not have a strongly connected component,"For each pair of vertices u and v, there is a directed path from u to v",A,"(A) True, because of cycle in the bottom left corner of the graph.  (B) True, we can come back length of 3 edges.  (C)  The graph does have a strongly connected component, it has cycle.  (D) False, not a strongly connected graph.",Graph,Easy,Low,0.27
296,"In a directed acyclic graph with a source vertex s, the quality-score of a directed path is defined to be the product of the weights of the edges on the path. Further, for a vertex v other than s, the quality-score of v is defined to be the maximum among the quality-scores of all the paths from s to v. The quality-score of s is assumed to be 1.



The sum of the quality-scores of all vertices on the graph shown above is _______ .",929,81,729,1023,B,"Let Q(V) denote the quality-score of vertex V.
Q(S) = 1 (Given)
Q(C) = 1 (S → C)
Q(F) = 1 * 9 (S  → C  → F)
Q(A) = 9 (S  → A)
Q(D) = 9*1 (S  → A  → D)
Q(G) = 9 * 1 * 9 (S  → A  → D  → G)
Q(B) = 9 * 1 (S  → A  → B)
Q(E) = 9 * 1 * 9 (S  → A  → D  → E)
Q(T) = 9*1*9*9 (S  → A  → D  → E → T) 

Sum of quality-score of all vertices, 

= 1 + 1 + 9 + 9 + 9 + 81 + 9 + 81 + 729 
= 929",Graph,Easy,Low,0.27
297,Consider a complete binary tree with 7 nodes. Let A denote the set of first 3 elements obtained by performing Breadth-First Search (BFS) starting from the root. Let B denote the set of first 3 elements obtained by performing Depth-First Search (DFS) starting from the root.  The value of ∣A−B∣ is _____________ .,1,2,3,4,A,"In case of BFS if we draw complete binary tree then in Set A we have level1+level2. In DFS we have level1+ level 2 + level 3. Level 1 = 1 element, level 2 = 2 elements, level 3= 4 elements. Total of 7 elements. Set A have: Level 1 = 1st element, Level 2 = 2nd &amp; 3rd element.Set B have: Level 1 = 1 element, level 2 = 2nd element, level 3= 3rd element.L1 x 1 element from L2 (A ∩ B) Element in A not in B.So A-B= remaining element of level 2. |A - B = 1|",Graph,Medium,Medium,0.25
298,"For a given graph G having v vertices and e edges which is connected and has no cycles, which of the following statements is true?",v= e-1,e= v-2,v=e+1,None,D,"For a given graph G is connected, has no cycles (also called acyclic), and has v - 1 edges. Since G is connected and has no cycles, and the number of edges (e) is v - 1, it satisfies the definition of a tree. Trees are fundamental data structures in graph theory and have important applications in computer science and various other fields.The number of edges e= v-1 or v= e+1.Hence Option(C) is the correct answer.",Graph,Medium,Medium,0.25
299,"Which data structure is commonly used to implement the navigation system in a mapping application, helping users find the shortest route between locations?",Heap,Stack,Graph,Queue,D,"The data structure commonly used to implement the navigation system in a mapping application, helping users find the shortest route between locations, is a graph.Hence Option (C) is the correct answer.",Graph,Medium,Medium,0.25
300,Identify the following Representation of the graph.,Adjacency List,Adjacency Matrix,Both,None,B,The above representation is the Adjacency matrix of the graph.Hence Option(B) is the correct answer.,Graph,Medium,Medium,0.25
301,"Which of the following statement is correct?P1: Every tree will always be a graphP2: Every graph will always be trees.P3: Every tree will be a graph, but every graph will not be a treeP4: Every graph will be a tree, but every tree will not be a graph.",P1 and P2,P1,P2,P1 and P3,E,"Trees are the restricted types of graphs, just with some more rules. Every tree will always be a graph but not all graphs will be trees. Linked List, Trees, and Heaps all are special cases of graphs.&nbsp;&nbsp;Hence Option(D) is the correct answer.",Graph,Medium,Medium,0.25
