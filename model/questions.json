[
  {
    "Question ID": 1,
    "Question Text": "What will the output of the below code?\n        C++\n        \n        #include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\n    int arr[2] = { 1, 2 };\n    cout &lt;&lt; arr[0] &lt;&lt; &quot;, &quot; &lt;&lt; arr[1] &lt;&lt; endl;\n    return 0;\n}\n\n        \n    \n        Java\n        \n        public class Main {\n    public static void main(String[] args) {\n        int[] arr = {1, 2};\n        System.out.println(arr[0] + &quot;, &quot; + arr[1]);\n    }\n}",
    "Option A": "1, 2",
    "Option B": "Syntax error",
    "Option C": "Run time error",
    "Option D": "",
    "Correct Answer": "A",
    "Explanation": "The code declares an integer array arr with two elements, 1 and 2, and then prints them as 1, 2 using cout.",
    "Concept": "Array",
    "Difficulty": 0.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 2,
    "Question Text": "The minimum number of comparisons required to determine if an integer appears more than n/2 times in a sorted array of n integers is",
    "Option A": "\u0398(n)",
    "Option B": "\u0398(logn)",
    "Option C": "\u0398(n*logn)",
    "Option D": "\u0398(1)",
    "Correct Answer": "B",
    "Explanation": "If you answered Theta(1), then think of examples {1, 2, 2, 2, 4, 4}, {1, 1, 2, 2, 2, 2, 3, 3} The Best way to find out whether an integer appears more than n/2 times in a sorted array(Ascending Order) of n integers, would be binary search approach.The First occurrence of an element can be found out in O(log(n)) time using divide and conquer technique,lets say it is i.The Last occurrence of an element can be found out in O(log(n)) time using divide and conquer technique,lets say it is j.Now number of occurrence of that element(count) is (j-i+1). Overall time complexity = log n +log n +1 = O(logn)See Check for Majority Element in a sorted array This solution is contributed by Nirmal Bharadwaj",
    "Concept": "Array",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 3,
    "Question Text": "An algorithm performs (logN)1/2  find operations, N insert operations, (logN)1/2 , delete operations, and (logN)1/2  decrease-key operations on a set of data items with keys drawn from a linearly ordered set. For a delete operation, a pointer is provided to the record that must be deleted. For the decrease-key operation, a pointer is provided to the record that has its key decreased. Which one of the following data structures is the most suited for the algorithm to use, if the goal is to achieve the best total asymptotic complexity considering all the operations?",
    "Option A": "Unsorted array",
    "Option B": "Min-heap",
    "Option C": "Sorted array",
    "Option D": "Sorted doubly linked list",
    "Correct Answer": "A",
    "Explanation": "The time complexity of insert in unsorted array is O(1), O(Logn) in Min-Heap, O(n) in sorted array and sorted DLL. For unsorted array, we can always insert an element at end and do insert in O(1) timeFor Min Heap, insertion takes O(Log n) time. Refer Binary Heap operations for details. For sorted array, insert takes O(n) time as we may have to move all elements worst case. For sorted doubly linked list, insert takes O(n) time to find position of element to be inserted. Since number of insertion operations is asymptotically higher, unsorted array is preferred.",
    "Concept": "Array",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 4,
    "Question Text": "Consider an array consisting of \u2013ve and +ve numbers. What would be the worst case time complexity of an algorithm to segregate the numbers having same sign altogether i.e all +ve on one side and then all -ve on the other ?",
    "Option A": "O(N)",
    "Option B": "O(N Log N)",
    "Option C": "O(N * N)",
    "Option D": "O(N Log Log N)",
    "Correct Answer": "A",
    "Explanation": "Here we can use the partition algorithm of quick sort for segregation and answer will be O(N).",
    "Concept": "Array",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 5,
    "Question Text": "Let A[1...n] be an array of n distinct numbers. If i &lt; j and A[i] &gt; A[j], then the pair (i, j) is called an inversion of A. What is the expected number of inversions in any permutation on n elements ?",
    "Option A": "n(n-1)/2",
    "Option B": "n(n-1)/4",
    "Option C": "n(n+1)/4",
    "Option D": "2n[logn]",
    "Correct Answer": "B",
    "Explanation": "There are n(n-1)/2 pairs such that i &lt; j. For a pair (ai, aj), probability of being inversion is 1/2. Therefore expected value of inversions = 1/2 * (n(n-1)/2) = n(n-1)/4.",
    "Concept": "Array",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 6,
    "Question Text": "Consider a two dimensional array A[20][10]. Assume 4 words per memory cell, the base address of array A is 100, elements are stored in row-major order and first element is A[0][0]. What is the address of A[11][5] ?",
    "Option A": "560",
    "Option B": "460",
    "Option C": "570",
    "Option D": "575",
    "Correct Answer": "A",
    "Explanation": "Element A[11][0] is stored at \"Base Address + 11 * 10 * 4\" which is  \"Base Address + 440\" = 540.  So A[11][5] is stored at 540 + 5*4 = 560.",
    "Concept": "Array",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 7,
    "Question Text": "An array A consists of n integers in locations A[0], A[1] ....A[n-1]. It is required to shift the elements of the array cyclically to the left by k places, where 1 &lt;= k &lt;= (n-1). An incomplete algorithm for doing this in linear time, without using another array is given below. Complete the algorithm by filling in the blanks. Assume alt the variables are suitably declared.\n        C++\n        \n        min = n; i = 0;\n\nwhile (___________) {\t\n\n     temp = A[i]; j = i;\n\n     while (________) {\n\n     A[j] = ________\t\n\n     j= (j + k) mod n ;\n\n     If ( j&lt; min ) then\n\n         min = j;\n\n}\n\nA[(n + i \u2014 k) mod n] = _________\n\ni = __________",
    "Option A": "i &gt; min; j!= (n+i)mod n; A[j + k]; temp; i + 1 ;",
    "Option B": "i &lt; min; j!= (n+i)mod n; A[j + k]; temp; i + 1;",
    "Option C": "i &gt; min; j!= (n+i+k)mod n; A[(j + k)]; temp; i + 1;",
    "Option D": "i &lt; min; j!= (n+i-k)mod n; A[(j + k)mod n]; temp; i + 1;",
    "Correct Answer": "D",
    "Explanation": "In the five blanks given in the question, the last two blanks must be temp and i+1 because all the given options for the fourth and fifth blanks have temp and i+1. Now, for the first blank, it must be imin then the control goes out of the while loop in the initial case when i=0 and min=n So, the first blank is i &lt; min which implies either option (B) or option (D) is correct. Assume option (B) is correct then in the bracket of while we have j!=(n+i)modn That means whenever j becomes equal to (n+i)modn then control goes out of the while loop. Now (n+i)modn=i and j is always equal to i because in line 3 of the code we are assigning the value of i to j. So, if option (B) is true control never enters the second while loop but it has to enter the second while loop to shift the nos. K places left. Hence, option (D) is correct.",
    "Concept": "Array",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 8,
    "Question Text": "Which of the following correctly declares an array?",
    "Option A": "int geeks[20];",
    "Option B": "int geeks;",
    "Option C": "geeks{20};",
    "Option D": "array geeks[20];",
    "Correct Answer": "A",
    "Explanation": "Option A is correct. Int is the data type used, geeks is the name of the array and 20 is the size of the array.",
    "Concept": "Array",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 9,
    "Question Text": "A three dimensional array in \u2018C++\u2019 is declared as int A[x][y][z]. Consider that array elements are stored in row major order and indexing begins from 0. Here, the address of an item at the location A[p][q][r] can be computed as follows (where w is the word length of an integer):",
    "Option A": "&amp;A[0][0][0] + w(y * z * q + z * p + r)",
    "Option B": "&amp;A[0][0][0] + w(y * z * p + z*q + r)",
    "Option C": "&amp;A[0][0][0] + w(x * y * p + z * q+ r)",
    "Option D": "&amp;A[0][0][0] + w(x * y * q + z * p + r)",
    "Correct Answer": "B",
    "Explanation": "According to above question we have to find the address of A[p][q][r] To reach pth row we must have to cross 0 to p-1 row i.e. p rows and each rows contains y\u2217z elements Hence , = y\u2217z\u2217p Now to reach qth element in pth row we have to cross q rows and each row contains z(total columns) elements =z\u2217q to reach rth elements we have to cross r elements in (p+1)th row Total elements to cross =(y\u2217z\u2217p+z\u2217q+r) Now each element occupies m amount of space in memory Therefore total space occupied by these elements = m(y\u2217z\u2217p+z\u2217q+r) Hence , address of A[p][q][r]=base address+ Space Occupied by the Elements Before it. =&amp;A[0][0][0]+m(y*z*p+z*q+r) Hence Option (B) is correct.",
    "Concept": "Array",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 10,
    "Question Text": "Let A be a square matrix of size n x n. Consider the following program. What is the expected output?&nbsp;C = 100for i = 1 to n do    for j = 1 to n do    {        Temp = A[i][j] + C        A[i][j] = A[j][i]        A[j][i] = Temp - C    } for i = 1 to n do    for j = 1 to n do        Output(A[i][j]);",
    "Option A": "The matrix A itself",
    "Option B": "Transpose of matrix A",
    "Option C": "Adding 100 to the upper diagonal elements and subtracting 100 from diagonal elements of A",
    "Option D": "Inverse of matrix A",
    "Correct Answer": "A",
    "Explanation": "If we take look at the inner statements of first loops, we can notice that the statements swap A[i][j] and A[j][i] for all i and j. Since the loop runs for all elements, every element A[l][m] would be swapped twice, once for i = l and j = m and then for i = m and j = l. Swapping twice means the matrix doesn\u2019t change.",
    "Concept": "Array",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 11,
    "Question Text": "A program P reads in 500 integers in the range [0..100] representing the scores of 500 students. It then prints the frequency of each score above 50. What would be the best way for P to store the frequencies?&nbsp;",
    "Option A": "An array of 50 numbers&nbsp;",
    "Option B": "An array of 100 numbers&nbsp;",
    "Option C": "An array of 500 numbers&nbsp;",
    "Option D": "A dynamically allocated array of 550 numbers&nbsp;",
    "Correct Answer": "A",
    "Explanation": "An array of 50 numbers is correct.",
    "Concept": "Array",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 12,
    "Question Text": "What will the output of the below code, be if the base address of the array is 1200?\n        C++\n        \n        #include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n\n    int arr[] = { 1, 2, 3, 4, 5 };\n    cout &lt;&lt; arr &lt;&lt; &quot;, &quot; &lt;&lt; &amp;arr &lt;&lt; &quot;, &quot; &lt;&lt; &amp;arr[0] &lt;&lt; endl;\n    return 0;\n}",
    "Option A": "1200, 1202, 1204",
    "Option B": "1200 1200 1200",
    "Option C": "1200, 1204, 1208",
    "Option D": "1200, 1204, 1208",
    "Correct Answer": "B",
    "Explanation": "Given that, the base address of the array is 1200.arr, &amp;arr is pointing to the base address of the array arr.&amp;arr[0] is pointing to the address of the first element array arr (base address).Hence the correct option is (B)",
    "Concept": "Array",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 13,
    "Question Text": "What is the correct way to call the function (fun) in the below program?\n        C++\n        \n        #include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid fun(char* arr)\n{\n    int i;\n    unsigned int n = strlen(arr);\n    for (i = 0; i &lt; n; i++)\n        cout &lt;&lt; &quot; &quot; &lt;&lt; arr[i];\n}\n\n// Driver program\nint main()\n{\n    char arr[]\n        = { &#39;g&#39;, &#39;e&#39;, &#39;e&#39;, &#39;k&#39;, &#39;s&#39;, &#39;q&#39;, &#39;u&#39;, &#39;i&#39;, &#39;z&#39; };\n    // How to call the above function here to print the char\n    // elements?\n\n    return 0;\n}",
    "Option A": "fun(&amp;arr);",
    "Option B": "fun(*arr);",
    "Option C": "fun(arr)",
    "Option D": "",
    "Correct Answer": "C",
    "Explanation": "fun(arr) is the correct syntax to call the function having array (arr) as a Parameter.Hence option(C) is correct.&nbsp;",
    "Concept": "Array",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 14,
    "Question Text": "Let A be a matrix of size n x n. Consider the following program. What is the expected output?&nbsp;\n        C++\n        \n        void fun(int A[][N])\n{\n    for (int i = 0; i &lt; N; i++)\n        for (int j = i + 1; j &lt; N; j++)\n            swap(A[i][j], A[j][i]);\n}",
    "Option A": "Matrix A",
    "Option B": "Diagonal Of matrix A",
    "Option C": "Transpose of matrix A",
    "Option D": "",
    "Correct Answer": "C",
    "Explanation": "In the above program, we are just swapping(arr[i][j]) to arr[j][i]). That means row will become column and column will become row.That means the Transpose of the graph.Hence (C) is the correct output.",
    "Concept": "Array",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 15,
    "Question Text": "What will do the following code?\n        C++\n        \n        void fun(int arr[], int n)\n{\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = i; j &lt; n; j++) {\n            for (int k = i; k &lt;= j; k++)\n                cout &lt;&lt; arr[k] &lt;&lt; &quot; &quot;;\n\n            cout &lt;&lt; endl;\n        }\n    }\n}",
    "Option A": "Prints the subsequence of the article.",
    "Option B": "Prints the elements of the array",
    "Option C": "Prints the subarray of the element.",
    "Option D": "",
    "Correct Answer": "C",
    "Explanation": "The above code will print subarray of the elements.Hence the correct option is(C).",
    "Concept": "Array",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 16,
    "Question Text": "Which of the following is the limitation of the array?",
    "Option A": "elements can be accessed from anywhere.",
    "Option B": "The size of the array is fixed.",
    "Option C": "Indexing is started from Zero.",
    "Option D": "Memory waste if an array's elements are smaller than the size allotted to them",
    "Correct Answer": "D",
    "Explanation": "Suppose we have an arry like : arr[5] ={1, 2, 3}Here we have declared the size of the array as 5, but we have initialized only &nbsp;3 values to it. So it leads to memory wastage.Hence Option (D) is correct.",
    "Concept": "Array",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 17,
    "Question Text": "Consider the below program, and what is doing this program basically?\n        C++\n        \n        #include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid print(char a[], int n, int ind)\n{\n    for (int i = ind; i &lt; n + ind; i++)\n        cout &lt;&lt; a[(i % n)] &lt;&lt; &quot; &quot;;\n}\n\nint main()\n{\n    char a[] = { &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; };\n    int n = sizeof(a) / sizeof(a[0]);\n    print(a, n, 3);\n    return 0;\n}",
    "Option A": "It is printing the normal array",
    "Option B": "It is printing circular array rotated by 3",
    "Option C": "Syntax error",
    "Option D": "",
    "Correct Answer": "B",
    "Explanation": "In the above program, we are just shifting the array elements by 3 circularly.we are running loop from i = 3 to 9.Inside the loop we are printing arr[3%6] = arr[3] = 'D'arr[4 % 6] = arr[4] &nbsp;= 'E'arr[5 % 6] = arr[5] = 'F'arr[6 % 6] = arr[0] = 'A'arr[7 % 6] = arr[1] = 'B'arr[8 % 6] = arr[2] = 'C'Hence Option (B) is correct.",
    "Concept": "Array",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 18,
    "Question Text": "Fill in the blanks for completing the program to rotate an array by d elements.\n        C++\n        \n        /*Function to left rotate arr[] of size n by d*/\nvoid Rotate(int arr[], int d, int n)\n{\n    int p = 1;\n    while (_______) {\n        int last = arr[0];\n        for (int i = 0; ______ i++) {\n            arr[i] = arr[i + 1];\n        }\n        __________\n        p++;\n    }\n}",
    "Option A": "p &lt;= d , i &lt; n - 1 , arr[n - 1] = last;",
    "Option B": "p &lt; d, i &lt; n, arr[n] = last;",
    "Option C": "p &gt;=d, i &gt;n , arr[n] = &nbsp;last",
    "Option D": "",
    "Correct Answer": "A",
    "Explanation": "In the three blanks given in the questions.The first blank will be a conditional statement which should be (p.&lt;=d) because p starts with 1 and goes till d.The second blank should be the condition for looping, which is (i &lt; n-1), because the loop will run till n-1 elements.and the last blank will be updating the last element.Hence Option(A) is correct.",
    "Concept": "Array",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 19,
    "Question Text": "Refer the below diagram and identify the problem.&nbsp;",
    "Option A": "Normal traversal of the matrix.",
    "Option B": "Row-wise traversal of the matrix.",
    "Option C": "Column-wise traversal of the matrix.",
    "Option D": "spiral traversal of the matrix.",
    "Correct Answer": "D",
    "Explanation": "The image is for the spiral traversal of the matrix.Refer the below article:https://www.geeksforgeeks.org/print-a-given-matrix-in-spiral-form/Hence Option (D) is correct.",
    "Concept": "Array",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 20,
    "Question Text": "Consider the below program. What is the expected output?&nbsp;\n        C++\n        \n        void fun(int arr[], int start, int end)\n{\n    while (start &lt; end) {\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}",
    "Option A": "swapping the elements pairwise",
    "Option B": "sorting the elements",
    "Option C": "Reverse an array",
    "Option D": "",
    "Correct Answer": "C",
    "Explanation": "The above code is for reversing an array of elements., we are just swapping the first and last element of the array, and the whole array is reversed.For more reference:https://www.geeksforgeeks.org/write-a-program-to-reverse-an-array-or-string/Hence Option(C) is correct.&nbsp;",
    "Concept": "Array",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 21,
    "Question Text": "What does the following function do for a given Linked List with first node as head?\n        C++\n        \n        void fun1(struct node* head)\n{\n  if(head == NULL)\n    return;\n  \n  fun1(head-&gt;next);\n  printf(&quot;%d  &quot;, head-&gt;data);\n}\n\n        \n    \n        C\n        \n        void fun1(struct node* head) {\n  if(head == NULL)\n    return;\n  \n  fun1(head-&gt;next);\n  printf(&quot;%d  &quot;, head-&gt;data);\n}\n\n        \n    \n        Java\n        \n        void fun1(Node head) {\n  if(head == null)\n    return;\n  \n  fun1(head.next);\n  System.out.print(head.data + &quot;  &quot;);\n}\n\n        \n    \n        Python\n        \n        def fun1(head):\n  if head is None:\n    return\n  \n  fun1(head.next)\n  print(head.data, end=&#39;  &#39;)\n\n        \n    \n        JavaScript\n        \n        function fun1(head) {\n  if (head === null)\n    return;\n  \n  fun1(head.next);\n  console.log(head.data + &#39;  &#39;);\n}",
    "Option A": "Prints all nodes of linked lists",
    "Option B": "Prints all nodes of linked list in reverse order",
    "Option C": "Prints alternate nodes of Linked List",
    "Option D": "Prints alternate nodes in reverse order",
    "Correct Answer": "B",
    "Explanation": "This function fun1 recursively prints the elements of a linked list in reverse order.It first checks if the head is NULL, and if it is, it returns without doing anything. Otherwise, it calls the fun1 function recursively with the next node in the linked list (head-&gt;next). This continues until the last node is reached, which is the node whose next pointer is NULL.At this point, the function starts returning, and as it returns it prints the value of each node in the linked list starting from the last node, working its way backwards to the first node. This is achieved through the printf statement which prints the value of head-&gt;data.Thus, when this function is called with the head of a linked list as an argument, it will print the values of the nodes in reverse order.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 22,
    "Question Text": "Which of the following points is/are true about Linked List data structure when it is compared with array?",
    "Option A": "Arrays have better cache locality that can make them better in terms of performance.",
    "Option B": "It is easy to insert and delete elements in Linked List",
    "Option C": "Random access is not allowed in a typical implementation of Linked Lists",
    "Option D": "The size of array has to be pre-decided, linked lists can change their size any time.",
    "Correct Answer": "E",
    "Explanation": "The following points are true when comparing Linked List data structure with an array:Insertion and deletion: Linked lists allow for efficient insertion and deletion operations at any point in the list, as they involve simply adjusting pointers, while in an array, these operations can be expensive as all the elements after the insertion or deletion point need to be shifted.Memory allocation: Linked lists use dynamic memory allocation, so they can grow or shrink as needed, while arrays have a fixed size and need to be allocated a contiguous block of memory upfront.Access time: Arrays provide constant-time access to any element in the array (assuming the index is known), while accessing an element in a linked list takes linear time proportional to the number of elements in the list, as the list needs to be traversed from the beginning to find the desired element.Random access: Arrays support random access, which means that we can directly access any element in the array with its index, while linked lists do not support random access and we need to traverse the list to find a specific element.",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 23,
    "Question Text": "Consider the following function that takes reference to head of a Doubly Linked List as parameter. Assume that a node of doubly linked list has previous pointer as prev and next pointer as next.&nbsp;\n        C++\n        \n        void fun(struct node **head_ref) {\n    struct node *temp = NULL;\n    struct node *current = *head_ref;\n\n    while (current != NULL) {\n        temp = current-&gt;prev;\n        current-&gt;prev = current-&gt;next;\n        current-&gt;next = temp;\n        current = current-&gt;prev;\n    }\n\n    if (temp != NULL)\n        *head_ref = temp-&gt;prev;\n}\n\n        \n    \n        C\n        \n        void fun(struct node **head_ref)\n{\n    struct node *temp = NULL;\n    struct node *current = *head_ref;\n\n    while (current !=  NULL)\n    {\n        temp = current-&gt;prev;\n        current-&gt;prev = current-&gt;next;\n        current-&gt;next = temp;\n        current = current-&gt;prev;\n    }\n\n    if(temp != NULL )\n        *head_ref = temp-&gt;prev;\n}\n\n        \n    \n        Java\n        \n        void fun(Node[] head_ref) {\n    Node temp = null;\n    Node current = head_ref[0];\n\n    while (current != null) {\n        temp = current.prev;\n        current.prev = current.next;\n        current.next = temp;\n        current = current.prev;\n    }\n\n    if (temp != null)\n        head_ref[0] = temp.prev;\n}\n\n        \n    \n        Python\n        \n        def fun(head_ref):\n    temp = None\n    current = head_ref[0]\n\n    while current is not None:\n        temp = current.prev\n        current.prev = current.next\n        current.next = temp\n        current = current.prev\n\n    if temp is not None:\n        head_ref[0] = temp.prev\n\n        \n    \n        JavaScript\n        \n        function fun(head_ref) {\n    let temp = null;\n    let current = head_ref[0];\n\n    while (current !== null) {\n        temp = current.prev;\n        current.prev = current.next;\n        current.next = temp;\n        current = current.prev;\n    }\n\n    if (temp !== null)\n        head_ref[0] = temp.prev;\n}\n\n        \n    Assume that reference of head of following doubly linked list is passed to above function 1 &lt;--&gt; 2 &lt;--&gt; 3 &lt;--&gt; 4 &lt;--&gt; 5 &lt;--&gt;6. What should be the modified linked list after the function call?",
    "Option A": "2 &lt;--&gt; 1 &lt;--&gt; 4 &lt;--&gt; 3 &lt;--&gt; 6 &lt;--&gt;5",
    "Option B": "5 &lt;--&gt; 4 &lt;--&gt; 3 &lt;--&gt; 2 &lt;--&gt; 1 &lt;--&gt;6.",
    "Option C": "6 &lt;--&gt; 5 &lt;--&gt; 4 &lt;--&gt; 3 &lt;--&gt; 2 &lt;--&gt; 1.",
    "Option D": "6 &lt;--&gt; 5 &lt;--&gt; 4 &lt;--&gt; 3 &lt;--&gt; 1 &lt;--&gt; 2",
    "Correct Answer": "C",
    "Explanation": "This function fun takes a double pointer to the head of a doubly linked list as its argument and reverses the order of the nodes in the list. By performing the following steps: Recursively traverse the&nbsp;doubly linked list until it reaches the last node.While&nbsp;backtracking, reverse the links between the nodes. To reverse the links:Change the&nbsp;next&nbsp;pointer of the&nbsp;current&nbsp;node&nbsp;to point to its&nbsp;previous&nbsp;node.Change the&nbsp;prev&nbsp;pointer of the&nbsp;current&nbsp;node&nbsp;to point to its&nbsp;next&nbsp;node.Adjust the&nbsp;head&nbsp;of the doubly linked list to point to the&nbsp;last&nbsp;node.For more reference: Reverse a Double linked ListHence Option(C) is correct answer.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 24,
    "Question Text": "The following function reverse() is supposed to reverse a singly linked list. There is one line missing at the end of the function.&nbsp;\n        C++\n        \n        // Link list node\nstruct node\n{\n    int data;\n    struct node* next;\n};\n\n// head_ref is a double pointer which points to head (or start) pointer \nof linked list\nstatic void reverse(struct node** head_ref)\n{\n    struct node* prev   = NULL;\n    struct node* current = *head_ref;\n    struct node* next;\n    while (current != NULL)\n    {\n        next  = current-&gt;next;  \n        current-&gt;next = prev;   \n        prev = current;\n        current = next;\n    }\n     // MISSING STATEMENT HERE\n}\n\n        \n    \n        C\n        \n        /* Link list node */\nstruct node\n{\n    int data;\n    struct node* next;\n};\n\n/* head_ref is a double pointer which points to head (or start) pointer \n  of linked list */\nstatic void reverse(struct node** head_ref)\n{\n    struct node* prev   = NULL;\n    struct node* current = *head_ref;\n    struct node* next;\n    while (current != NULL)\n    {\n        next  = current-&gt;next;  \n        current-&gt;next = prev;   \n        prev = current;\n        current = next;\n    }\n    /*MISSING STATEMENT HERE*/\n}\n \n\n        \n    \n        Java\n        \n        // Link list node\nclass Node {\n    int data;\n    Node next;\n    Node(int d) { data = d; next = null; }\n}\n\n// head_ref is a reference to the head pointer of linked list\nstatic void reverse(Node[] head_ref) {\n    Node prev = null;\n    Node current = head_ref[0];\n    Node next;\n    while (current != null) {\n        next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    // MISSING STATEMENT HERE\n}\n\n        \n    \n        Python\n        \n        # Link list node\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n# head_ref is a reference to the head pointer of linked list\ndef reverse(head_ref):\n    prev = None\n    current = head_ref\n    while current is not None:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n     # MISSING STATEMENT HERE\n\n        \n    \n        JavaScript\n        \n        // Link list node\nclass Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// head_ref is a reference to the head pointer of linked list\nfunction reverse(head_ref) {\n    let prev = null;\n    let current = head_ref;\n    let next;\n    while (current !== null) {\n        next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    // MISSING STATEMENT HERE\n}\n\n        \n    What should be added in place of \"/*ADD A STATEMENT HERE*/\", so that the function correctly reverses a linked list.",
    "Option A": "Set the value of head_ref to prev;",
    "Option B": "Set the value of head_ref to current;",
    "Option C": "Set the value of head_ref to next;",
    "Option D": "Set the value of head_ref to NULL;",
    "Correct Answer": "A",
    "Explanation": "The missing statement should sets the value of *head_ref (which is a double pointer) to the value of prev, which is the new head of the reversed list.Hence correct option is (A).",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 25,
    "Question Text": "What is the output of following function in which start is pointing to the first node of the following linked list 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 ?\n        C++\n        \n        #include &lt;iostream&gt;\nusing namespace std;\n\nstruct node {\n    int data;\n    node* next;\n};\n\nvoid fun(node* start) {\n    if (start == NULL)\n        return;\n    cout &lt;&lt; start-&gt;data &lt;&lt; &quot;  &quot;;\n    \n    if (start-&gt;next != NULL)\n        fun(start-&gt;next-&gt;next);\n    cout &lt;&lt; start-&gt;data &lt;&lt; &quot;  &quot;;\n}\n\n        \n    \n        C\n        \n        void fun(struct node* start)\n{\n  if(start == NULL)\n    return;\n  printf(&quot;%d  &quot;, start-&gt;data); \n \n  if(start-&gt;next != NULL )\n    fun(start-&gt;next-&gt;next);\n  printf(&quot;%d  &quot;, start-&gt;data);\n}\n\n        \n    \n        Java\n        \n        class Node {\n    int data;\n    Node next;\n    Node(int d) { data = d; next = null; }\n}\n\nvoid fun(Node start) {\n    if (start == null)\n        return;\n    System.out.print(start.data + &quot;  &quot;);\n    \n    if (start.next != null)\n        fun(start.next.next);\n    System.out.print(start.data + &quot;  &quot;);\n}\n\n        \n    \n        Python\n        \n        class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\ndef fun(start):\n    if start is None:\n        return\n    print(start.data, end=&#39;  &#39;)\n    \n    if start.next is not None:\n        fun(start.next.next)\n    print(start.data, end=&#39;  &#39;)\n\n        \n    \n        JavaScript\n        \n        class Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nfunction fun(start) {\n    if (start === null)\n        return;\n    console.log(start.data + &#39;  &#39;);\n    \n    if (start.next !== null)\n        fun(start.next.next);\n    console.log(start.data + &#39;  &#39;);\n}",
    "Option A": "1 4 6 6 4 1",
    "Option B": "1 3 5 1 3 5",
    "Option C": "1 2 3 5",
    "Option D": "1 3 5 5 3 1",
    "Correct Answer": "D",
    "Explanation": "The function prints the data of the current node and then recursively calls itself with the second next node (i.e., start-&gt;next-&gt;next).So, it prints the data of every alternate node of the linked list i.e 1 3 5, and then, since the next-&gt;next of 5 is null, it returns and prints the data of the current node, so it then prints 5 3 1.Therefore, for the given linked list 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6, the function would print 1 3 5 5 3 1.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 26,
    "Question Text": "The following C function takes a simply-linked list as input argument. It modifies the list by moving the last element to the front of the list and returns the modified list. Some part of the code is left blank. Choose the correct alternative that contain the correct pseudocode for the blank line.&nbsp;\n        C++\n        \n        #include &lt;iostream&gt;\nstruct Node {\n    int value;\n    Node *next;\n};\n\nNode* move_to_front(Node *head) {\n    Node *p, *q;\n    if (head == NULL || head-&gt;next == NULL)\n        return head;\n    q = NULL; p = head;\n    while (p-&gt;next != NULL) {\n        q = p;\n        p = p-&gt;next;\n    }\n    __________________________________\n    return head;\n}\n\n        \n    \n        C\n        \n        typedef struct node \n{\n  int value;\n  struct node *next;\n}Node;\n \nNode *move_to_front(Node *head) \n{\n  Node *p, *q;\n  if ((head == NULL: || (head-&gt;next == NULL)) \n    return head;\n  q = NULL; p = head;\n  while (p-&gt; next !=NULL) \n  {\n    q = p;\n    p = p-&gt;next;\n  }\n  _______________________________\n  return head;\n}\n\n        \n    \n        Java\n        \n        class Node {\n    int value;\n    Node next;\n    Node(int value) {\n        this.value = value;\n        this.next = null;\n    }\n}\n\nNode moveToFront(Node head) {\n    Node p, q;\n    if (head == null || head.next == null)\n        return head;\n    q = null; p = head;\n    while (p.next != null) {\n        q = p;\n        p = p.next;\n    }\n    _____________________________________\n    return head;\n}\n\n        \n    \n        Python\n        \n        class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\ndef move_to_front(head):\n    if head is None or head.next is None:\n        return head\n    p = head\n    q = None\n    while p.next is not None:\n        q = p\n        p = p.next\n    ______________________________\n    return head\n\n        \n    \n        JavaScript\n        \n        class Node {\n    constructor(value) {\n        this.value = value;\n        this.next = null;\n    }\n}\n\nfunction moveToFront(head) {\n    if (head === null || head.next === null)\n        return head;\n    let p = head;\n    let q = null;\n    while (p.next !== null) {\n        q = p;\n        p = p.next;\n    }\n   _____________________________\n    return head;\n}",
    "Option A": "q = NULL; next of p = head; head = p;",
    "Option B": "next of q = NULL; head = p; next of p = head;",
    "Option C": "head = p; next of p = q; next of q = NULL;",
    "Option D": "next of q = NULL; next of p = head; head = p;",
    "Correct Answer": "D",
    "Explanation": "To move the last element to the front of the list, we need to do the following steps:Make the second last node as the last node (i.e., set its next pointer to NULL).Set the next pointer of the current last node (which is now the second last node) to the original head node.Make the current last node as the new head node.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 27,
    "Question Text": "The following &nbsp;function takes a single-linked list of integers as a parameter and rearranges the elements of the list. The function is called with the list containing the integers 1, 2, 3, 4, 5, 6, 7 in the given order. What will be the contents of the list after the function completes execution?&nbsp;\n        C++\n        \n        class Node {\npublic:\n    int value;\n    Node* next;\n};\n\nvoid rearrange(Node* list) {\n    Node* p;\n    Node* q;\n    int temp;\n    if (list == nullptr || list-&gt;next == nullptr) {\n        return;\n    }\n    p = list;\n    q = list-&gt;next;\n    while (q != nullptr) {\n        temp = p-&gt;value;\n        p-&gt;value = q-&gt;value;\n        q-&gt;value = temp;\n        p = q-&gt;next;\n        q = (p != nullptr) ? p-&gt;next : nullptr;\n    }\n}\n\n        \n    \n        C\n        \n        struct Node {\n    int value;\n    struct Node* next;\n};\n\nvoid rearrange(struct Node* list) {\n    struct Node* p;\n    struct Node* q;\n    int temp;\n    if (list == NULL || list-&gt;next == NULL) {\n        return;\n    }\n    p = list;\n    q = list-&gt;next;\n    while (q != NULL) {\n        temp = p-&gt;value;\n        p-&gt;value = q-&gt;value;\n        q-&gt;value = temp;\n        p = q-&gt;next;\n        q = (p != NULL) ? p-&gt;next : NULL;\n    }\n}\n\n        \n    \n        Java\n        \n        class Node {\n    int value;\n    Node next;\n}\n\nvoid rearrange(Node list) {\n    Node p, q;\n    int temp;\n    if (list == null || list.next == null) {\n        return;\n    }\n    p = list;\n    q = list.next;\n    while (q != null) {\n        temp = p.value;\n        p.value = q.value;\n        q.value = temp;\n        p = q.next;\n        q = p != null ? p.next : null;\n    }\n}\n\n        \n    \n        Python\n        \n        class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\ndef rearrange(head):\n    if head is None or head.next is None:\n        return\n    p = head\n    q = head.next\n    while q is not None:\n        p.value, q.value = q.value, p.value\n        p = q.next\n        q = p.next if p is not None else None\n\n        \n    \n        JavaScript\n        \n        class Node {\n    constructor(value) {\n        this.value = value;\n        this.next = null;\n    }\n}\n\nfunction rearrange(list) {\n    if (list === null || list.next === null) {\n        return;\n    }\n    let p = list;\n    let q = list.next;\n    while (q !== null) {\n        [p.value, q.value] = [q.value, p.value];\n        p = q.next;\n        q = p !== null ? p.next : null;\n    }\n}",
    "Option A": "1,2,3,4,5,6,7",
    "Option B": "2,1,4,3,6,5,7",
    "Option C": "1,3,2,5,4,7,6",
    "Option D": "2,3,4,5,6,7,1",
    "Correct Answer": "B",
    "Explanation": "The function rearrange() exchanges data of every node with its next node. It starts exchanging data from the first node itself.For eg. 3,5,7,9,11answer:- 5,3,9,7,11",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 28,
    "Question Text": "Suppose each set is represented as a linked list with elements in arbitrary order. Which of the operations among union, intersection, membership, cardinality will be the slowest? (GATE CS 2004)",
    "Option A": "union&nbsp;",
    "Option B": "&nbsp;membership",
    "Option C": "cardinality",
    "Option D": "&nbsp;union, intersection",
    "Correct Answer": "D",
    "Explanation": "Cardinality and membership are definitely not the slowest one. For cardinality, just count the number of nodes in a list. For membership, just traverse the list and look for a matchFor getting intersection of L1 and L2, search for each element of L1 in L2 and print the elements we find in L2.&nbsp;There can be many ways for getting union of L1 and L2. One of them is as follows&nbsp;a) Print all the nodes of L1 and print only those which are not present in L2.&nbsp;b) Print nodes of L2.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 29,
    "Question Text": "Consider the function f defined below.&nbsp;\n        C++\n        \n        #include &lt;iostream&gt;\n\nstruct item {\n    int data;\n    struct item *next;\n};\n\nint f(struct item *p) {\n    return (\n        (p == NULL) || \n        (p-&gt;next == NULL) || \n        ((p-&gt;data &lt;= p-&gt;next-&gt;data) &amp;&amp; f(p-&gt;next))\n    );\n}\n\n        \n    \n        c\n        \n        struct item \n{ \n  int data; \n  struct item * next; \n}; \n\nint f(struct item *p) \n{ \n  return (\n          (p == NULL) || \n          (p-&gt;next == NULL) || \n          (( p-&gt;data &lt;= p-&gt;next-&gt;data) &amp;&amp; f(p-&gt;next))\n         ); \n} \n\n        \n    \n        Java\n        \n        class Item {\n    int data;\n    Item next;\n\n    Item(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\npublic class Main {\n    public static boolean f(Item p) {\n        return (\n            (p == null) || \n            (p.next == null) || \n            ((p.data &lt;= p.next.data) &amp;&amp; f(p.next))\n        );\n    }\n}\n\n        \n    \n        Python\n        \n        class Item:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\ndef f(p):\n    return (\n        p is None or \n        p.next is None or \n        (p.data &lt;= p.next.data and f(p.next))\n    )\n\n        \n    \n        JavaScript\n        \n        class Item {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nfunction f(p) {\n    return (\n        p === null || \n        p.next === null || \n        (p.data &lt;= p.next.data &amp;&amp; f(p.next))\n    );\n}\n\n        \n    For a given linked list p, the function f returns 1 if and only if (GATE CS 2003)",
    "Option A": "not all elements in the list have the same data value.",
    "Option B": "the elements in the list are sorted in non-decreasing order of data value",
    "Option C": "the elements in the list are sorted in non-increasing order of data value",
    "Option D": "None of them",
    "Correct Answer": "B",
    "Explanation": "The function checks if the current element is less than or equal to the next element, and recursively applies the same check to the next element. If the end of the list is reached (i.e., p-&gt;next is NULL), or the next element is less than the current element, the function returns 1. Otherwise, it returns 0. Therefore, the function returns 1 only if the linked list is sorted in non-decreasing order.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 30,
    "Question Text": "A circularly linked list is used to represent a Queue. A single variable p is used to access the Queue. To which node should p point such that both the operations enQueue and deQueue can be performed in constant time? (GATE 2004)&nbsp;",
    "Option A": "rear node",
    "Option B": "front node",
    "Option C": "not possible with a single pointer",
    "Option D": "node next to front",
    "Correct Answer": "A",
    "Explanation": "Answer is not \"(b) front node\", as we can not get rear from front in O(1), but if p is rear we can implement both enQueue and deQueue in O(1) because from rear we can get front in O(1). Below are sample functions. Note that these functions are just sample are not working. Code to handle base cases is missing.&nbsp;\n        C\n        \n        /* p is pointer to address of rear (double pointer).  This function adds new \n   node after rear and updates rear which is *p to point to new node  */\nvoid  enQueue(struct node **p, struct node *new_node)\n{\n    /* Missing code to handle base cases like *p is NULL */\n     \n     new_node-&gt;next = (*p)-&gt;next;\n     (*p)-&gt;next = new_node;\n     (*p) = new_node /* new is now rear */\n     /* Note that p-&gt;next is again front and  p is rear */\n\n }\n\n/* p is pointer to rear. This function removes the front element and \n    returns the dequeued element from the queue */\nstruct node *deQueue(struct node *p)\n{\n    /* Missing code to handle base cases like p is NULL,\n        p-&gt;next is NULL,...  etc */\n\n    struct node *temp = p-&gt;next;\n    p-&gt;next = p-&gt;next-&gt;next;\n    return temp;\n    /* Note that p-&gt;next is again front and  p is rear */\n}\n\n        \n    &nbsp;",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 31,
    "Question Text": "What are the time complexities of finding 8th element from beginning and 8th element from end in a singly linked list? Let n be the number of nodes in linked list, you may assume that n &gt; 8.",
    "Option A": "O(1) and O(n)",
    "Option B": "O(1) and O(1)",
    "Option C": "O(n) and O(1)",
    "Option D": "O(n) and O(n)",
    "Correct Answer": "A",
    "Explanation": "Finding the 8th element from the beginning of a singly linked list requires traversing the first 8 nodes of the list, which takes O(8) time, or simply O(1) time since it's a constant time operation.Finding the 8th element from the end of a singly linked list requires traversing the list until we reach the 8th node from the end. One way to do this is to first traverse the list once to determine its length, and then traverse the list again until we reach the node at position n-8. This takes O(n) time for the first traversal, and then O(n-8) time for the second traversal. Therefore, the time complexity of finding the 8th element from the end of a singly linked list is O(n).",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 32,
    "Question Text": "Is it possible to create a doubly linked list using only one pointer with every node.",
    "Option A": "Not Possible",
    "Option B": "Yes, possible by storing XOR of addresses of previous and next nodes.",
    "Option C": "Yes, possible by storing XOR of current node and next node",
    "Option D": "Yes, possible by storing XOR of current node and previous node",
    "Correct Answer": "B",
    "Explanation": "Yes, it is possible to implement a doubly linked list using a single pointer per node, by storing the XOR of the addresses of the previous and next nodes.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 33,
    "Question Text": "Given pointer to a node X in a singly linked list. Only one pointer is given, pointer to head node is not given, can we delete the node X from given linked list?",
    "Option A": "Possible if X is not last node. Use following two steps (a) Copy the data of next of X to X. (b)Update the pointer of node X to the node after the next node. Delete next of X.",
    "Option B": "Possible if size of linked list is even.",
    "Option C": "Possible if size of linked list is odd",
    "Option D": "Possible if X is not first node. Use following two steps (a) Copy the data of next of X to X. (b) Delete next of X.",
    "Correct Answer": "A",
    "Explanation": "Following are simple steps.    struct node *temp  = X-&gt;next;    X-&gt;data  = temp-&gt;data;    X-&gt;next  = temp-&gt;next;    free(temp);",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 34,
    "Question Text": "Which of the following is an application of XOR-linked lists?",
    "Option A": "Implementing stacks",
    "Option B": "Implementing queues",
    "Option C": "Memory-efficient linked list representation",
    "Option D": "Caching data structures",
    "Correct Answer": "C",
    "Explanation": "XOR linked lists are a memory-efficient representation of linked lists. They store the XOR combination of the addresses of the previous and next nodes, reducing the memory overhead compared to traditional linked lists.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 35,
    "Question Text": "Consider the following function to traverse a linked list.&nbsp;\n        C++\n        \n        // C++ version of traverse function\nvoid traverse(Node *head) {\n    while (head != NULL) {\n        printf(&quot;%d  &quot;, head-&gt;data);\n        head = head-&gt;next;\n    }\n}\n\n        \n    \n        C\n        \n        void traverse(struct Node *head)\n{\n   while (head-&gt;next != NULL)\n   {\n       printf(&quot;%d  &quot;, head-&gt;data);\n       head = head-&gt;next;\n   }\n}\n\n        \n    \n        Java\n        \n        // Java version of traverse function\nvoid traverse(Node head) {\n    while (head != null) {\n        System.out.print(head.data + &quot;  &quot;);\n        head = head.next;\n    }\n}\n\n        \n    \n        Python\n        \n        # Python 3 version of traverse function\ndef traverse(head):\n    while head is not None:\n        print(head.data, end=&#39;  &#39;)\n        head = head.next\n\n        \n    \n        JavaScript\n        \n        // JavaScript version of traverse function\nfunction traverse(head) {\n    while (head !== null) {\n        console.log(head.data + &#39;  &#39;);\n        head = head.next;\n    }\n}\n\n        \n    Which of the following is FALSE about above function?",
    "Option A": "The function may crash when the linked list is empty",
    "Option B": "The function doesn't print the last node when the linked list is not empty",
    "Option C": "The function is implemented incorrectly because it changes head",
    "Option D": "None of the above",
    "Correct Answer": "C",
    "Explanation": "This statement is false because it is common for a function that traverses a linked list to change the head pointer, in order to move through the list. In the given function, the head pointer is initially passed in as a parameter, and then it is updated to point to the next node in the list during each iteration of the while loop. This is a standard approach to traversing a linked list.",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 36,
    "Question Text": "N items are stored in a sorted doubly linked list. For a delete operation, a pointer is provided to the record to be deleted. For a decrease-key operation, a pointer is provided to the record on which the operation is to be performed. An algorithm performs the following operations on the list in this order: \u0398(N) delete, O(log N) insert, O(log N) find, and \u0398(N) decrease-key What is the time complexity of all these operations put together?",
    "Option A": "O(Log2N)",
    "Option B": "O(N)",
    "Option C": "O(N Log N)",
    "Option D": "\u0398(N2 Log N)",
    "Correct Answer": "C",
    "Explanation": "The time complexity of all these operations put together is O(N log N).The delete operation takes \u0398(N) time because we need to traverse the list to find the record to be deleted.The insert and find operations take O(log N) time each because the list is sorted and we can use binary search to locate the correct position for the new record or to find an existing record.The decrease-key operation takes \u0398(N) time because we need to traverse the list to find the record on which the operation is to be performed.Assuming that there are M total operations (M = \u0398(N) + O(log N) + O(log N) + \u0398(N) = O(N)), the total time complexity of all operations is O(M log N) = O(N log N), because the operations take varying amounts of time but they are all performed on a list of size N.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 37,
    "Question Text": "What are the application(s) of linked list?",
    "Option A": "Implementation of stacks and queues.",
    "Option B": "Maintaining a directory of names",
    "Option C": "None of the above",
    "Option D": "Both a and b",
    "Correct Answer": "D",
    "Explanation": "Both a and b are the implementations of linked list.",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 38,
    "Question Text": "The concatenation of two lists is to be performed in O(1) time. Which of the following implementations of a list should be used?",
    "Option A": "singly linked list",
    "Option B": "doubly linked list",
    "Option C": "circular doubly linked list",
    "Option D": "array implementation of lists",
    "Correct Answer": "C",
    "Explanation": "As list concatenation requires traversing at least one list to the end. So singly linked list and doubly linked list requires O(n) time complexity whereas circular doubly linked list required O(1) time.&nbsp;",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 39,
    "Question Text": "Consider the following piece of 'C' code fragment that removes duplicates from an ordered list of integers.\n        C++\n        \n        #include &lt;stdio.h&gt;\n\nNode *remove_duplicates(Node *head, int *j) {\n    Node *t1, *t2;\n    *j = 0;\n    t1 = head;\n    if (t1 != NULL) t2 = t1-&gt;next;\n    else return head;\n    *j = 1;\n    if (t2 == NULL)\n        return head;\n    while (t2 != NULL) {\n        if (t1-&gt;val != t2-&gt;val) { // S1\n            (*j)++; t1-&gt;next = t2; t1 = t2; // S2\n        }\n        t2 = t2-&gt;next;\n    }\n    t1-&gt;next = NULL;\n    return head;\n}\n\n        \n    \n        C\n        \n        #include &lt;stdio.h&gt;\n\nNode  *remove-duplicates(Node *head, int *j)\n{\n    Node *t1, *t2;\n    *j=0;\n    t1 = head;\n    if (t1! = NULL) t2 = t1 \u2192next;\n    else return head;\n    *j = 1;\n    if(t2 == NULL)\n        return head;\n    while t2 != NULL)\n    {\n        if (t1.val != t2.val) --------------------------\u2192 (S1)\n        {\n            (*j)++; t1 -&gt; next = t2; t1 = t2: ----------\u2192 (S2)\n        }\n        t2 = t2 \u2192next;\n    }\n    t1 \u2192next = NULL;\n    return head;\n}\n\n        \n    \n        Java\n        \n        public Node removeDuplicates(Node head, int[] j) {\n    Node t1, t2;\n    j[0] = 0;\n    t1 = head;\n    if (t1 != null) t2 = t1.next;\n    else return head;\n    j[0] = 1;\n    if (t2 == null)\n        return head;\n    while (t2 != null) {\n        if (t1.val != t2.val) { // S1\n            j[0]++; t1.next = t2; t1 = t2; // S2\n        }\n        t2 = t2.next;\n    }\n    t1.next = null;\n    return head;\n}\n\n        \n    \n        Python\n        \n        def remove_duplicates(head, j):\n    t1 = head\n    j[0] = 0\n    if t1 is not None:\n        t2 = t1.next\n    else:\n        return head\n    j[0] = 1\n    if t2 is None:\n        return head\n    while t2 is not None:\n        if t1.val != t2.val:  # S1\n            j[0] += 1         # S2\n            t1.next = t2      # S2\n            t1 = t2           # S2\n        t2 = t2.next\n    t1.next = None\n    return head\n\n        \n    \n        JavaScript\n        \n        function removeDuplicates(head, j) {\n    let t1 = head;\n    j[0] = 0;\n    if (t1 !== null) t2 = t1.next;\n    else return head;\n    j[0] = 1;\n    if (t2 === null)\n        return head;\n    while (t2 !== null) {\n        if (t1.val !== t2.val) { // S1\n            j[0]++; t1.next = t2; t1 = t2; // S2\n        }\n        t2 = t2.next;\n    }\n    t1.next = null;\n    return head;\n}\n\n        \n    Assume the list contains n elements (n\u22652) in the following questions. a). How many times is the comparison in statement S1 made? b). What is the minimum and the maximum number of times statements marked S2 get executed? c). What is the significance of the value in the integer pointed to by j when the function completes?",
    "Option A": "(a). n-1 times, since comparison is pairwise for n elements.(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.(C). j keeps count of distinct nodes in the list.",
    "Option B": "(a). n times, since comparison is pairwise for n elements.(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.(C). j keeps count of distinct nodes in the list.",
    "Option C": "(a). n-1 times, since comparison is pairwise for n elements.(b). maximum : n-1 for all distinct elements, minimum: 1 for all same elements.(C). j keeps count of distinct nodes in the list.",
    "Option D": "None of the above",
    "Correct Answer": "A",
    "Explanation": "(a). n-1 times, since comparison is pairwise for n elements.(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.(C). j keeps count of distinct nodes in the list.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 40,
    "Question Text": "Suppose there are two singly linked lists both of which intersect at some point and become a single linked list. The head or start pointers of both the lists are known, but the intersecting node and lengths of lists are not known. What is worst case time complexity of optimal algorithm to find intersecting node from two intersecting linked lists?",
    "Option A": "\u0398(n*m), where m, n are lengths of given lists",
    "Option B": "\u0398(n^2), where m&gt;n and m, n are lengths of given lists",
    "Option C": "\u0398(m+n), where m, n are lengths of given lists",
    "Option D": "\u0398(min(n, m)), where m, n are lengths of given lists",
    "Correct Answer": "C",
    "Explanation": "This takes \u0398(m+n) time and O(1) space in worst case, where M and N are the total length of the linked lists.Traverse the two linked list to find m and n.Get back to the heads, then traverse |m \u2212 n| nodes on the longer list.Now walk in lock step and compare the nodes until you found the common ones.Option (C) is correct.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 41,
    "Question Text": "A queue is implemented using a non-circular singly linked list. The queue has a head pointer and a tail pointer, as shown in the figure. Let n denote the number of nodes in the queue. Let 'enqueue' be implemented by inserting a new node at the head, and 'dequeue' be implemented by deletion of a node from the tail. Which one of the following is the time complexity of the most time-efficient implementation of 'enqueue' and 'dequeue, respectively, for this data structure?",
    "Option A": "\u0398(1), \u0398(1)",
    "Option B": "\u0398(1), \u0398(n)",
    "Option C": "\u0398(n), \u0398(1)",
    "Option D": "\u0398(n), \u0398(n)",
    "Correct Answer": "B",
    "Explanation": "For Enqueue operation, performs in constant amount of time (i.e., \u0398(1)), because it modifies only two pointers, i.e.,Create a Node P.P--&gt;Data = DataP--&gt;Next = HeadHead = PFor Dequeue operation, we need address of second last node of single linked list to make NULL of its next pointer. Since we can not access its previous node in singly linked list, so need to traverse entire linked list to get second last node of linked list, i.e.,temp = head; While( temp-Next--&gt;Next != NULL){        temp = temp-Next;        }temp--&gt;next = NULL;Tail = temp;Since, we are traversing entire linked for each Dequeue, so time complexity will be \u0398(n). Option (B) is correct.&nbsp;",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 42,
    "Question Text": "In a doubly linked list, the number of pointers affected for an insertion operation will be",
    "Option A": "5",
    "Option B": "0",
    "Option C": "1",
    "Option D": "None of these",
    "Correct Answer": "D",
    "Explanation": "Explanation - Actually , &nbsp;It depends on the position at which the insertion is done .&nbsp;However , there can be at most 3 cases :-1) Insertion at Begin - 3 pointers affected2) Insertion at Middle - 4 pointers affected3) Insertion at End - 3 pointers affected",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 43,
    "Question Text": "Consider an implementation of unsorted single linked list. Suppose it has its representation with a head and a tail pointer (i.e. pointers to the first and last nodes of the linked list). Given the representation, which of the following operation can not be implemented in O(1) time ?",
    "Option A": "Insertion at the front of the linked list.",
    "Option B": "Insertion at the end of the linked list.",
    "Option C": "Deletion of the front node of the linked list.",
    "Option D": "Deletion of the last node of the linked list.",
    "Correct Answer": "D",
    "Explanation": "Deletion of the last node of the linked list, we need address of second last node of single linked list to make NULL of its next pointer. Since we can not access its previous node in singly linked list, so need to traverse entire linked list to get second last node of linked list. So, option (D) is correct.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 44,
    "Question Text": "Consider a single linked list where F and L are pointers to the first and last elements respectively of the linked list. The time for performing which of the given operations depends on the length of the linked list?F-&gt;1-&gt;2-&gt;3-&gt;L",
    "Option A": "Delete the first element of the list",
    "Option B": "Interchange the first two elements of the list",
    "Option C": "Delete the last element of the list",
    "Option D": "Add an element at the end of the list",
    "Correct Answer": "C",
    "Explanation": "If F and L are pointers to the first and last elements respectively of the linked list, then: i) Deleting the first element of the list will not depend on the length of the link list as F = F-&gt;next and delete first node. ii) Interchanging the first two elements of the list will also not require the length of linked list, simply by taking a temp node, swap the two nodes of the list. iii) Deleting the last element of the list will require the length traversal of the list so as to obtain the pointer of the node previous to the last node. iv) Adding an element at the end of the list, can be done by making L-&gt;next = new node So, correct option is (C).",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 45,
    "Question Text": "The following steps in a linked listp = getnode() info (p) = 10 next (p) = list list = presult in which type of operation?",
    "Option A": "pop operation in stack",
    "Option B": "removal of a node",
    "Option C": "inserting a node at beginning&nbsp;",
    "Option D": "modifying an existing node",
    "Correct Answer": "C",
    "Explanation": "The given steps result in the insertion of a new node at the beginning of a linked list.The first step p = getnode() creates a new node p using the getnode() function (assuming it is defined elsewhere).The second step info (p) = 10 sets the info field of the new node p to the value 10.The third step next (p) = list sets the next field of the new node p to the current head of the linked list, which is pointed to by the list pointer.Finally, the fourth step list = p updates the list pointer to point to the newly inserted node p, effectively making it the new head of the linked list.Therefore, this sequence of steps performs an insertion operation at the beginning of the linked list, also known as a push operation.",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 46,
    "Question Text": "In DNA sequence alignment, which string-matching algorithm is commonly used to identify similarities between two DNA sequences efficiently?",
    "Option A": "Rabin-Karp algorithm",
    "Option B": "Knuth-Morris-Pratt algorithm",
    "Option C": "Z function",
    "Option D": "None of the above",
    "Correct Answer": "D",
    "Explanation": "In DNA sequence alignment, other specialized algorithms like the Smith-Waterman algorithm or Needleman-Wunsch algorithm are commonly used instead of the Rabin-Karp algorithm, Knuth-Morris-Pratt algorithm, or Z function.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 47,
    "Question Text": "Which of the following operations is performed more efficiently by doubly linked list than by linear linked list?",
    "Option A": "Deleting a node whose location is given",
    "Option B": "Searching an unsorted list for a given item",
    "Option C": "Inserting a node after the node with a given location",
    "Option D": "Traversing the list to process each node",
    "Correct Answer": "A",
    "Explanation": "Doubly linked lists have a few advantages over linear linked lists when it comes to certain operations. Specifically, the following operation is performed more efficiently by a doubly linked list than by a linear linked listDeleting a node given a pointer to the node.In a linear linked list, deleting a node requires traversing the list to find the node to be deleted and its predecessor. Once these nodes have been found, the predecessor's next pointer is updated to skip over the node to be deleted. This operation takes O(n) time in the worst case, where n is the number of nodes in the list.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 48,
    "Question Text": "The time required to search an element in a linked list of length n is",
    "Option A": "O (log n)",
    "Option B": "O (n)",
    "Option C": "O (1)",
    "Option D": "O (n2)",
    "Correct Answer": "B",
    "Explanation": "In the worst case, the element to be searched has to be compared with all elements of linked list, so the time complexity is O(n). Option (B) is correct.",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 49,
    "Question Text": "The minimum number of fields with each node of doubly linked list is",
    "Option A": "1",
    "Option B": "2",
    "Option C": "3",
    "Option D": "4",
    "Correct Answer": "C",
    "Explanation": "In general, each node of doubly link list always has 3 fields, i.e., the previous node pointer, the data field, and the next node pointer, see - doubly linked list introduction  So, answer should be option (C) 3.  However, each node of doubly linked list can have only 2 fields, i.e., XOR pointer field, and data field. This XOR pointer field can points both previous node and next node, this is the best case with data field. This is called as memory efficient doubly linked list, see - XOR linked list \u2013 a memory efficient doubly linked list | set 1    Also, if we remove data node from the XOR linked list, then each node of this doubly linked list can have only 1 field, i.e., XOR pointer field. But, this is without data field so, this doubly linked list does not make sense.",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 50,
    "Question Text": "A doubly linked list is declared as\n        C++\n        \n        struct Node {\n       int Value;\n       struct Node *Fwd;\n       struct Node *Bwd;\n);\n\n        \n    \n        C\n        \n        // Struct definition in C\nstruct Node {\n    int Value;\n    struct Node *Fwd;\n    struct Node *Bwd;\n};\n\n        \n    \n        Java\n        \n        // Struct definition in Java\nclass Node {\n    int Value;\n    Node Fwd;\n    Node Bwd;\n}\n\n        \n    \n        Python\n        \n        # Class definition in Python\nclass Node:\n    def __init__(self, value):\n        self.Value = value\n        self.Fwd = None\n        self.Bwd = None\n\n        \n    \n        JavaScript\n        \n        // Class definition in JavaScript\nclass Node {\n    constructor(value) {\n        this.Value = value;\n        this.Fwd = null;\n        this.Bwd = null;\n    }\n}\n\n        \n    Where Fwd and Bwd represent forward and backward link to the adjacent elements of the list. Which of the following segments of code deletes the node pointed to by X from the doubly linked list, if it is assumed that X points to neither the first nor the last node of the list?",
    "Option A": "X-&gt;Bwd-&gt;Fwd = X-&gt;Fwd; X-&gt;Fwd-&gt;Bwd = X-&gt;Bwd ;",
    "Option B": "X-&gt;Bwd.Fwd = X-&gt;Fwd ; X.Fwd-&gt;Bwd = X-&gt;Bwd ;",
    "Option C": "X.Bwd-&gt;Fwd = X.Bwd ; X-&gt;Fwd.Bwd = X.Bwd ;",
    "Option D": "X-&gt;Bwd-&gt;Fwd = X-&gt;Bwd ; X-&gt;Fwd-&gt;Bwd = X-&gt;Fwd;",
    "Correct Answer": "A",
    "Explanation": "To delete a node from a doubly linked list, we need to update the links of the previous and next nodes to point to each other, effectively removing the node to be deleted from the list.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 51,
    "Question Text": "Consider a singly linked list of the form where F is a pointer to the first element in the linked list and L is the pointer to the last element in the list. The time of which of the following operations depends on the length of the list?",
    "Option A": "Delete the last element of the list",
    "Option B": "Delete the first element of the list",
    "Option C": "Add an element after the last element of the list",
    "Option D": "Interchange the first two elements of the list",
    "Correct Answer": "A",
    "Explanation": "Interchange the first two elements of the list: To interchange the first two elements of the list, we can simply update the head pointer of the list to point to the second element and update the next pointer of the second element to point to the first element. This can be done in constant time, regardless of the length of the list.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 52,
    "Question Text": "Which of the following sorting algorithms can be used to sort a random linked list with minimum time complexity?",
    "Option A": "Insertion Sort",
    "Option B": "Quick Sort",
    "Option C": "Heap Sort",
    "Option D": "Merge Sort",
    "Correct Answer": "D",
    "Explanation": "Both Merge sort and Insertion sort can be used for linked lists. The slow random-access performance of a linked list makes other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible. Since worst case time complexity of Merge Sort is O(nLogn) and Insertion sort is O(n^2), merge sort is preferred. See following for implementation of merge sort using Linked List.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 53,
    "Question Text": "In the worst case, the number of comparisons needed to search a singly linked list of length n for a given element is",
    "Option A": "log(2*n)",
    "Option B": "n/2",
    "Option C": "log(2*n) -1",
    "Option D": "n",
    "Correct Answer": "D",
    "Explanation": "In the worst case, the given element may not be present in the singly linked list of length n. Therefore, the search algorithm would need to traverse the entire list to determine that the element is not present.Therefore, the number of comparisons needed to search a singly linked list of length n in the worst case is equal to n, which is the length of the list.",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 54,
    "Question Text": "Let P be a singly linked list. Let Q be the pointer to an intermediate node x in the list. What is the worst-case time complexity of the best known algorithm to delete the node Q from the list?",
    "Option A": "O(n)",
    "Option B": "O(log2 n)",
    "Option C": "O(logn)",
    "Option D": "O(1)",
    "Correct Answer": "A",
    "Explanation": "To delete a node Q from a singly linked list, we need to modify the next pointer of the node that precedes Q to point to the node that follows Q. However, in a singly linked list, we cannot traverse the list backwards from a given node, so we need to start from the beginning of the list to find the node that precedes Q.Therefore, the worst-case time complexity of the best known algorithm to delete the node Q from the list is O(n), where n is the length of the list. This is because we may need to traverse the entire list to find the node that precedes Q.However, if we have a pointer to the node that precedes Q, the deletion operation can be performed in O(1) time complexity, since we can simply modify the next pointer of that node to skip over Q. But, if we do not have a pointer to the node that precedes Q, we need to start from the beginning of the list and traverse the list to find it, which takes O(n) time complexity in the worst case.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 55,
    "Question Text": "What is the worst case time complexity of inserting n elements into an empty linked list, if the linked list needs to be maintained in sorted order ?",
    "Option A": "\u0398(n)",
    "Option B": "\u0398(n log n)",
    "Option C": "\u0398(n2)",
    "Option D": "\u0398(1)",
    "Correct Answer": "C",
    "Explanation": "If we want to insert n elements into an empty linked list that needs to be maintained in sorted order, the worst-case time complexity would be O(n^2). This is because we would need to traverse the list for each element we want to insert, to find the correct position for the element in the sorted list.&nbsp;",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 56,
    "Question Text": "Consider the following conditions:&nbsp;(a)The solution must be feasible, i.e. it must satisfy all the supply and demand constraints.&nbsp;(b)The number of positive allocations must be equal to m1n21, where m is the number of rows and n is the number of columns.&nbsp;(c)All the positive allocations must be in independent positions.&nbsp;The initial solution of a transportation problem is said to be non-degenerate basic feasible solution if it satisfies: Codes:",
    "Option A": "(a) and (b) only",
    "Option B": "(a) and (c) only",
    "Option C": "(b) and (c) only",
    "Option D": "(a), (b) and (c)",
    "Correct Answer": "D",
    "Explanation": "The correct answer is (a) and (b) and (c)A basic feasible solution (BFS) satisfies the following conditions:The solution is feasible, i.e., it satisfies all the supply and demand constraints.The number of positive allocations is equal to the number of rows plus the number of columns minus one (m + n - 1).All the positive allocations are in independent positions.A non-degenerate basic feasible solution (NDBFS) is a basic feasible solution that satisfies conditions (a) and (b) above, but also satisfies the additional condition that no three or more variables are simultaneously zero in any nondegenerate square submatrix of the allocation matrix. This condition is used to ensure uniqueness of the solution. However, it is not explicitly mentioned in the given options.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 57,
    "Question Text": "Consider the following statements:i.   First-in-first out types of computations are efficiently supported by STACKS.ii.  Implementing LISTS on linked lists is more efficient than implementing LISTS on an array for almost all the basic LIST operations.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.iv.  Last-in-first-out type of computations are efficiently supported by QUEUES.Which of the following is correct?",
    "Option A": "(ii) is true",
    "Option B": "(i) and (ii) are true",
    "Option C": "(iii) is true",
    "Option D": "(ii) and (iv) are true",
    "Correct Answer": "C",
    "Explanation": "The correct statement is:iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.Explanation:i. STACKS are used to implement Last-in-First-Out (LIFO) operations, not First-in-First-out (FIFO) operations. Therefore, statement i is incorrect.ii. Implementing LISTS on a linked list is more efficient for some operations, such as adding or removing elements in the middle of the list, but it is less efficient for other operations, such as accessing elements by index. Therefore, the statement is incorrect.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices. This is because with a circular array, the front and rear indices wrap around when they reach the end of the array, making it more efficient toenqueue and dequeue elements. Therefore, the statement is correct.iv. QUEUES are used to implement First-in-First-out (FIFO) operations, not Last-in-First-out (LIFO) operations. Therefore, statement iv is incorrect.Hence Option (C) is the correct answer.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 58,
    "Question Text": "Consider the problem of reversing a singly linked list. To take an example, given the linked list below,&nbsp;the reversed linked list should look like&nbsp;Which one of the following statements is TRUE about the time complexity of algorithms that solve the above problem in O(1) space?",
    "Option A": "The best algorithm for the problem takes&nbsp;[Tex]\\theta (n)&nbsp;&nbsp;&nbsp;&nbsp;[/Tex]&nbsp;time in the worst case",
    "Option B": "The best algorithm for the problem takes&nbsp;[Tex]\\theta(nlogn)&nbsp;&nbsp;&nbsp;&nbsp;[/Tex]&nbsp;time in the worst case.&nbsp;",
    "Option C": "The best algorithm for the problem takes&nbsp;[Tex]\\theta(n^{2})&nbsp;&nbsp;&nbsp;&nbsp;[/Tex]&nbsp;time in the worst case",
    "Option D": "It is not possible to reverse a singly linked list in O(1) space.&nbsp;",
    "Correct Answer": "A",
    "Explanation": "Reversing a linked list only requires one traversal of entire linked list of N elements and Change the appropriate Pointers. The Time complexity is&nbsp;\u0398(n).So, option A is the correct answer.&nbsp;",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 59,
    "Question Text": "Consider the queues Q1 containing four elements and Q2 containing none (shown as the Initial State in the figure). The only operations allowed on these two queues are Enqueue(Q, element) and Dequeue(Q). The minimum number of Enqueue operations on Q1 required to place the elements of Q1 in Q2 in reverse order (shown as the Final State in the figure) without using any additional storage is___________.&nbsp;",
    "Option A": "12",
    "Option B": "9",
    "Option C": "4",
    "Option D": "0",
    "Correct Answer": "D",
    "Explanation": "Understanding the Operation usedEnq(Qx, Deq(Qy)) means that we dequeue an element from the queue Qy and enqueue an element into the queue Qx.The operation does not take any extra space as the value returned from one function is immediately passed as an argument to another function. Remember that a function's return value and arguments are stored in the function stack frame, so no extra space is taken, i.e. space to keep this data is included in the function-call/operation itself.Solution StepsThis question can be solved by following the given set of instructions :Step No.OperationState of Queues (after performing the operation)0.-Original State1.Enq(Q2, Deq(Q1))&nbsp;2.Enq(Q2, Deq(Q1))&nbsp;3.Enq(Q2, Deq(Q2))&nbsp;4.Enq(Q2, Deq(Q1))&nbsp;5.Enq(Q2, Deq(Q2))&nbsp;6.&nbsp;Enq(Q2, Deq(Q2))&nbsp;7.Enq(Q2, Deq(Q1))&nbsp;8.Enq(Q2, Deq(Q2))&nbsp;9.Enq(Q2, Deq(Q2))&nbsp;10.Enq(Q2, Deq(Q2))Solution StateThe minimum number of Enqueue operations on Q1 required to place the elements of Q1 in Q2 in reverse order (shown as the Final State in the figure) without using any additional storage is 0.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 60,
    "Question Text": "Find the functionality of the given code-\n        C++\n        \n        void function(int data)\n{\n    int flag = 0;\n    if (head != null) {\n        Node temp = head.getNext();\n        while ((temp != head)\n               &amp;&amp; (!(temp.getItem() == data))) {\n            temp = temp.getNext();\n            flag = 1;\n            break;\n        }\n    }\n    if (flag)\n        System.out.println(&quot;success&quot;);\n    else\n        System.out.println(&quot;fail&quot;);\n}",
    "Option A": "Print success if a particular element is not found",
    "Option B": "Print fail if a particular element is not found",
    "Option C": "Print success if a particular element is equal to 1",
    "Option D": "Print fail if the list is empty",
    "Correct Answer": "D",
    "Explanation": "The function checks if the linked list is empty. If it is, it will print \"fail.\"If the list is not empty, it checks the first node. If the first node's item does not match the data, it will print \"success\" due to the break statement, which is misleading because it suggests a match was found when it wasn't.Therefore, \"Print fail if a particular element is not found\" is not accurate because it only checks the first element and the output can be misleading.So, the most appropriate answer reflecting the functionality of the code is \"Print fail if the list is empty.\"",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 61,
    "Question Text": "What is the time complexity of searching for an element in a circular linked list?",
    "Option A": "O(n)",
    "Option B": "O(nlogn)",
    "Option C": "O(1)",
    "Option D": "O(n2)",
    "Correct Answer": "A",
    "Explanation": "In the worst case, you have to traverse through the entire list of n elements.",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 62,
    "Question Text": "Choose the code snippet which inserts a node to the head of the list?",
    "Option A": "public void insertHead(int data){Node temp = new Node(data);Node cur = head;while(cur.getNext() != head)&nbsp;cur = cur.getNext()if(head == null){&nbsp;head = temp;&nbsp;head.setNext(head);}else{&nbsp;temp.setNext(head);&nbsp;head = temp;&nbsp;cur.setNext(temp);}size++;}&nbsp;",
    "Option B": "public void insertHead(int data){Node temp = new Node(data);while(cur != head)&nbsp;cur = cur.getNext()if(head == null){&nbsp;head = temp;&nbsp;head.setNext(head);}else{&nbsp;temp.setNext(head.getNext());&nbsp;cur.setNext(temp);}size++;}",
    "Option C": "public void insertHead(int data){Node temp = new Node(data);if(head == null){&nbsp;head = temp;&nbsp;head.setNext(head);}else{&nbsp;temp.setNext(head.getNext());&nbsp;head = temp;}size++;}",
    "Option D": "public void insertHead(int data){Node temp = new Node(data);if(head == null){&nbsp;head = temp;&nbsp;head.setNext(head.getNext());}else{&nbsp;temp.setNext(head.getNext());&nbsp;head = temp;}size++;}",
    "Correct Answer": "A",
    "Explanation": "If the list is empty make the new node as \u2018head\u2019, otherwise traverse the list to the end and make its \u2018next\u2019 pointer point to the new node, set the new node\u2019s next point to the current head and make the new node as the head.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 63,
    "Question Text": "What is the functionality of the following code? Choose the most appropriate answer.\n        C++\n        \n        int function()\n{\n    if (head == null)\n        return Integer.MIN_VALUE;\n    int var;\n    Node temp = head;\n    while (temp.getNext() != head)\n        temp = temp.getNext();\n    if (temp == head) {\n        var = head.getItem();\n        head = null;\n        return var;\n    }\n    temp.setNext(head.getNext());\n    var = head.getItem();\n    head = head.getNext();\n    return var;\n}",
    "Option A": "Return data from the end of the list",
    "Option B": "Returns the data and deletes the node at the end of the list",
    "Option C": "Returns the data from the beginning of the list",
    "Option D": "Returns the data and deletes the node from the beginning of the list",
    "Correct Answer": "D",
    "Explanation": "First traverse through the list to find the end node, then manipulate the \u2018next\u2019 pointer such that it points to the current head\u2019s next node, returns the data stored in the head and make this next node as the head.Hence Option(D) is the correct answer.",
    "Concept": "Linked List",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 64,
    "Question Text": "Consider a small circular linked list. How to detect the presence of cycles in this list effectively?",
    "Option A": "Keep one node as head and traverse another temp node till the end to check if its \u2018next points to head",
    "Option B": "Have fast and slow pointers with the fast pointer advancing two nodes at a time and slow pointer advancing by one node at a time",
    "Option C": "Cannot determine, you have to pre-define if the list contains cycles",
    "Option D": "Circular linked list itself represents a cycle. So no new cycles cannot be generated",
    "Correct Answer": "B",
    "Explanation": "Advance the pointers in such a way that the fast pointer advances two nodes at a time and slow pointer advances one node at a time and check to see if at any given instant of time if the fast pointer points to slow pointer or if the fast pointer\u2019s \u2018next\u2019 points to the slow pointer. This is applicable for smaller lists.Below is the implementation of the above approach: bool isCircular() {        if (head == nullptr) {            return false;        }        Node* slow = head;        Node* fast = head-&gt;next;        while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) {            if (slow == fast) {                return true;            }            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        }        return false;    }Hence (B) is the correct answer.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 65,
    "Question Text": "Which of the following application makes use of a circular linked list?",
    "Option A": "Undo Operation",
    "Option B": "Recursive function calls",
    "Option C": "Allocating CPU to resources",
    "Option D": "Implement Hash Tables",
    "Correct Answer": "C",
    "Explanation": "Applications of circular linked lists:Multiplayer games use this to give each player a chance to play.A circular linked list can be used to organize multiple running applications on an operating system. These applications are iterated over by the OS.Circular linked lists can be used in resource allocation problems.Circular linked lists are commonly used to implement circular buffers,Circular linked lists can be used in simulation and gaming.Hence Option (C) is the correct answer.&nbsp;",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 66,
    "Question Text": "In a circular linked list, How many nodes are containing NULL as the address?",
    "Option A": "Only one node",
    "Option B": "Only Two node",
    "Option C": "Every Node",
    "Option D": "No, any node",
    "Correct Answer": "D",
    "Explanation": "In a circular linked list, there is no any node containing NULL as their address.Circular linked listFollowing are some properties of the circular linked list:&nbsp;A node always points to another node, so NULL assignment is not necessary.Any node can be set as the starting point.Nodes are traversed quickly from the first to the last.Hence Option(D) is the correct answer.",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 67,
    "Question Text": "What is the time complexity to insert a node at the beginning of the list?",
    "Option A": "O(LogN)",
    "Option B": "O(N)",
    "Option C": "O(1)",
    "Option D": "",
    "Correct Answer": "C",
    "Explanation": "To insert a node at the beginning of the Circular linked list, there is no need to traverse the list so it takes constant time.To insert a node at the beginning of the list, follow these steps:&nbsp;Create a node, say T.&nbsp;Make T -&gt; next = last -&gt; next.&nbsp;last -&gt; next = T.&nbsp;Circular linked listAnd then,&nbsp;Circular linked listHence Option(A) is the correct answer.",
    "Concept": "Linked List",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 68,
    "Question Text": "Consider the below program, and identify which Operation is performed.\n        C++\n        \n        int solve(struct Node* head)\n{\n    if (head == NULL)\n        return 1;\n    struct Node* ptr;\n    ptr = head-&gt;next;\n    while (ptr != NULL &amp;&amp; ptr != head)\n        ptr = ptr-&gt;next;\n    return (ptr == head);\n}",
    "Option A": "Checking for List is empty of not",
    "Option B": "Checking for the list is Circular or not",
    "Option C": "count the number of elements in the list",
    "Option D": "",
    "Correct Answer": "B",
    "Explanation": "In the above program, we are just checking whether the linked list is circular or not. The idea is to store the head of the linked list and traverse it. If the iterator reaches NULL, the linked list is not circular. else If it reaches the head again, then the linked list is circular.&nbsp;A linked list is called circular if it is not NULL-terminated and all nodes are connected in the form of a cycle. Below is an example of a circular linked list.&nbsp;Hence (B) is the correct answer.",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 69,
    "Question Text": "Which of the following Statement is correct about Circular Linked List?P1: Every Node has a successor.P2: TIme complexity for deleting the first node is O(N).P3: Last Node points to the NULL.P4: Every Node contains the data and a next pointer to traverse the list.",
    "Option A": "Only P4",
    "Option B": "Only P1",
    "Option C": "P1 and P2",
    "Option D": "P1 and P4.",
    "Correct Answer": "D",
    "Explanation": "In the above statement, P1 and P4 are correct about the linked list.P1: &nbsp;Every Node has a successor node in a circular form.P2: TIme complexity for deleting the first node is O(N). this statement is incorrect because deleting the first node will take O(1) time.P3:Last Node points to the NULL. this statement is also incorrect because the last node points to the first node in a circular linked list.P4: Every Node contains the data and a next pointer to traverse the list., this statement is also correct.Therefore, P1 and P4 are the correct statements.Hence (D) is the correct answer.&nbsp;",
    "Concept": "Linked List",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 70,
    "Question Text": "Following is a pseudo code of a function that takes a number as an argument, and uses a stack S to do processing.  \n        Python\n        \n        def fun(n):\n    S = []  # Say it creates an empty stack S\n    while n &gt; 0:\n        # This line pushes the value of n%2 to stack S\n        S.append(n % 2)\n        n = n // 2\n\n    # Run while Stack S is not empty\n    while S:\n        print(S.pop(), end=&#39; &#39;)  # pop an element from S and print it\n\n        \n    What does the above function do in general?",
    "Option A": "Prints binary representation of n in reverse order",
    "Option B": "Prints binary representation of n",
    "Option C": "Prints the value of Logn",
    "Option D": "Prints the value of Logn in reverse order",
    "Correct Answer": "B",
    "Explanation": "The given code is recursive method to print binary representation of \u2018NUM\u2019.&nbsp;step 1) if NUM &gt; 1    a) push NUM on stack    b) recursively call function with 'NUM / 2'step 2)    a) pop NUM from stack, divide it by 2 and print it's remainder.Read in Detail :  Binary representation of a number for explanation.",
    "Concept": "Stack",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 71,
    "Question Text": "Consider the following pseudocode that uses a stack&nbsp;\n        Python\n        \n        # Declare a stack of characters\nword = &quot;example&quot;  # Replace with the word you want to read\nchar_stack = []\n\n# While there are more characters in the word to read\nfor c in word:\n    char_stack.append(c)  # Push the character on the stack\n\n# While the stack is not empty\nwhile char_stack:\n    c = char_stack.pop()  # Pop a character off the stack\n    print(c, end=&#39;&#39;)  # Write the character to the screen\n\n        \n    What is output for input \"geeksquiz\"?",
    "Option A": "geeksquizgeeksquiz",
    "Option B": "ziuqskeeg",
    "Option C": "geeksquiz",
    "Option D": "ziuqskeegziuqskeeg",
    "Correct Answer": "B",
    "Explanation": "Since the stack data structure follows LIFO order. When we pop() items from stack, they are popped in reverse order of their insertion (or push())",
    "Concept": "Stack",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 72,
    "Question Text": "Following is an incorrect pseudocode for the algorithm which is supposed to determine whether a sequence of parentheses is balanced:&nbsp;\n\n\n        C\n        \n           declare a character stack \n   while ( more input is available)\n   {\n      read a character\n      if ( the character is a &#39;(&#39; ) \n         push it on the stack\n      else if ( the character is a &#39;)&#39; and the stack is not empty )\n         pop a character off the stack\n      else\n         print &quot;unbalanced&quot; and exit\n    }\n    print &quot;balanced&quot;\n\n        \n    \n\nWhich of these unbalanced sequences does the above code think is balanced?&nbsp;",
    "Option A": "((())",
    "Option B": "())(()",
    "Option C": "(()()))",
    "Option D": "(()))()",
    "Correct Answer": "B",
    "Explanation": "At the end of while loop, we must check whether the stack is empty or not. For input ((()), the stack doesn't remain empty after the loop. See http://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/ for details.",
    "Concept": "Stack",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 73,
    "Question Text": "The following postfix expression with single digit operands is evaluated using a stack:8 2 3 ^ / 2 3 * + 5 1 * -  Note that ^ is the exponentiation operator. The top two elements of the stack after the first * is evaluated are:",
    "Option A": "6, 1",
    "Option B": "5, 7",
    "Option C": "3, 2",
    "Option D": "1, 5",
    "Correct Answer": "A",
    "Explanation": "The algorithm for evaluating any postfix expression is fairly straightforward: 1. While there are input tokens left    o Read the next token from input.    o If the token is a value       + Push it onto the stack.    o Otherwise, the token is an operator       (operator here includes both operators, and functions).       * It is known a priori that the operator takes n arguments.       * If there are fewer than n values on the stack        (Error) The user has not input sufficient values in the expression.       * Else, Pop the top n values from the stack.       * Evaluate the operator, with the values as arguments.       * Push the returned results, if any, back onto the stack.2. If there is only one value in the stack    o That value is the result of the calculation.3. If there are more values in the stack    o (Error)  The user input has too many values. Source for algorithm:&nbsp;http://en.wikipedia.org/wiki/Reverse_Polish_notation#The_postfix_algorithm  Let us run the above algorithm for the given expression. First three tokens are values, so they are simply pushed. After pushing 8, 2 and 3, the stack is as follows     8, 2, 3 When ^ is read, top two are popped and power(2^3) is calculated     8, 8 When / is read, top two are popped and division(8/8) is performed     1 Next two tokens are values, so they are simply pushed. After pushing 2 and 3, the stack is as follows     1, 2, 3 When * comes, top two are popped and multiplication is performed.     1, 6",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 74,
    "Question Text": "Let S be a stack of size n &gt;= 1. Starting with the empty stack, suppose we push the first n natural numbers in sequence, and then perform n pop operations. Assume that Push and Pop operation take X seconds each, and Y seconds elapse between the end of one such stack operation and the start of the next operation. For m &gt;= 1, define the stack-life of m as the time elapsed from the end of Push(m) to the start of the pop operation that removes m from S. The average stack-life of an element of this stack is",
    "Option A": "n(X+ Y)",
    "Option B": "3Y + 2X",
    "Option C": "n(X + Y)-X",
    "Option D": "Y + 2X",
    "Correct Answer": "C",
    "Explanation": "Example: Let's n = 31  ( Pushed in Stack ) : Time take = X 2  ( Pushed in Stack ) : Time take = X 3  ( Pushed in Stack ) : Time take = X 3  ( Popped Out of Stack ) : Time take = X 2  ( Popped Out of Stack ) : Time take = X 1   ( Popped Out of Stack ) : Time take = X Stack Life of 3 = yStack Life of 2 = 3(x + y ) - xStack Life of 1 =  5(x + y ) - xAverage Stack Lifge of Element = ( Y + (3(X + Y ) - X ) + (5(X + Y ) - X) ) /3 = ( 6X + 9Y )/3 = 2X + 3YFor n= 3 the average stack life is 2X +3YSimiliarly for n elements, the average stack life will be n( X + Y ) -Y",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 75,
    "Question Text": "A single array A[1..MAXSIZE] is used to implement two stacks. The two stacks grow from opposite ends of the array. Variables top1 and top2 (topl&lt; top 2) point to the location of the topmost element in each of the stacks. If the space is to be used efficiently, the condition for \u201cstack full\u201d is:",
    "Option A": "(top1 = MAXSIZE/2) and (top2 = MAXSIZE/2+1)",
    "Option B": "top1 + top2 + 1 = MAXSIZE",
    "Option C": "(top1= MAXSIZE/2) or (top2 = MAXSIZE)",
    "Option D": "top1= top2 -1",
    "Correct Answer": "D",
    "Explanation": "If we are to use space efficiently then size of the any stack can be more than MAXSIZE/2.   Both stacks will grow from both ends and if any of the stack top reaches near to the other top then stacks are full. So the condition will be top1 = top2 -1 (given that top1 &lt; top2)",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 76,
    "Question Text": "Assume that the operators +, -, \u00d7 are left associative and ^ is right associative. The order of precedence (from highest to lowest) is ^, x , +, -. The postfix expression corresponding to the infix expression a + b \u00d7 c - d ^ e ^ f is",
    "Option A": "abc \u00d7 + def ^ ^ -",
    "Option B": "abc \u00d7 + de ^ f ^ -",
    "Option C": "ab + c \u00d7 d - e ^ f ^",
    "Option D": "- + a \u00d7 bc ^ ^ def",
    "Correct Answer": "B",
    "Explanation": "Start scanning from left to right.Use a stack to keep track of operators.If the scanned symbol is an operand (in this case, 'a', 'b', 'c', 'd', 'e', 'f'), append it to the postfix expression.If the scanned symbol is an operator, pop and output all operators from the stack which have equal or higher precedence than the current operator. Then push the current operator onto the stack.If the scanned symbol is an opening parenthesis '(', push it onto the stack.If the scanned symbol is a closing parenthesis ')', pop and output operators from the stack until an opening parenthesis '(' is encountered. Pop '(' from the stack (but don't output it).Repeat steps 3-6 until all symbols are scanned.Given the infix expression a + b \u00d7 c - d ^ e ^ f, the corresponding postfix expression is:a b c x + d e f ^ ^ -",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 77,
    "Question Text": "To evaluate an expression without any embedded function calls :&nbsp;",
    "Option A": "As many stacks as the height of the expression tree are needed",
    "Option B": "One stack is enough",
    "Option C": "Two stacks are needed",
    "Option D": "A Turing machine is needed in the general case",
    "Correct Answer": "C",
    "Explanation": "Any expression can be converted into Postfix or Prefix form.&nbsp;Prefix and postfix evaluation can be done using a single stack.&nbsp;For example : Expression '10 2 8 * + 3 -' is given.&nbsp;PUSH 10 in the stack.&nbsp;PUSH 2 in the stack.&nbsp;PUSH 8 in the stack.&nbsp;When operator '*' occurs, POP 2 and 8 from the stack.&nbsp;PUSH 2 * 8 = 16 in the stack.&nbsp;When operator '+' occurs, POP 16 and 10 from the stack.&nbsp;PUSH 10 * 16 = 26 in the stack.&nbsp;PUSH 3 in the stack.&nbsp;When operator '-' occurs, POP 26 and 3 from the stack.&nbsp;PUSH 26 - 3 = 23 in the stack.&nbsp;So, 23 is the answer obtained using single stack.&nbsp;Thus, option (B) is correct.&nbsp;",
    "Concept": "Stack",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 78,
    "Question Text": "The result evaluating the postfix expression 10 5 + 60 6 / * 8 \u2013  is",
    "Option A": "284",
    "Option B": "213",
    "Option C": "142",
    "Option D": "71",
    "Correct Answer": "C",
    "Explanation": "Step 1: Postfix Expression Evaluation RulesOperands (numbers) are pushed onto a stack.When an operator is encountered, the required number of operands is popped from the stack, the operation is performed, and the result is pushed back onto the stack.Step 2: Evaluate the ExpressionLet's evaluate step by step:Expression: 10\u20095\u2009+\u200960\u20096\u2009/\u2009\u2217\u20098\u2009\u2212Push 10: Stack = [10]Push 5: Stack = [10, 5]Encounter +: Pop 10 and 5, add them: 10+5 = 15. Push result back: Stack=[15]Push 60: Stack = [15, 60]Push 6: Stack = [15, 60, 6]Encounter /: Pop 60 and 6, divide them: 60/6=10. Push result back: Stack = [15,10]Encounter *: Pop 15 and 10, multiply them: 15\u00d710=150. Push result back: Stack=[150]Push 8: Stack = [150, 8]Encounter -: Pop 150 and 8, subtract them: 150\u22128=142. Push result back: Stack=[142].Step 3: The final result in the stack is: 142",
    "Concept": "Stack",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 79,
    "Question Text": "A function f defined on stacks of integers satisfies the following properties. f(\u2205) = 0 and f (push (S, i)) = max (f(S), 0) + i for all stacks S and integers i. If a stack S contains the integers 2, -3, 2, -1, 2 in order from bottom to top, what is f(S)?",
    "Option A": "6",
    "Option B": "4",
    "Option C": "3",
    "Option D": "2",
    "Correct Answer": "D",
    "Explanation": "Since a stack follows LIFO (Last In, First Out), we process elements from top to bottom:Stack (Top to Bottom): [2, -1, 2, -3, 2]Start with f(\u2205) = 0Push 2: f = 2Push -1: f = 2 - 1 = 1Push 2: f = 1 + 2 = 3Push -3: f = 3 - 3 = 0Push 2: f = 0 + 2 = 2Final result: 2",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 80,
    "Question Text": "Consider the following program:  \n        C++\n        \n        #include &lt;iostream&gt;\n#include &lt;cctype&gt;\n#include &lt;stack&gt;\n\n#define EOF -1\n\nstd::stack&lt;int&gt; s;\n\nvoid push(int value) { s.push(value); } /* push the argument on the stack */\nint pop(void) { if (s.empty()) return EOF; int value = s.top(); s.pop(); return value; }  /* pop the top of the stack */\nvoid flagError() { std::cerr &lt;&lt; &quot;Error!&quot; &lt;&lt; std::endl; exit(1); }\n\nint main() {\n    int c, m, n, r;\n    while ((c = std::cin.get()) != EOF) {\n        if (isdigit(c))\n            push(c - &#39;0&#39;);\n        else if ((c == &#39;+&#39;) || (c == &#39;*&#39;)) {\n            m = pop();\n            n = pop();\n            r = (c == &#39;+&#39;) ? n + m : n * m;\n            push(r);\n        } else if (c != &#39; &#39;)\n            flagError();\n    }\n    std::cout &lt;&lt; pop() &lt;&lt; std::endl;\n}\n\n        \n    \n        C\n        \n        #include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;ctype.h&gt;\n\n#define EOF -1\n\n#define MAX_STACK_SIZE 100\nint s[MAX_STACK_SIZE];\nint top = -1;\n\nvoid push(int value) { if (top &lt; MAX_STACK_SIZE - 1) s[++top] = value; } /* push the argument on the stack */\nint pop(void) { if (top == -1) return EOF; return s[top--]; }  /* pop the top of the stack */\nvoid flagError() { fprintf(stderr, &quot;Error!\\n&quot;); exit(1); }\n\nint main() {\n    int c, m, n, r;\n    while ((c = getchar()) != EOF) {\n        if (isdigit(c))\n            push(c - &#39;0&#39;);\n        else if ((c == &#39;+&#39;) || (c == &#39;*&#39;)) {\n            m = pop();\n            n = pop();\n            r = (c == &#39;+&#39;) ? n + m : n * m;\n            push(r);\n        } else if (c != &#39; &#39;)\n            flagError();\n    }\n    printf(&quot;%d\\n&quot;, pop());\n}\n\n        \n    \n        Java\n        \n        import java.util.*;\n\npublic class Main {\n    static Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n\n    static void push(int value) { stack.push(value); } /* push the argument on the stack */\n    static int pop() { return stack.isEmpty() ? -1 : stack.pop(); }  /* pop the top of the stack */\n    static void flagError() { System.err.println(&quot;Error!&quot;); System.exit(1); }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int c, m, n, r;\n        while ((c = scanner.next().charAt(0)) != -1) {\n            if (Character.isDigit(c))\n                push(c - &#39;0&#39;);\n            else if (c == &#39;+&#39; || c == &#39;*&#39;) {\n                m = pop();\n                n = pop();\n                r = (c == &#39;+&#39;) ? n + m : n * m;\n                push(r);\n            } else if (c != &#39; &#39;)\n                flagError();\n        }\n        System.out.println(pop());\n    }\n}\n\n        \n    \n        Python\n        \n        class Stack:\n    def __init__(self):\n        self.items = []\n    def push(self, item):\n        self.items.append(item)  # push the argument on the stack\n    def pop(self):\n        return self.items.pop() if self.items else -1  # pop the top of the stack\n\ndef flagError():\n    print(&quot;Error!&quot;)\n    exit(1)\n\ns = Stack()\n\nwhile True:\n    try:\n        c = input()\n        if c == &#39;&#39;:\n            break\n        c = ord(c)\n        if c &gt;= ord(&#39;0&#39;) and c &lt;= ord(&#39;9&#39;):\n            s.push(c - ord(&#39;0&#39;))\n        elif c == ord(&#39;+&#39;) or c == ord(&#39;*&#39;):\n            m = s.pop()\n            n = s.pop()\n            r = n + m if c == ord(&#39;+&#39;) else n * m\n            s.push(r)\n        elif c != ord(&#39; &#39;):\n            flagError()\n    except EOFError:\n        break\nprint(s.pop())\n\n        \n    \n        JavaScript\n        \n        class Stack {\n    constructor() {\n        this.items = [];\n    }\n    push(item) { this.items.push(item); } /* push the argument on the stack */\n    pop() { return this.items.length === 0 ? -1 : this.items.pop(); }  /* pop the top of the stack */\n}\n\nfunction flagError() { console.error(&#39;Error!&#39;); process.exit(1); }\n\nconst stack = new Stack();\n\nprocess.stdin.on(&#39;data&#39;, function (data) {\n    const input = data.toString();\n    for (let c of input) {\n        if (!isNaN(c)) {\n            stack.push(parseInt(c));\n        } else if (c === &#39;+&#39; || c === &#39;*&#39;) {\n            const m = stack.pop();\n            const n = stack.pop();\n            const r = (c === &#39;+&#39;) ? n + m : n * m;\n            stack.push(r);\n        } else if (c !== &#39; &#39;) {\n            flagError();\n        }\n    }\n});\n\nprocess.stdin.on(&#39;end&#39;, function () {\n    console.log(stack.pop());\n});\n\n        \n    What is the output of the program for the following input ? 5 2 * 3 3 2 + * +",
    "Option A": "15",
    "Option B": "25",
    "Option C": "30",
    "Option D": "150",
    "Correct Answer": "B",
    "Explanation": "&nbsp;The function of the program is:-1) If the current character is a digit it pushes into stack2) Else if the current character is operator,&nbsp; it pops two elements and then performs the operation.Finally it pushes the resultant element into stack.Initially stack s is empty. 5 2 * 3 3 2 + * + 1) 5 -&gt; It pushes into s 2) 2 -&gt; It pushes into s 3) * -&gt; It pops two elements n = 2, m=5 n*m = 10 It pushes 10 into s4) 3 -&gt; It pushes into s 5) 3 -&gt; It pushes into s6) 2 -&gt; It pushes into s7) + -&gt; n=2, m=3 n+m=5 It pushes 5 into s8) * -&gt; n=5, m=3 n*m=15 It pushes 15 into s 9) + -&gt; n=15, m=10 n+m = 25 It pushes 25 into s.Result = 25",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 81,
    "Question Text": "Suppose a stack is to be implemented with a linked list instead of an array. What would be the effect on the time complexity of the push and pop operations of the stack implemented using linked list (Assuming stack is implemented efficiently)?",
    "Option A": "O(1) for insertion and O(n) for deletion",
    "Option B": "O(1) for insertion and O(1) for deletion",
    "Option C": "O(n) for insertion and O(1) for deletion",
    "Option D": "O(n) for insertion and O(n) for deletion",
    "Correct Answer": "C",
    "Explanation": "Stack can be implemented using link list having O(1) bounds for both insertion as well as deletion by inserting and deleting the element from the beginning of the list.",
    "Concept": "Stack",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 82,
    "Question Text": "Consider n elements that are equally distributed in k stacks. In each stack, elements of it are arranged in ascending order (min is at the top in each of the stack and then increasing downwards). \r\n\r\nGiven a queue of size n in which we have to put all n elements in increasing order. What will be the time complexity of the best known algorithm?",
    "Option A": "O(n logk)",
    "Option B": "O(nk)",
    "Option C": "O(n2)",
    "Option D": "O(k2)",
    "Correct Answer": "B",
    "Explanation": "In nlogk it can be done by creating a min heap of size k and adding all the top - elements of all the stacks. After extracting the min , add the next element from the stack from which we have got our 1st minimum.\r\nTime Complexity = O(k) (For Creating Heap of size k) + (n-k)log k (Insertions into the heap).",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 83,
    "Question Text": "A priority queue Q is used to implement a stack S that stores characters. PUSH(C) is implemented as INSERT(Q, C, K) where K is an appropriate integer key chosen by the implementation. POP is implemented as DELETEMIN(Q). For a sequence of operations, the keys chosen are in",
    "Option A": "Non-increasing order",
    "Option B": "Non-decreasing order",
    "Option C": "strictly increasing order",
    "Option D": "strictly decreasing order",
    "Correct Answer": "E",
    "Explanation": "We are implementing a STACK using Priority Queue. Note that Stack implementation is always last in first out (LIFO) order. As given \"POP is implemented as DELETEMIN(Q)\" that means Stack returns minimum element always. So, we need to implement PUSH(C) using INSERT(Q, C, K) where K is key chosen from strictly-decreasing order(only this order will ensure stack will return minimum element when we POP an element). That will satisfy Last In First Out (LIFO) property of stack. That is answer, option (D) is true. Option (A) non-increasing order can not be true because two same (identical) numbers can not have same priority as priority should be distinguishable for each number.",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 84,
    "Question Text": "Which of the following permutation can be obtained in the same order using a stack assuming that input is the sequence 5, 6, 7, 8, 9 in that order?",
    "Option A": "7, 8, 9, 5, 6",
    "Option B": "5, 9, 6, 7, 8",
    "Option C": "7, 8, 9, 6, 5",
    "Option D": "9, 8, 7, 5, 6",
    "Correct Answer": "D",
    "Explanation": "The sequence given in option (C) is one of the only possible sequence which can be obtained.\r\nWe can obtain the sequence by performing operations in the manner:\r\nPush 5\r\nPush 6\r\nPush 7\r\nPop 7\r\nPush 8\r\nPop 8\r\nPush 9\r\nPop 9\r\nPop 6\r\nPop 5.\r\nhence the sequence will be 7,8,9,6,5.",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 85,
    "Question Text": "The best data structure to check whether an arithmetic expression has balanced parenthesis is a",
    "Option A": "Queue",
    "Option B": "Stack",
    "Option C": "Tree",
    "Option D": "List",
    "Correct Answer": "C",
    "Explanation": "Stacks can check equal pair/ balanced pair of parenthesis efficiently. Whenever we get an opening parenthesis we can push it on the stack and when we get the corresponding closing parenthesis, we can pop it. After performing all push and pop operations, if at the end of the expression stack becomes empty then the expression has a balanced parenthesis.",
    "Concept": "Stack",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 86,
    "Question Text": "The seven elements A, B, C, D, E, F and G are pushed onto a stack in reverse order, i.e., starting from G. The stack is popped five times and each element is inserted into a queue.Two elements are deleted from the queue and pushed back onto the stack. Now, one element is popped from the stack. The popped item is ________.",
    "Option A": "A",
    "Option B": "B",
    "Option C": "F",
    "Option D": "G",
    "Correct Answer": "C",
    "Explanation": "In fig:-1 elements are inserted into a stack then in fig:-2 top 5 elements are popped and these 5 elements are inserted into a queue which is shown in fig:-3, now first two elements are deleted from queue and pushed into stack one by one which is shown in fig:-5.\r\nAt top of the stack element B is presented.\r\nSo, option (B) is correct.",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 87,
    "Question Text": "If the sequence of operations - push (1), push (2), pop, push (1), push (2), pop, pop, pop, push (2), pop are performed on a stack, the sequence of popped out values",
    "Option A": "2,2,1,1,2",
    "Option B": "2,2,1,2,2",
    "Option C": "2,1,2,2,1",
    "Option D": "2,1,2,2,2",
    "Correct Answer": "B",
    "Explanation": "Let's simulate the sequence of operations on a stack:Push(1): Stack = [1]Push(2): Stack = [1, 2]Pop: Pop 2, Stack = [1]Push(1): Stack = [1, 1]Push(2): Stack = [1, 1, 2]Pop: Pop 2, Stack = [1, 1]Pop: Pop 1, Stack = [1]Pop: Pop 1, Stack = []Push(2): Stack = [2]Pop: Pop 2, Stack = []The sequence of popped out values is: 2, 2, 1, 1, 2.",
    "Concept": "Stack",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 88,
    "Question Text": "The five items: A, B, C, D, and E are pushed in a stack, one after other starting from A. The stack is popped four items and each element is inserted in a queue. The two elements are deleted from the queue and pushed back on the stack. Now one item is popped from the stack. The popped item is",
    "Option A": "A",
    "Option B": "B",
    "Option C": "C",
    "Option D": "D",
    "Correct Answer": "E",
    "Explanation": "When five items: A, B, C, D, and E are pushed in a stack: Order of stack becomes: A, B, C, D, and E (A at the bottom and E at the top.) stack is popped four items and each element is inserted in a queue: Order of queue: B, C, D, E (B at rear and E at the front) Order of stack after pop operations = A. Two elements deleted from the queue and pushed back on the stack: New order of stack = A, E, D(A at the bottom, D at the top) As D is on the top so when pop operation occurs D will be popped out. So, correct option is (D).",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 89,
    "Question Text": "Consider the following operations performed on a stack of size 5 : Push (a); Pop() ; Push(b); Push(c); Pop(); Push(d); Pop();Pop(); Push (e) Which of the following statements is correct?",
    "Option A": "Underflow occurs",
    "Option B": "Stack operations are performed smoothly",
    "Option C": "Overflow occurs",
    "Option D": "None of the above",
    "Correct Answer": "C",
    "Explanation": "All Stack operations are performed smoothly. So, option (B) is correct.",
    "Concept": "Stack",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 90,
    "Question Text": "Which of the following is not an inherent application of stack?",
    "Option A": "Implementation of recursion",
    "Option B": "Evaluation of a postfix expression",
    "Option C": "Job scheduling",
    "Option D": "Reverse a string",
    "Correct Answer": "D",
    "Explanation": "We can use stack for string reversal, evaluation of postfix expression and most important is implementation of recursion but job scheduling is not done by stack. So, option (C) is correct.",
    "Concept": "Stack",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 91,
    "Question Text": "Convert the following infix expression into its equivalent post fix expression (A + B^ D) / (E \u2013 F) + G",
    "Option A": "ABD^ + EF \u2013 / G+",
    "Option B": "ABD + ^EF \u2013 / G+",
    "Option C": "ABD + ^EF / \u2013 G+",
    "Option D": "ABD^ + EF / \u2013 G+",
    "Correct Answer": "B",
    "Explanation": "(A + B^ D) / (E \u2013 F) + G\r\n= (A + B^ D)(E \u2013 F)/ + G\r\n=  (A + B^ D)(E \u2013 F)/G+\r\n= A + BD^(E \u2013 F)/G+\r\n= ABD^+EF-/G+\r\nSo, option (A) is correct.",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 92,
    "Question Text": "Consider the following sequence of operations on an empty stack.Push(54);push(52);pop();push(55);push(62);s=pop(); Consider the following sequence of operations on an empty queue.enqueue(21);enqueue(24);dequeue();enqueue(28);enqueue(32);q=dequeue(); The value of s+q is ___________.",
    "Option A": "86",
    "Option B": "68",
    "Option C": "24",
    "Option D": "94",
    "Correct Answer": "A",
    "Explanation": "Let's construct an empty stack and do the operations. Stack follows LIFO order. Push(54) // (54) Push(52) // (54,52) Pop() // (54) Push(55) //(54,55) Push(62) //(54,55,62) s=pop() // (54,55) s=62Let's construct an empty queue and do the operations. Queue follows FIFO order. Enqueue(21) // [21] Enqueue(24) // [21,24] Dequeue() // [24] Enqueue(28) // [24,28] Enqueue(32) // [24,28,32] q=Dequeue() // [28,32] q=24; s+q=62+24 So, s+q=86 .&nbsp; Alternative Way : Stack is last in first out data structure, so s = pop() = 62 Queue is first in first out data structure, so q = dequeue() = 24 Therefore, s+q = 62+24 = 86.",
    "Concept": "Stack",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 93,
    "Question Text": "Which of the following is true about linked list implementation of stack?",
    "Option A": "In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end.",
    "Option B": "In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from the beginning.",
    "Option C": "Both of the above",
    "Option D": "None of the above",
    "Correct Answer": "E",
    "Explanation": "To keep the Last In First Out order, a stack can be implemented using linked list in two ways:\r\n\r\na) In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from beginning.\r\n\r\nb) In push operation, if new nodes are inserted at the end of linked list, then in pop operation, nodes must be removed from end.",
    "Concept": "Stack",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 94,
    "Question Text": "Which one of the following is an application of Stack Data Structure?",
    "Option A": "Managing function calls",
    "Option B": "The stock span problem",
    "Option C": "Arithmetic expression evaluation",
    "Option D": "All of the above",
    "Correct Answer": "E",
    "Explanation": "See http://en.wikipedia.org/wiki/Stack_(abstract_data_type)#Applications",
    "Concept": "Stack",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 95,
    "Question Text": "The five items: A, B, C, D, and E are pushed in a stack, one after other starting from A. The stack is popped four items and each element is inserted in a queue. The two elements are deleted from the queue and pushed back on the stack. Now one item is popped from the stack. The popped item is",
    "Option A": "A",
    "Option B": "B",
    "Option C": "C",
    "Option D": "D",
    "Correct Answer": "E",
    "Explanation": "When five items: A, B, C, D, and E are pushed in a stack: Order of stack becomes: A, B, C, D, and E (A at the bottom and E at the top.) stack is popped four items and each element is inserted in a queue: Order of queue: B, C, D, E (B at rear and E at the front) Order of stack after pop operations = A. Two elements deleted from the queue and pushed back on the stack: New order of stack = A, E, D(A at the bottom, D at the top) As D is on the top so when pop operation occurs D will be popped out. So, correct option is (D).",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 96,
    "Question Text": "Stack A has the entries a, b, c (with a on top). Stack B is empty. An entry popped out of stack A can be printed immediately or pushed to stack B. An entry popped out of the stack B can be only be printed. In this arrangement, which of the following permutations of a, b, c are not possible?",
    "Option A": "b a c",
    "Option B": "b c a",
    "Option C": "c a b",
    "Option D": "a b c",
    "Correct Answer": "D",
    "Explanation": "Option (A):\r\nPop a from stack A\r\nPush a to stack B\r\nPrint b\r\nPrint a from stack B\r\nPrint c from stack A\r\nOrder = b a c\r\n\r\nOption (B):\r\nPop a from stack A\r\nPush a to stack B\r\nPrint b from stack A\r\nPrint c from stack A\r\nPrint a from stack A\r\nOrder = b c a\r\n\r\nOption (C):\r\nPop a from stack A\r\nPush a to stack B\r\nPop b from stack A\r\nPush b to stack B\r\nPrint c from stack A\r\nNow, printing a will not be possible.\n\r\rSo, option (C) is incorrect.",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 97,
    "Question Text": "The five items: A, B, C, D, and E are pushed in a stack, one after other starting from A. The stack is popped four items and each element is inserted in a queue. The two elements are deleted from the queue and pushed back on the stack. Now one item is popped from the stack. The popped item is",
    "Option A": "A",
    "Option B": "B",
    "Option C": "C",
    "Option D": "D",
    "Correct Answer": "E",
    "Explanation": "When five items: A, B, C, D, and E are pushed in a stack:\r\nOrder of stack becomes: A, B, C, D, and E (A at the bottom and E at the top.)\r\nstack is popped four items and each element is inserted in a queue:\r\nOrder of queue: B, C, D, E (B at rear and E at the front)\r\nOrder of stack after pop operations = A\r\nTwo elements deleted from the queue and pushed back on the stack:\r\nNew order of stack = A, E, D(A at the bottom, D at the top)\r\nAs D is on the top so when pop operation occurs D will be popped out.\r\n\r\nSo, correct option is (D).",
    "Concept": "Stack",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 98,
    "Question Text": "Consider the following statements:i.   First-in-first out types of computations are efficiently supported by STACKS.ii.  Implementing LISTS on linked lists is more efficient than implementing LISTS on an array for almost all the basic LIST operations.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.iv.  Last-in-first-out type of computations are efficiently supported by QUEUES.Which of the following is correct?",
    "Option A": "(ii) is true",
    "Option B": "(i) and (ii) are true",
    "Option C": "(iii) is true",
    "Option D": "(ii) and (iv) are true",
    "Correct Answer": "C",
    "Explanation": "The correct statement is:iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.Explanation:i. STACKS are used to implement Last-in-First-Out (LIFO) operations, not First-in-First-out (FIFO) operations. Therefore, statement i is incorrect.ii. Implementing LISTS on a linked list is more efficient for some operations, such as adding or removing elements in the middle of the list, but it is less efficient for other operations, such as accessing elements by index. Therefore, the statement is incorrect.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices. This is because with a circular array, the front and rear indices wrap around when they reach the end of the array, making it more efficient toenqueue and dequeue elements. Therefore, the statement is correct.iv. QUEUES are used to implement First-in-First-out (FIFO) operations, not Last-in-First-out (LIFO) operations. Therefore, statement iv is incorrect.Hence Option (C) is the correct answer.",
    "Concept": "Stack",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 99,
    "Question Text": "The minimum number of stacks needed to implement a queue is",
    "Option A": "3",
    "Option B": "1",
    "Option C": "2",
    "Option D": "4",
    "Correct Answer": "C",
    "Explanation": "Two stacks S1 &amp; S2 are required to implement a queue.This method makes sure that newly entered element is always at the top of stack 1, so that DeQueue operation just pops from stack1. To put the element at top of stack1, stack2 is used.Hence Option (C) is the correct answer.",
    "Concept": "Stack",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 100,
    "Question Text": "Following is pseudo code of a function that takes a Queue as an argument, and uses a stack S to do processing.&nbsp;\n        C++\n        \n        void fun(Queue *Q) {\n    Stack S;  // Say it creates an empty stack S\n\n    // Run while Q is not empty\n    while (!isEmpty(Q)) {\n        // deQueue an item from Q and push the dequeued item to S\n        push(&amp;S, deQueue(Q));\n    }\n\n    // Run while Stack S is not empty\n    while (!isEmpty(&amp;S)) {\n        // Pop an item from S and enqueue the popped item to Q\n        enQueue(Q, pop(&amp;S));\n    }\n}\n\n        \n    \n        C\n        \n        void fun(Queue *Q)\n{\n    Stack S;  // Say it creates an empty stack S\n\n    // Run while Q is not empty\n    while (!isEmpty(Q))\n    {\n        // deQueue an item from Q and push the dequeued item to S\n        push(&amp;S, deQueue(Q));\n    }\n\n    // Run while Stack S is not empty\n    while (!isEmpty(&amp;S))\n    {\n      // Pop an item from S and enqueue the popped item to Q\n      enQueue(Q, pop(&amp;S));\n    }\n}\n\n        \n    \n        Java\n        \n        void fun(Queue Q) {\n    Stack S = new Stack();  // Say it creates an empty stack S\n\n    // Run while Q is not empty\n    while (!Q.isEmpty()) {\n        // deQueue an item from Q and push the dequeued item to S\n        S.push(Q.deQueue());\n    }\n\n    // Run while Stack S is not empty\n    while (!S.isEmpty()) {\n        // Pop an item from S and enqueue the popped item to Q\n        Q.enQueue(S.pop());\n    }\n}\n\n        \n    \n        Python\n        \n        def fun(Q):\n    S = []  # Say it creates an empty stack S\n\n    # Run while Q is not empty\n    while not Q.is_empty():\n        # deQueue an item from Q and push the dequeued item to S\n        S.append(Q.deQueue())\n\n    # Run while Stack S is not empty\n    while S:\n        # Pop an item from S and enqueue the popped item to Q\n        Q.enQueue(S.pop())\n\n        \n    \n        JavaScript\n        \n        function fun(Q) {\n    let S = [];  // Say it creates an empty stack S\n\n    // Run while Q is not empty\n    while (!Q.isEmpty()) {\n        // deQueue an item from Q and push the dequeued item to S\n        S.push(Q.deQueue());\n    }\n\n    // Run while Stack S is not empty\n    while (S.length &gt; 0) {\n        // Pop an item from S and enqueue the popped item to Q\n        Q.enQueue(S.pop());\n    }\n}\n\n        \n    What does the above function do in general?",
    "Option A": "Removes the last from Q",
    "Option B": "Keeps the Q same as it was before the call",
    "Option C": "Makes Q empty",
    "Option D": "Reverses the Q",
    "Correct Answer": "D",
    "Explanation": "The function takes a queue Q as an argument. It dequeues all items of Q and pushes them to a stack S. Then pops all items of S and enqueues the items back to Q. Since the stack is LIFO order, all items of the queue are reversed.Hence option (D) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 101,
    "Question Text": "How many stacks are needed to implement a queue. Consider the situation where no other data structure like arrays, linked list is available to you.",
    "Option A": "1",
    "Option B": "2",
    "Option C": "3",
    "Option D": "4",
    "Correct Answer": "B",
    "Explanation": "A queue can be implemented using two stacks.Refer this for more reference:https://www.geeksforgeeks.org/queue-using-stacks/Hence Option(B) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 102,
    "Question Text": "Which of the following operations on a queue data structure has a time complexity of O(1)?&nbsp;A) Enqueue&nbsp;B) Dequeue&nbsp;C) Peek&nbsp;D) Clear",
    "Option A": "A and B",
    "Option B": "B only",
    "Option C": "C only",
    "Option D": "A and D&nbsp;",
    "Correct Answer": "B",
    "Explanation": "In a queue data structure, dequeueing (removing an element from the front of the queue) typically has a time complexity of O(1) because it involves removing the first element and adjusting the front pointer.&nbsp;Hence, Option B is the correct option.",
    "Concept": "Queue",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 103,
    "Question Text": "A priority queue can efficiently implemented using which of the following data structures? Assume that the number of insert and peek (operation to see the current highest priority item) and extraction (remove the highest priority item) operations are almost same.",
    "Option A": "Array",
    "Option B": "Linked List",
    "Option C": "Heap Data Structures like Binary Heap, Fibonacci Heap",
    "Option D": "None of the above",
    "Correct Answer": "C",
    "Explanation": "A priority queue can be efficiently implemented using a data structure called a binary heap or Fibonacci Heap. A binary heap is a complete binary tree that satisfies the heap property. Binary heaps provide excellent time complexity for these operations, making them an efficient choice for implementing priority queues when the number of insert and peek/extraction operations is roughly equal.Hence option(C) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 104,
    "Question Text": "Which of the following is true about linked list implementation of queue?",
    "Option A": "In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end.",
    "Option B": "In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from the beginning.",
    "Option C": "Both of the above",
    "Option D": "None of the above",
    "Correct Answer": "C",
    "Explanation": "To keep the First In First Out order, a queue can be implemented using a linked list in any of the given two ways.Hence option (C) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 105,
    "Question Text": "A Priority-Queue is implemented as a Max-Heap. Initially, it has 5 elements. The level-order traversal of the heap is given below: 10, 8, 5, 3, 2 Two new elements \u201d1\u2018 and \u201d7\u2018 are inserted in the heap in that order. The level-order traversal of the heap after the insertion of the elements is:",
    "Option A": "10, 8, 7, 5, 3, 2, 1",
    "Option B": "10, 8, 7, 2, 3, 1, 5",
    "Option C": "10, 8, 7, 1, 2, 3, 5",
    "Option D": "10, 8, 7, 3, 2, 1, 5",
    "Correct Answer": "D",
    "Explanation": "The output will be 10, 8, &nbsp;7, 3, 2, 1, 5.Refer the image for clarification:&nbsp;Hence Option(D) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 106,
    "Question Text": "An implementation of a queue Q, using two stacks S1 and S2, is given below:&nbsp;Function Insert(Q, x):    Push x onto stack S1Function Delete(Q):    If stack S2 is empty:        If stack S1 is also empty:            Print \"Q is empty\"            Return        Else:            While stack S1 is not empty:                Pop element from stack S1 and store it in x                Push x onto stack S2    Pop element from stack S2 and store it in x    Return x  // Or process the popped element (if needed)Let n insert and m (&lt;=n) delete operations be performed in an arbitrary order on an empty queue Q. Let x and y be the number of push and pop operations performed respectively in the process. Which one of the following is true for all m and n?",
    "Option A": "n+m &lt;= x &lt; 2n and 2m &lt;= y &lt;= n+m",
    "Option B": "n+m &lt;= x &lt; 2n and 2m&lt;= y &lt;= 2n",
    "Option C": "2m &lt;= x &lt; 2n and 2m &lt;= y &lt;= n+m",
    "Option D": "2m &lt;= x &lt;2n and 2m &lt;= y &lt;= 2n",
    "Correct Answer": "A",
    "Explanation": "The order in which insert and delete operations are performed matters here. The best case: Insert and delete operations are performed alternatively. In every delete operation, 2 pop and 1 push operations are performed. So, total m+ n push (n push for insert() and m push for delete()) operations and 2m pop operations are performed. The worst case: First n elements are inserted and then m elements are deleted. In first delete operation, n + 1 pop operations and n push operation are performed. Other than first, in all delete operations, 1 pop operation is performed. So, total m + n pop operations and 2n push operations are performed (n push for insert() and n push for delete())Hence Option (A) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 107,
    "Question Text": "Consider the following operation along with Enqueue and Dequeue operations on queues, where k is a global parameter.MultiDequeue(Q){\n   m = k\n   while (Q is not empty and m  &gt; 0) {\n      Dequeue(Q)\n      m = m - 1\n   }\n}\nWhat is the worst case time complexity of a sequence of n MultiDequeue() operations on an initially empty queue? (A)&nbsp;[Tex]\\\\Theta(n)&nbsp;&nbsp;[/Tex](B)&nbsp;[Tex]\\\\Theta(n + k)&nbsp;&nbsp;[/Tex](C)&nbsp;[Tex]\\\\Theta(nk)&nbsp;&nbsp;[/Tex](D)&nbsp;[Tex]\\\\Theta(n^2)&nbsp;[/Tex]",
    "Option A": "A",
    "Option B": "B",
    "Option C": "C",
    "Option D": "D",
    "Correct Answer": "A",
    "Explanation": "Since the queue is empty initially, the condition of while loop never becomes true. So the time complexity is&nbsp;[Tex]\\\\Theta(n)&nbsp;&nbsp;[/Tex].Hence Option (A) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 108,
    "Question Text": "Consider the following pseudo-code. Assume that IntQueue is an integer queue. What does the function fun do?&nbsp;fun(int n)\n{    IntQueue q = new IntQueue();\n    q.enqueue(0);    q.enqueue(1);\n    for (int i = 0; i &lt; n; i++)\n    { \n       int a = q.dequeue();\n        int b = q.dequeue();\n        q.enqueue(b);\n        q.enqueue(a + b);\n        print(a);\n    }\n}",
    "Option A": "Prints numbers from 0 to n-1",
    "Option B": "Prints numbers from n-1 to 0",
    "Option C": "Prints first n Fibonacci numbers",
    "Option D": "Prints first n Fibonacci numbers in reverse order.",
    "Correct Answer": "C",
    "Explanation": "The function prints first n Fibonacci Numbers. Note that 0 and 1 are initially there in q. In every iteration of the loop sum of the two queue items is enqueued and the front item is dequeued.Hence option (C) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 109,
    "Question Text": "Which of the following is NOT a common operation in a queue data structure?&nbsp;",
    "Option A": "Enqueue&nbsp;",
    "Option B": "Dequeue&nbsp;",
    "Option C": "Peek&nbsp;",
    "Option D": "Shuffle&nbsp;",
    "Correct Answer": "D",
    "Explanation": "Shuffle is NOT a common operation in a queue data structure.Hence Option (D) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 110,
    "Question Text": "Suppose a stack implementation supports an instruction REVERSE, which reverses the order of elements on the stack, in addition to the PUSH and POP instructions. Which one of the following statements is TRUE with respect to this modified stack?",
    "Option A": "A queue cannot be implemented using this stack.",
    "Option B": "A queue can be implemented where ENQUEUE takes a single instruction and DEQUEUE takes a sequence of two instructions.",
    "Option C": "A queue can be implemented where ENQUEUE takes a sequence of three instructions and DEQUEUE takes a single instruction.",
    "Option D": "A queue can be implemented where both ENQUEUE and DEQUEUE take a single instruction each.",
    "Correct Answer": "C",
    "Explanation": "To DEQUEUE an item, simply POP. To ENQUEUE an item, we can do following 3 operations 1) REVERSE 2) PUSH 3) REVERSEHence Option (C) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 111,
    "Question Text": "A queue is implemented using an array such that ENQUEUE and DEQUEUE operations are performed efficiently. Which one of the following statements is CORRECT (n refers to the number of items in the queue)?",
    "Option A": "Both operations can be performed in O(1) time",
    "Option B": "At most one operation can be performed in O(1) time but the worst case time for the other operation will be \u03a9(n)",
    "Option C": "The worst case time complexity for both operations will be \u03a9(n)",
    "Option D": "Worst case time complexity for both operations will be \u03a9(log n)",
    "Correct Answer": "A",
    "Explanation": "Time Complexity AnalysisENQUEUE Operation:The rear pointer is updated in O(1) time.The element is inserted at the position indicated by the rear pointer.Time Complexity: O(1).DEQUEUE Operation:The front pointer is updated in O(1) time.The element is removed from the position indicated by the front pointer.Time Complexity: O(1).Worst Case Consideration:Both operations (ENQUEUE and DEQUEUE) involve pointer updates and accessing elements in the array, which can be done in constant time.No \u03a9(n) or \u03a9(log\u2061n) operations are required.Hence Option (A) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 112,
    "Question Text": "Let Q denote a queue containing sixteen numbers and S be an empty stack. Head(Q) returns the element at the head of the queue Q without removing it from Q. Similarly Top(S) returns the element at the top of S without removing it from S. Consider the algorithm given below.  The maximum possible number of iterations of the while loop in the algorithm is______ [This Question was originally a Fill-in-the-Blanks question]",
    "Option A": "16",
    "Option B": "32",
    "Option C": "256",
    "Option D": "64",
    "Correct Answer": "C",
    "Explanation": "The worst case happens when the queue is sorted in decreasing order. In worst case, loop runs n*n times.Queue: 4 3 2 1Stack: Empty3 2 143 2 1 4Empty2 1 432 1 4 3Empty1 4 321 4 3 2Empty4 3 213 21 43 2 412 41 32 4 314 31 23 1 2 43 4 1 241 2 3Empty1 2 3 4Hence Option (C) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 113,
    "Question Text": "Suppose you are given an implementation of a queue of integersConsider the following function:&nbsp;\n        C++\n        \n        void f(queue&lt;int&gt; &amp;Q) {\n    int i;\n    if (!Q.empty()) {\n        i = Q.front();\n        Q.pop();\n        f(Q);\n        Q.push(i);\n    }\n}\n\n        \n    \n        C\n        \n        void f(queue Q)\n{\n    int i;\n    if (!isEmpty(Q))\n    {\n        i = delete (Q);\n        f(Q);\n        insert(Q, i);\n    }\n}\n\n        \n    \n        Java\n        \n        void f(Queue&lt;Integer&gt; Q) {\n    if (!Q.isEmpty()) {\n        int i = Q.poll();\n        f(Q);\n        Q.add(i);\n    }\n}\n\n        \n    \n        Python\n        \n        def f(Q):\n    if Q:\n        i = Q.pop(0)\n        f(Q)\n        Q.append(i)\n\n        \n    \n        JavaScript\n        \n        function f(Q) {\n    if (Q.length &gt; 0) {\n        let i = Q.shift();\n        f(Q);\n        Q.push(i);\n    }\n}\n\n        \n    What operation is performed by the above function f ?",
    "Option A": "Leaves the queue Q unchanged",
    "Option B": "Reverses the order of the elements in the queue Q",
    "Option C": "Deletes the element at the front of the queue Q and inserts it at the rear keeping the other elements in the same order",
    "Option D": "Empties the queue Q",
    "Correct Answer": "B",
    "Explanation": "As it is recursive call, and removing from front while inserting from end, that means last element will be deleted at last and will be inserted 1st in the new queue. And like that it will continue till first call executes insert(Q,i) function.So, the queue will be in reverse.Hence Option (B) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 114,
    "Question Text": "Consider a standard Circular Queue 'q' implementation (which has the same condition for Queue Full and Queue Empty) whose size is 11 and the elements of the queue are q[0], q[1], q[2].....,q[10].\r\nThe front and rear pointers are initialized to point at q[2] . In which position will the ninth element be added?",
    "Option A": "q[0]",
    "Option B": "q[1]",
    "Option C": "q[9]",
    "Option D": "q[10]",
    "Correct Answer": "A",
    "Explanation": "Circular queue whose total size is 11, front and rear pointers are initialized to point at q[2]:    Therefore, 9th element will be added at pointer q[0].  So, option (A) is correct.",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 115,
    "Question Text": "Circular queue is also called -----.",
    "Option A": "Ring Buffer",
    "Option B": "Rectangular Buffer",
    "Option C": "Square Buffer",
    "Option D": "",
    "Correct Answer": "A",
    "Explanation": "A Circular Queue is an extended version of a normal queue where the last element of the queue is connected to the first element of the queue forming a circle. The operations are performed based on FIFO (First In First Out) principle. It is also called \u2018Ring Buffer\u2019.&nbsp;&nbsp;Hence Option (A) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 116,
    "Question Text": "A queue is implemented using a non-circular singly linked list. The queue has a head pointer and a tail pointer, as shown in the figure. Let n denote the number of nodes in the queue. Let 'enqueue' be implemented by inserting a new node at the head, and 'dequeue' be implemented by deletion of a node from the tail. Which one of the following is the time complexity of the most time-efficient implementation of 'enqueue' and 'dequeue, respectively, for this data structure?",
    "Option A": "\u0398(1), \u0398(1)",
    "Option B": "\u0398(1), \u0398(n)",
    "Option C": "\u0398(n), \u0398(1)",
    "Option D": "\u0398(n), \u0398(n)",
    "Correct Answer": "B",
    "Explanation": "For Enqueue operation, performs in constant amount of time (i.e., \u0398(1)), because it modifies only two pointers, i.e.,Create a Node P.P--&gt;Data = DataP--&gt;Next = HeadHead = PFor Dequeue operation, we need address of second last node of single linked list to make NULL of its next pointer. Since we can not access its previous node in singly linked list, so need to traverse entire linked list to get second last node of linked list, i.e.,temp = head; While( temp-Next--&gt;Next != NULL){        temp = temp-Next;        }temp--&gt;next = NULL;Tail = temp;Since, we are traversing entire linked for each Dequeue, so time complexity will be \u0398(n). Option (B) is correct.&nbsp;",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 117,
    "Question Text": "Which one of the following is an application of Queue Data Structure?",
    "Option A": "When a resource is shared among multiple consumers.",
    "Option B": "When data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes",
    "Option C": "Load Balancing",
    "Option D": "All of the above",
    "Correct Answer": "D",
    "Explanation": "(A) When a resource is shared among multiple consumers: In scenarios where a resource (such as a printer, CPU time, or database connection) needs to be shared among multiple consumers or processes, a queue data structure can be used. Each consumer can enqueue their requests for the resource, and the resource can be allocated to them in the order of their requests by dequeuing from the queue. This ensures fair access to the shared resource and prevents conflicts or resource contention.(B) When data is transferred asynchronously between two processes: When data is transferred asynchronously between two processes or systems, a queue can be used as a buffer or intermediary storage. One process enqueues the data to be sent, while the other process dequeues and processes the received data. The queue allows for decoupling the rate of data production from data consumption, ensuring smooth and efficient communication between the processes.(C) Load Balancing: Load balancing is the practice of distributing workloads across multiple resources to optimize performance and utilization. A queue data structure can be used in load-balancing algorithms to manage incoming requests or tasks. The requests are enqueued in the queue, and the load balancer can dequeue and assign them to available resources based on various criteria (e.g., round-robin, least connections). This helps distribute the workload evenly across the resources, preventing overload and maximizing throughput.Hence (D) is the correct option.&nbsp;",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 118,
    "Question Text": "Consider the following statements:i.   First-in-first out types of computations are efficiently supported by STACKS.ii.  Implementing LISTS on linked lists is more efficient than implementing LISTS on an array for almost all the basic LIST operations.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.iv.  Last-in-first-out type of computations are efficiently supported by QUEUES.Which of the following is correct?",
    "Option A": "(ii) is true",
    "Option B": "(i) and (ii) are true",
    "Option C": "(iii) is true",
    "Option D": "(ii) and (iv) are true",
    "Correct Answer": "C",
    "Explanation": "The correct statement is:iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices.Explanation:i. STACKS are used to implement Last-in-First-Out (LIFO) operations, not First-in-First-out (FIFO) operations. Therefore, statement i is incorrect.ii. Implementing LISTS on a linked list is more efficient for some operations, such as adding or removing elements in the middle of the list, but it is less efficient for other operations, such as accessing elements by index. Therefore, the statement is incorrect.iii. Implementing QUEUES on a circular array is more efficient than implementing QUEUES on a linear array with two indices. This is because with a circular array, the front and rear indices wrap around when they reach the end of the array, making it more efficient toenqueue and dequeue elements. Therefore, the statement is correct.iv. QUEUES are used to implement First-in-First-out (FIFO) operations, not Last-in-First-out (LIFO) operations. Therefore, statement iv is incorrect.Hence Option (C) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 119,
    "Question Text": "Which of the following option is not correct?",
    "Option A": "If the queue is implemented with a linked list, keeping track of a front pointer, Only rear pointer s will change during an insertion into an non-empty queue.",
    "Option B": "Queue data structure can be used to implement least recently used (LRU) page fault algorithm and Quick short algorithm.",
    "Option C": "Queue data structure can be used to implement Quick short algorithm but not least recently used (LRU) page fault algorithm.",
    "Option D": "Both (A) and (C)",
    "Correct Answer": "C",
    "Explanation": "If the queue is implemented with a linked list, keeping track of a front pointer, Only rear pointer s will change during an insertion into an non-empty queue. Queue data structure can be used to implement least recently used (LRU) page fault algorithm and Quick short algorithm. Only option (C) is not correct.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 120,
    "Question Text": "Suppose a circular queue of capacity (n \u2013 1) elements is implemented with an array of n elements. Assume that the insertion and deletion operation are carried out using REAR and FRONT as array index variables, respectively. Initially, REAR = FRONT = 0. The conditions to detect queue full and queue empty are",
    "Option A": "Full: (REAR+1) mod n == FRONT, empty: REAR == FRONT",
    "Option B": "Full: (REAR+1) mod n == FRONT, empty: (FRONT+1) mod n == REAR",
    "Option C": "Full: REAR == FRONT, empty: (REAR+1) mod n == FRONT",
    "Option D": "Full: (FRONT+1) mod n == REAR, empty: REAR == FRONT",
    "Correct Answer": "A",
    "Explanation": "Suppose we start filling the queue.Let the maxQueueSize ( Capacity of the Queue) is 4.So the size of the array which is used to implement this circular queue is 5, which is n. In the beginning when the queue is empty, FRONT and REAR point to 0 index in the array. REAR represents insertion at the REAR index. FRONT represents deletion from the FRONT index.enqueue(\"a\"); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 1)enqueue(\"b\"); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 2)enqueue(\"c\"); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 3)enqueue(\"d\"); REAR = (REAR+1)%5; ( FRONT = 0, REAR = 4)Now the queue size is 4 which is equal to the maxQueueSize. Hence overflow condition is reached.Now, we can check for the conditions.When Queue Full :( REAR+1)%n = (4+1)%5 = 0FRONT is also 0. Hence ( REAR + 1 ) %n is equal to FRONT.When Queue Empty :REAR was equal to FRONT when empty ( because in the starting before filling the queue FRONT = REAR = 0 )Hence Option A is correct.&nbsp;",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 121,
    "Question Text": "The minimum number of stacks needed to implement a queue is",
    "Option A": "3",
    "Option B": "1",
    "Option C": "2",
    "Option D": "4",
    "Correct Answer": "C",
    "Explanation": "Two stacks S1 &amp; S2 are required to implement a queue.This method makes sure that newly entered element is always at the top of stack 1, so that DeQueue operation just pops from stack1. To put the element at top of stack1, stack2 is used.Hence Option (C) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 122,
    "Question Text": "Which data structure is commonly used to implement the event-driven simulation of complex systems, such as in computer network simulations or traffic simulations?",
    "Option A": "Stack",
    "Option B": "Tree",
    "Option C": "Array",
    "Option D": "Queue",
    "Correct Answer": "D",
    "Explanation": "The data structure commonly used to implement the event-driven simulation of complex systems, such as computer network simulations or traffic simulations, is a queue. In event-driven simulations, events occur at specific times, and these events need to be processed in the order of their occurrence. A queue follows the First-In-First-Out (FIFO) principle, which makes it suitable for maintaining the order of events.Hence Option (D) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 123,
    "Question Text": "The deque which stores elements in strictly increasing order or in strictly decreasing order is called ------.",
    "Option A": "Priority &nbsp;Queue",
    "Option B": "Double ended Queue",
    "Option C": "Monotonic Deque",
    "Option D": "",
    "Correct Answer": "C",
    "Explanation": "Monotonic Deque :&nbsp;It is deque which stores elements in strictly increasing order or in strictly decreasing order&nbsp;To maintain monotonicity, we need to delete elementsFor example \u2013 Consider monotonic(decreasing) deque dq = &nbsp;{5, 4, 2, 1}&nbsp;Insert 3 into dqSo we need to delete elements till dq.back() &lt; 3 &nbsp; to insert 3 into dq &nbsp;(2,1 are the deleted elements)Resulting dq = {5, 4, 3}Hence Option (C) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 124,
    "Question Text": "Consider the below program, and identify what the function is doing.\n        C++\n        \n        #include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int item) {\n        data = item;\n        left = right = nullptr;\n    }\n};\n\nvoid function(Node* root) {\n    if (root == nullptr)\n        return;\n    std::queue&lt;Node*&gt; q;\n\n    q.push(root);\n\n    while (!q.empty()) {\n        Node* node = q.front();\n        q.pop();\n        std::cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;;\n\n        if (node-&gt;left != nullptr)\n            q.push(node-&gt;left);\n\n        if (node-&gt;right != nullptr)\n            q.push(node-&gt;right);\n    }\n}\n\n        \n    \n        C\n        \n        #include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nstruct Node* newNode(int item) {\n    struct Node* node = (struct Node*)malloc(sizeof(struct Node));\n    node-&gt;data = item;\n    node-&gt;left = node-&gt;right = NULL;\n    return node;\n}\n\nvoid function(struct Node* root) {\n    if (root == NULL)\n        return;\n    struct Node** q = (struct Node**)malloc(100 * sizeof(struct Node*));\n    int front = 0, rear = 0;\n\n    q[rear++] = root;\n\n    while (front &lt; rear) {\n        struct Node* node = q[front++];\n        printf(&quot;%d &quot;, node-&gt;data);\n\n        if (node-&gt;left != NULL)\n            q[rear++] = node-&gt;left;\n\n        if (node-&gt;right != NULL)\n            q[rear++] = node-&gt;right;\n    }\n    free(q);\n}\n\n        \n    \n        Java\n        \n        import java.util.LinkedList;\nimport java.util.Queue;\n\nclass Node {\n    int data;\n    Node left, right;\n    Node(int item) {\n        data = item;\n        left = right = null;\n    }\n}\n\nvoid function(Node root) {\n    if (root == null)\n        return;\n    Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();\n\n    q.add(root);\n\n    while (!q.isEmpty()) {\n        Node node = q.poll();\n        System.out.print(node.data + &quot; &quot;);\n\n        if (node.left != null)\n            q.add(node.left);\n\n        if (node.right != null)\n            q.add(node.right);\n    }\n}\n\n        \n    \n        Python\n        \n        class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nfrom collections import deque\n\ndef function(root):\n    if root is None:\n        return\n    q = deque()\n\n    q.append(root)\n\n    while q:\n        node = q.popleft()\n        print(node.data, end=&#39; &#39;)\n\n        if node.left is not None:\n            q.append(node.left)\n\n        if node.right is not None:\n            q.append(node.right)\n\n        \n    \n        JavaScript\n        \n        class Node {\n    constructor(data) {\n        this.data = data;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nfunction function(root) {\n    if (root === null)\n        return;\n    let q = [];\n\n    q.push(root);\n\n    while (q.length &gt; 0) {\n        let node = q.shift();\n        console.log(node.data);\n\n        if (node.left !== null)\n            q.push(node.left);\n\n        if (node.right !== null)\n            q.push(node.right);\n    }\n}",
    "Option A": "In order traversal of a tree",
    "Option B": "Normal traversal of a tree",
    "Option C": "Level order traversal of &nbsp;a tree",
    "Option D": "",
    "Correct Answer": "C",
    "Explanation": "The above code is the level order traversal of the tree using Queue. We need to visit the nodes in a lower level before any node in a higher level, this idea is quite similar to that of a queue. Push the nodes of a lower level in the queue. When any node is visited, pop that node from the queue and push the child of that node in the queue.This ensures that the node of a lower level is visited prior to any node of a higher level.Hence Option (C) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 125,
    "Question Text": "Which of the following is/are advantages of circular Queue?",
    "Option A": "Memory Management",
    "Option B": "Traffic system",
    "Option C": "CPU Scheduling",
    "Option D": "All of the above",
    "Correct Answer": "D",
    "Explanation": "Applications of Circular Queue:Memory Management: The unused memory locations in the case of ordinary queues can be utilized in circular queues.Traffic system: In computer controlled traffic system, circular queues are used to switch on the traffic lights one by one repeatedly as per the time set.CPU Scheduling: Operating systems often maintain a queue of processes that are ready to execute or that are waiting for a particular event to occur.Hence option(D) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 126,
    "Question Text": "which data structure is used to implement deque?",
    "Option A": "Stack",
    "Option B": "Doubly linked &nbsp;list",
    "Option C": "circular array",
    "Option D": "Both B and C",
    "Correct Answer": "D",
    "Explanation": "A Deque can be implemented either using a doubly-linked list or a circular array. In both implementations, we can implement all operations in O(1) time.Hence Option (D) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 127,
    "Question Text": "Which of the following is the type of priority Queue?",
    "Option A": "Ascending Order Priority Queue",
    "Option B": "Descending order Priority Queue&nbsp;",
    "Option C": "Deque",
    "Option D": "Both A and B.",
    "Correct Answer": "D",
    "Explanation": "Types of Priority Queue:1) Ascending Order Priority Queue: As the name suggests, in ascending order priority queue, the element with a lower priority value is given a higher priority in the priority list.2) Descending order Priority Queue: The root node is the maximum element in a max heap, as you may know. It will also remove the element with the highest priority first.Priority QueueHence Option(D) is the correct answer.",
    "Concept": "Queue",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 128,
    "Question Text": "What is wrong in the below code of printing Right View of a binary tree using the Queue data structure?\n        C++\n        \n        #include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nvoid printRightView(Node* root) {\n    if (root == nullptr) return;\n\n    queue&lt;Node*&gt; q;\n    q.push(root);\n    while (!q.empty()) {\n        int n = q.size();\n        for (int i = 0; i &lt; n; i++) {\n            Node* x = q.front();\n            q.pop();\n            if (i == n - 1) {\n                cout &lt;&lt; x-&gt;data &lt;&lt; &quot; &quot;;\n            }\n            if (x-&gt;left) {\n                q.push(x-&gt;left);\n            }\n            if (x-&gt;right) {\n                q.push(x-&gt;right);\n            }\n        }\n    }\n}\n\n        \n    \n        C\n        \n        #include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nstruct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n};\n\nvoid printRightView(struct Node* root) {\n    if (root == NULL) return;\n\n    struct Node** queue = (struct Node**)malloc(100 * sizeof(struct Node*));\n    int front = 0, rear = 0;\n    queue[rear++] = root;\n    while (front &lt; rear) {\n        int n = rear - front;\n        for (int i = 0; i &lt; n; i++) {\n            struct Node* x = queue[front++];\n            if (i == n - 1) {\n                printf(&quot;%d &quot;, x-&gt;data);\n            }\n            if (x-&gt;left) {\n                queue[rear++] = x-&gt;left;\n            }\n            if (x-&gt;right) {\n                queue[rear++] = x-&gt;right;\n            }\n        }\n    }\n    free(queue);\n}\n\n        \n    \n        Java\n        \n        import java.util.LinkedList;\nimport java.util.Queue;\n\nclass Node {\n    int data;\n    Node left, right;\n    Node(int val) {\n        data = val;\n        left = right = null;\n    }\n}\n\npublic class Main {\n    public static void printRightView(Node root) {\n        if (root == null) return;\n\n        Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();\n        q.add(root);\n        while (!q.isEmpty()) {\n            int n = q.size();\n            for (int i = 0; i &lt; n; i++) {\n                Node x = q.poll();\n                if (i == n - 1) {\n                    System.out.print(x.data + &quot; &quot;);\n                }\n                if (x.left != null) {\n                    q.add(x.left);\n                }\n                if (x.right != null) {\n                    q.add(x.right);\n                }\n            }\n        }\n    }\n}\n\n        \n    \n        Python\n        \n        from collections import deque\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\ndef printRightView(root):\n    if root is None:\n        return\n\n    q = deque([root])\n    while q:\n        n = len(q)\n        for i in range(n):\n            x = q.popleft()\n            if i == n - 1:\n                print(x.data, end=&#39; &#39;)\n            if x.left:\n                q.append(x.left)\n            if x.right:\n                q.append(x.right)\n\n        \n    \n        JavaScript\n        \n        class Node {\n    constructor(data) {\n        this.data = data;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nfunction printRightView(root) {\n    if (root === null) return;\n\n    let q = [root];\n    while (q.length) {\n        let n = q.length;\n        for (let i = 0; i &lt; n; i++) {\n            let x = q.shift();\n            if (i === n - 1) {\n                process.stdout.write(x.data + &#39; &#39;);\n            }\n            if (x.left) q.push(x.left);\n            if (x.right) q.push(x.right);\n        }\n    }\n}",
    "Option A": "We have not initialized anything in the Queue",
    "Option B": "Queue will never be empty.",
    "Option C": "left and right nodes of the tree are null.",
    "Option D": "",
    "Correct Answer": "A",
    "Explanation": "We have to add the root node into the queue to access tree node's value. The correct code will look like this.void printRightView(Node* root){    if (root == NULL)        return;    queue&lt;Node*&gt; q;    q.push(root);    while (!q.empty()) {        int n = q.size();        while (n--) {            Node* x = q.front();            q.pop();            if (n == 0) {                cout &lt;&lt; x-&gt;data &lt;&lt; \" \";            }            if (x-&gt;left)                q.push(x-&gt;left);            if (x-&gt;right)                q.push(x-&gt;right);        }    }}Hence (A) is the correct option.",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 129,
    "Question Text": "Given a queue with a linked list implementation. the Rear pointer points to the rear node of the queue. and the front node of the queue points to the front node of the queue, Which of the following operations is impossible to do in O(1) time?&nbsp;",
    "Option A": "Delete the front item from the list.",
    "Option B": "Delete the rear from the list.",
    "Option C": "insert at the front of the list.",
    "Option D": "",
    "Correct Answer": "B",
    "Explanation": "A Queue is defined as a linear data structure that is open at both ends and the operations are performed in First In First Out (FIFO) order.&nbsp;Linked listIt takes O(N) time to traverse the complete list in order to delete the node at the end, as its predecessor node must be changed to NULL.Hence (B) is the correct option.",
    "Concept": "Queue",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 130,
    "Question Text": "Following function is supposed to calculate the maximum depth or height of a Binary tree -- the number of nodes along the longest path from the root node down to the farthest leaf node.\r\n\r\n\n        C\n        \n        int maxDepth(struct node* node)\n{\n   if (node==NULL)\n       return 0;\n   else\n   {\n       /* compute the depth of each subtree */\n       int lDepth = maxDepth(node-&gt;left);\n       int rDepth = maxDepth(node-&gt;right);\n \n       /* use the larger one */\n       if (lDepth &gt; rDepth)\n           return X;\n       else return Y;\n   }\n}\n\n        \n    \n\r\nWhat should be the values of X and Y so that the function works correctly?",
    "Option A": "X  = lDepth, Y = rDepth",
    "Option B": "X  = lDepth + 1, Y = rDepth + 1",
    "Option C": "X  = lDepth - 1, Y = rDepth -1",
    "Option D": "None of the above",
    "Correct Answer": "C",
    "Explanation": "If a tree is not empty, height of tree is \r\nMAX(Height of Left Subtree, Height of Right Subtree) + 1\r\n\r\nSee program to Find the Maximum Depth or Height of a Tree for more details.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 131,
    "Question Text": "What is common in three different types of traversals (Inorder, Preorder and Postorder)?",
    "Option A": "Root is visited before right subtree",
    "Option B": "Left subtree is always visited before right subtree",
    "Option C": "Root is visited after left subtree",
    "Option D": "All of the above",
    "Correct Answer": "C",
    "Explanation": "The order of inorder traversal is \r\nLEFT ROOT RIGHT\r\n\r\nThe order of preorder traversal is\r\nROOT LEFT RIGHT\r\n\r\nThe order of postorder traversal is\r\nLEFT RIGHT ROOT\r\n\r\n\r\nIn all three traversals, LEFT is traversed before RIGHT",
    "Concept": "Tree",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 132,
    "Question Text": "The inorder and preorder traversal of a binary tree are d b e a f c g and a b d e c f g, respectively. The postorder traversal of the binary tree is:",
    "Option A": "d e b f g c a",
    "Option B": "e d b g f c a",
    "Option C": "e d b f g c a",
    "Option D": "d e f g b c a",
    "Correct Answer": "B",
    "Explanation": "Below is the given tree.\r\n                              a\r\n                           /    \\\\\r\n                        /          \\\\\r\n                      b             c\r\n                   /   \\\\          /   \\\\\r\n                 /       \\\\      /       \\\\\r\n               d         e    f          g",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 133,
    "Question Text": "What does the following function do for a given binary tree?\r\n\r\n\n        C\n        \n        int fun(struct node *root)\n{\n   if (root == NULL)\n      return 0;\n   if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\n      return 0;\n   return 1 + fun(root-&gt;left) + fun(root-&gt;right);\n}",
    "Option A": "Counts leaf nodes",
    "Option B": "Counts internal nodes",
    "Option C": "Returns height where height is defined as number of edges on the path from root to deepest node",
    "Option D": "Return diameter where diameter is number of edges on the longest path between any two nodes.",
    "Correct Answer": "C",
    "Explanation": "The function counts internal nodes.\r\n1) If root is NULL or a leaf node, it returns 0.\r\n2) Otherwise returns, 1 plus count of internal nodes in left subtree, plus count of internal nodes in right subtree.\r\n\r\nSee the following complete program.\r\n\n        C\n        \n        #include &lt;stdio.h&gt;\n\nstruct node\n{\n  int key;\n  struct node *left, *right;\n};\n\nint fun(struct node *root)\n{\n   if (root == NULL)\n      return 0;\n   if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)\n      return 0;\n   return 1 + fun(root-&gt;left) + fun(root-&gt;right);\n}\n\n/* Helper function that allocates a new node with the\n   given key and NULL left and right pointers. */\nstruct node* newNode(int key)\n{\n  struct node* node = (struct node*)\n                       malloc(sizeof(struct node));\n  node-&gt;key = key;\n  node-&gt;left = NULL;\n  node-&gt;right = NULL;\n\n  return(node);\n}\n\n/* Driver program to test above functions*/\nint main()\n{\n\n  /* Constructed binary tree is\n            1\n          /   \\\\\n        2      3\n      /  \\\\    /\n    4     5  8\n  */\n  struct node *root = newNode(1);\n  root-&gt;left        = newNode(2);\n  root-&gt;right       = newNode(3);\n  root-&gt;left-&gt;left  = newNode(4);\n  root-&gt;left-&gt;right = newNode(5);\n  root-&gt;right-&gt;left = newNode(8);\n\n  printf(&quot;%d&quot;, fun(root));\n\n  getchar();\n  return 0;\n}",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 134,
    "Question Text": "Which of the following pairs of traversals is not sufficient to build a binary tree from the given traversals?",
    "Option A": "Preorder and Inorder",
    "Option B": "Preorder and Postorder",
    "Option C": "Inorder and Postorder",
    "Option D": "None of the Above",
    "Correct Answer": "C",
    "Explanation": "See  http://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/ for details.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 135,
    "Question Text": "Consider two binary operators '[Tex]\\uparrow[/Tex] ' and '[Tex]\\downarrow[/Tex]' with the precedence of operator [Tex]\\downarrow[/Tex] being lower than that of the [Tex]\\uparrow[/Tex] operator. Operator [Tex]\\uparrow[/Tex] is right associative while operator [Tex]\\downarrow[/Tex] is left associative. Which one of the following represents the parse tree for expression (7 [Tex]\\downarrow[/Tex] 3 \u00ad[Tex]\\uparrow[/Tex] 4 \u00ad[Tex]\\uparrow[/Tex] 3 [Tex]\\downarrow[/Tex] 2)? (GATE CS 2011)",
    "Option A": "A",
    "Option B": "B",
    "Option C": "C",
    "Option D": "D",
    "Correct Answer": "B",
    "Explanation": "Let us consider the given expression ([Tex]7 \\downarrow 3 \\uparrow 4 \\uparrow 3 \\downarrow 2[/Tex]).  Since the precedence of [Tex]\\uparrow[/Tex] is higher, the sub-expression ([Tex]3 \\uparrow 4 \\uparrow 3[/Tex]) will be evaluated first. In this sub-expression, [Tex]4 \\uparrow 3[/Tex] would be evaluated first because [Tex]\\uparrow[/Tex] is right to left associative. So the expression is evaluated as [Tex]((7 \\downarrow (3 \\uparrow (4 \\uparrow 3))) \\downarrow 2)[/Tex]. Also, note that among the two [Tex]\\downarrow [/Tex] operators, first one is evaluated before the second one because the associativity of [Tex]\\downarrow[/Tex] is left to right.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 136,
    "Question Text": "Which traversal of tree resembles the breadth first search of the graph?",
    "Option A": "Preorder",
    "Option B": "Inorder",
    "Option C": "Postorder",
    "Option D": "Level order",
    "Correct Answer": "E",
    "Explanation": "Breadth first search visits all the neighbors first and then deepens into each neighbor one by one. The level order traversal of the tree also visits nodes on the current level and then goes to the next level.",
    "Concept": "Tree",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 137,
    "Question Text": "Which of the following tree traversal uses a queue data structure?",
    "Option A": "Preorder",
    "Option B": "Inorder",
    "Option C": "Postorder",
    "Option D": "Level order",
    "Correct Answer": "E",
    "Explanation": "Level order traversal uses a queue data structure to visit the nodes level by level.",
    "Concept": "Tree",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 138,
    "Question Text": "Which of the following cannot generate the full binary tree?",
    "Option A": "Inorder and Preorder",
    "Option B": "Inorder and Postorder",
    "Option C": "Preorder and Postorder",
    "Option D": "None of the above",
    "Correct Answer": "E",
    "Explanation": "To generate a binary tree, two traversals are necessary and one of them must be inorder. But, a full binary tree can be generated from preorder and postorder traversals. Read the algorithm here.\r\nRead Can tree be constructed from given traversals?",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 139,
    "Question Text": "Consider the following C program segment\r\n\r\n\n        c\n        \n        struct CellNode\n{\n  struct CelINode *leftchild;\n  int element;\n  struct CelINode *rightChild;\n}\n\nint Dosomething(struct CelINode *ptr)\n{\n    int value = 0;\n    if (ptr != NULL)\n    {\n      if (ptr-&gt;leftChild != NULL)\n        value = 1 + DoSomething(ptr-&gt;leftChild);\n      if (ptr-&gt;rightChild != NULL)\n        value = max(value, 1 + DoSomething(ptr-&gt;rightChild));\n    }\n    return (value);\n}\n\n        \n    \n\r\nThe value returned by the function DoSomething when a pointer to the root of a non-empty tree is passed as argument is  (GATE CS 2004)",
    "Option A": "The number of leaf nodes in the tree",
    "Option B": "The number of nodes in the tree",
    "Option C": "The number of internal nodes in the tree",
    "Option D": "The height of the tree",
    "Correct Answer": "E",
    "Explanation": "Explanation: DoSomething() returns max(height of left child + 1, height of right child + 1).  So given that pointer to root of tree is passed to DoSomething(), it will return height of the tree. Note that this implementation follows the convention where height of a single node is 0.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 140,
    "Question Text": "Let LASTPOST, LASTIN and LASTPRE denote the last vertex visited in a postorder, inorder and preorder traversal. Respectively, of a complete binary tree. Which of the following is always true? (GATE CS 2000)",
    "Option A": "LASTIN = LASTPOST",
    "Option B": "LASTIN = LASTPRE",
    "Option C": "LASTPRE = LASTPOST",
    "Option D": "None of the above",
    "Correct Answer": "E",
    "Explanation": "It is given that the given tree is complete binary tree. For a complete binary tree, the last visited node will always be same for inorder and preorder traversal.  None of the above is true even for a complete binary tree. \r\rThe option (a) is incorrect because the last node visited in Inorder traversal is right child and last node visited in Postorder traversal is root.\r\rThe option (c) is incorrect because the last node visited in Preorder traversal is right child and last node visited in Postorder traversal is root.\r\rFor option (b), see the following counter example. Thanks to Hunaif Muhammed for providing the correct explanation.\r\r\n     1\r\n   /    \\\\\r\n  2      3\r\n / \\\\    /\r\n4   5  6  \r\n\r\nInorder traversal is 4 2 5 1 6 3\r\nPreorder traversal is 1 2 4 5 3 6",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 141,
    "Question Text": "The array representation of a complete binary tree contains the data in sorted order. Which traversal of the tree will produce the data in sorted form?",
    "Option A": "Preorder",
    "Option B": "Inorder",
    "Option C": "Postorder",
    "Option D": "Level order",
    "Correct Answer": "E",
    "Explanation": "The level order traversal of a binary tree prints the data in the same order as it is stored in the array representation of a complete binary tree.",
    "Concept": "Tree",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 142,
    "Question Text": "Consider the following rooted tree with the vertex P labeled as root\r\n\r\n\r\n\r\nThe order in which the nodes are visited during in-order traversal is",
    "Option A": "SQPTRWUV",
    "Option B": "SQPTURWV",
    "Option C": "SQPTWUVR",
    "Option D": "SQPTRUWV",
    "Correct Answer": "B",
    "Explanation": "Algorithm Inorder(tree) - Use of Recursion\r\nSteps:\r\n1. Traverse the left subtree, \r\n   i.e., call Inorder(left-subtree)\r\n2. Visit the root.\r\n3. Traverse the right subtree, \r\n   i.e., call Inorder(right-subtree)\r\n\r\nUnderstanding this algorithm requires the basic \r\nunderstanding of Recursion\r\n\r\nTherefore, We begin in the above tree with root as\r\nthe starting point, which is P.\r\n\r\n# Step 1( for node P) :\r\nTraverse the left subtree of node or root P.\r\nSo we have node Q on left of P.\r\n\r\n-> Step 1( for node Q)\r\nTraverse the left subtree of node Q.\r\nSo we have node S on left of Q.\r\n\r\n* Step 1 (for node S)\r\nNow again traverse the left subtree of node S which is \r\nNULL here.\r\n\r\n* Step 2(for node S)\r\nVisit the node S, i.e print node S as the 1st element of \r\ninorder traversal.\r\n\r\n* Step 3(for node S)\r\nTraverse the right subtree of node S.\r\nWhich is NULL here.\r\n\r\nNow move up in the tree to Q which is parent\r\nof S.( Recursion, function of Q called for function of S).\r\nHence we go back to Q.\r\n\r\n-> Step 2( for node Q):\r\nVisit the node Q, i.e print node Q as the 2nd\r\nelement of inorder traversal.\r\n\r\n-> Step 3 (for node Q)\r\nTraverse the right subtree of node Q.\r\nWhich is NULL here.\r\n\r\nNow move up in the tree to P which is parent\r\nof Q.( Recursion, function of P called for function of Q).\r\nHence we go back to P.\r\n\r\n# Step 2(for node P)\r\nVisit the node P, i.e print node S as the 3rd\r\nelement of inorder traversal.\r\n\r\n# Step 3 (for node P)\r\nTraverse the right subtree of node P.\r\nNode R is at the right of P.\r\n\r\nTill now we have printed SQP as the inorder of the tree. \r\nSimilarly other elements can be obtained by traversing \r\nthe right subtree of P.\r\n\r\nThe final correct order of Inorder traversal would \r\nbe SQPTRWUV.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 143,
    "Question Text": "Consider the pseudocode given below. The function DoSomething() takes as argument a pointer to the root of an arbitrary tree represented by the leftMostChild-rightSibling representation.\r\nEach node of the tree is of type treeNode.\r\n\r\n\n        C\n        \n        typedef struct treeNode* treeptr;\nstruct treeNode\n{\n    treeptr leftMostChild, rightSibling;\n};\nint DoSomething (treeptr tree)\n{\n    int value=0;\n    if (tree != NULL)\n    {\n        if (tree-&gt;leftMostChild == NULL)\n            value = 1;\n        else\n            value = DoSomething(tree-&gt;leftMostChild);\n        value = value + DoSomething(tree-&gt;rightSibling);\n    }\n    return(value);\n}\n\n        \n    \n\r\nWhen the pointer to the root of a tree is passed as the argument to DoSomething, the value returned by the function corresponds to the",
    "Option A": "number of internal nodes in the tree.",
    "Option B": "height of the tree.",
    "Option C": "number of nodes without a right sibling in the tree.",
    "Option D": "number of leaf nodes in the tree.",
    "Correct Answer": "E",
    "Explanation": "The function counts leaf nodes for a tree represented using leftMostChild-rightSibling representation.\r\n\r\nBelow is function with comments added to demonstrate how function works.\r\n\r\n\n        C\n        \n        int DoSomething (treeptr tree)\n{\n    // If tree is empty, 0 is returned\n    int value = 0;\n\n    // IF tree is not empty\n    if (tree != NULL)\n    {\n        // IF this is a leaf node, then values is initialized as 1\n        if (tree-&gt;leftMostChild == NULL)\n            value = 1;\n\n        // Else value is initialized as the value returned by leftmost\n        // child which in turn calls for the other children of this node\n        // Using last call &quot;value = value + DoSomething(tree-&gt;rightSibling);&quot;\n        else\n            value = DoSomething(tree-&gt;leftMostChild);\n\n        // Add value returned by right sibling\n        value = value + DoSomething(tree-&gt;rightSibling);\n    }\n    return(value);\n}",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 144,
    "Question Text": "Level order traversal of a rooted tree can be done by starting from the root and performing",
    "Option A": "preorder traversal",
    "Option B": "inorder traversal",
    "Option C": "depth first search",
    "Option D": "breadth first search",
    "Correct Answer": "D",
    "Explanation": "Level order traversal of a rooted tree, also known as breadth-first traversal, can be done by starting from the root and visiting each level of the tree from left to right. Here's how it can be performed:1. Enqueue the root node into a queue.2. While the queue is not empty, repeat steps 3-5:   3. Dequeue a node from the front of the queue and visit it.   4. Enqueue all the children (if any) of the dequeued node from left to right.   5. Repeat until all nodes at the current level are visited.6. Continue until all levels of the tree are traversed.Here's a pseudocode representation of the algorithm:```levelOrderTraversal(root):    if root is NULL:        return    create an empty queue    enqueue root into the queue    while queue is not empty:        current = dequeue from the front of the queue        visit current node        for each child of current (if any):            enqueue child into the queue```This algorithm ensures that nodes at each level of the tree are visited before proceeding to the next level. It effectively traverses the tree in a breadth-first manner, starting from the root.",
    "Concept": "Tree",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 145,
    "Question Text": "Consider the label sequences obtained by the following pairs of traversals on a labeled binary tree. Which of these pairs identify a tree uniquely ? \r\n(i)     preorder and postorder\r\n(ii)    inorder and postorder\r\n(iii)   preorder and inorder\r\n(iv)   level order and postorder",
    "Option A": "(i) only",
    "Option B": "(ii), (iii)",
    "Option C": "(iii) only",
    "Option D": "(iv) only",
    "Correct Answer": "C",
    "Explanation": "Here, we consider each and every option to check whether it is true or false.\r\n\r\n1) Preorder and postorder\r\n\r\n\r\nFor the above trees,\r\n\r\nPreorder is AB\r\n\r\nPostorder is BA\r\n\r\nIt shows that preorder and postorder can\u2019t identify a tree uniquely.\r\n\r\n2) Inorder and postorder define a tree uniquely\r\n\r\n3) Preorder and Inorder also define a tree uniquely\r\n\r\n4) Levelorder and postorder can\u2019t define a tree uniquely. For the above example,\r\n\r\nLevel order is AB\r\n\r\nPostorder is BA\r\n\r\nSee http://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/ for details\r\n\r\n\r\nThis solution is contributed by Anil Saikrishna Devarasetty",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 146,
    "Question Text": "Let LASTPOST, LASTIN and LASTPRE denote the last vertex visited in a postorder, inorder and preorder traversal, respectively, of a complete binary tree. Which of the following is always true?",
    "Option A": "LASTIN = LASTPOST",
    "Option B": "LASTIN = LASTPRE",
    "Option C": "LASTPRE = LASTPOST",
    "Option D": "None of the above",
    "Correct Answer": "E",
    "Explanation": "See question 1 of http://www.geeksforgeeks.org/data-structures-and-algorithms-set-1/",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 147,
    "Question Text": "Which one of the following binary trees has its inorder and preorder traversals as BCAD\u00a0 and ABCD, respectively?",
    "Option A": "A",
    "Option B": "B",
    "Option C": "C",
    "Option D": "D",
    "Correct Answer": "E",
    "Explanation": "Inorder Traversal:\u00a0Left -Root\u00a0-Right\r\rPreOrder Traversal:\u00a0Root-Left-Right\r\r\n    InOrder  PreOrder\r\n\r\nA. \u00a0 BADC \u00a0 ABCD\r\n\r\nB. \u00a0 BCAD\u00a0 \u00a0ACBD\r\n\r\nC. \u00a0 ACBD \u00a0 ABCD\n\rD. \u00a0 \u00a0BCAD \u00a0ABCD\r\rTherefore, D is Correct",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 148,
    "Question Text": "The numbers 1, 2, .... n are inserted in a binary search tree in some order. In the resulting tree, the right subtree of the root contains p nodes. The first number to be inserted in the tree must be",
    "Option A": "p",
    "Option B": "p + 1",
    "Option C": "n - p",
    "Option D": "n - p + 1",
    "Correct Answer": "D",
    "Explanation": "Binary Search Tree, is a node-based binary tree data structure which has the following properties:\r\n\r\n\tThe left subtree of a node contains only nodes with keys less than the node\u2019s key.\r\n\tThe right subtree of a node contains only nodes with keys greater than the node\u2019s key.\r\n\tThe left and right subtree each must also be a binary search tree.\r\nThere must be no duplicate nodes.\r\n\r\n\r\nSo let us say n=10, p=4. According to BST property the root must be 10-4=6 (considering all unique elements in BST)\r\nAnd according to BST insertion, root is the first element to be inserted in a BST.\r\n\r\nTherefore, the answer is (n-p).\r\n&nbsp;",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 149,
    "Question Text": "A binary search tree contains the numbers 1, 2, 3, 4, 5, 6, 7, 8. When the tree is traversed in pre-order and the values in each node printed out, the sequence of values obtained is 5, 3, 1, 2, 4, 6, 8, 7. If the tree is traversed in post-order, the sequence obtained would be\r\n\r\n&nbsp;",
    "Option A": "8, 7, 6, 5, 4, 3, 2, 1",
    "Option B": "1, 2, 3, 4, 8, 7, 6, 5",
    "Option C": "2, 1, 4, 3, 6, 7, 8, 5",
    "Option D": "2, 1, 4, 3, 7, 8, 6, 5",
    "Correct Answer": "E",
    "Explanation": "Please see this link for more details\r\n\r\nhttp://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 150,
    "Question Text": "Consider the following sequence of nodes for the undirected graph given below.\r\n\r\na b e f d g c\r\na b e f c g d\r\na d g e b c f\r\na d b c g e f\r\nA Depth First Search (DFS) is started at node a. The nodes are listed in the order they are first visited. Which all of the above is (are) possible output(s)?",
    "Option A": "1 and 3 only",
    "Option B": "2 and 3 only",
    "Option C": "2, 3 and 4 only",
    "Option D": "1, 2, and 3",
    "Correct Answer": "C",
    "Explanation": "1: abef->c or g should be covered\r\n4: adbc->e or f should be covered \r\n2: abefcgd  correct\r\n3: adgebcf correct",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 151,
    "Question Text": "Which of the following statement is false?",
    "Option A": "A tree with n nodes has (n-1) edges.",
    "Option B": "A labeled rooted binary tree can be uniquely constructed given its postorder and preorder traversal results.",
    "Option C": "A complete binary tree with n internal nodes has (n+1) leaves.",
    "Option D": "The maximum number of nodes in a binary tree of height h is (2^(h+1)  -1).",
    "Correct Answer": "C",
    "Explanation": "Both option (A) and (D) are correct. But option (B) is false because \"a labeled rooted binary tree can not be uniquely constructed given using its postorder and preorder traversal results\". It need inorder and preorder/postorder for uniquely constructed binary tree.\r\n\r\nOption (C) is also false, take counter example in given tree :\r\n\r\n\r\nTherefore, both option (B) and (C) are false.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 152,
    "Question Text": "A complete n-ary tree is one in which every node has 0 or n sons. If x is the number of internal nodes of a complete n-ary tree, the number of leaves in it is given by",
    "Option A": "x(n-1)+1",
    "Option B": "xn-1",
    "Option C": "xn+1",
    "Option D": "x(n+1)",
    "Correct Answer": "B",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 153,
    "Question Text": "Which of the following sequences denotes the post order traversal sequence of the given tree?\r\n         a\r\n       /   \\\\\r\n      b     e\r\n     / \\\\   /\r\n    c  d  f\r\n   /\r\n  g",
    "Option A": "f e g c d b a",
    "Option B": "g c b d a f e",
    "Option C": "g c d b f e a",
    "Option D": "f e d g c b a",
    "Correct Answer": "D",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 154,
    "Question Text": "Which of following option is not correct regarding depth first searching?",
    "Option A": "In a depth-first traversal of a graph G with V vertices, E edges are marked as tree edges. The number of connected components in G is (E - V).",
    "Option B": "Depth-first search requires O(V^2) time if implemented with an adjacency matrix.",
    "Option C": "Depth-first search requires O(V + E) time if implemented with adjacency lists",
    "Option D": "None of these",
    "Correct Answer": "B",
    "Explanation": "In a depth-first traversal of a graph G with V vertices, E edges are marked as tree edges. The number of connected components in G is (V - E).\r\nOnly option (A) is false.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 155,
    "Question Text": "The post-order traversal of a binary search tree is given by 2, 7, 6, 10, 9, 8, 15, 17, 20, 19, 16, 12.\r\nThen the pre-order traversal of this tree is:",
    "Option A": "2, 6, 7, 8, 9, 10, 12, 15, 16, 17, 19, 20",
    "Option B": "7, 6, 2, 10, 9, 8, 15, 16, 17, 20, 19, 12",
    "Option C": "7, 2, 6, 8, 9, 10, 20, 17, 19, 15, 16, 12",
    "Option D": "12, 8, 6, 2, 7, 9, 10, 16, 15, 19, 17, 20",
    "Correct Answer": "E",
    "Explanation": "Since given tree is binary tree, so inorder traversal will be always sorted order, i.e., 2, 6, 7, 8, 9, 10, 12, 15, 16, 17, 19, 20. \r\nNow we can draw that binary search tree using given postorder and inorder traversal. Final tree will be:\r\n\r\n\r\n\r\nTherefore, preorder traversal will be : 12, 8, 6, 2, 7, 9, 10, 16, 15, 19, 17, 20. \r\n\r\nOption (D) is correct.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 156,
    "Question Text": "Let G be a simple undirected graph. Let TD be a depth first search tree of G. Let TB be a breadth first search tree of G. Consider the following statements. (I) No edge of G is a cross edge with respect to TD. (A cross edge in G is between two nodes neither of which is an ancestor of the other in TD). (II) For every edge (u, v) of G, if u is at depth i and v is at depth j in TB, then \u2223i \u2212 j\u2223 = 1. Which of the statements above must necessarily be true?",
    "Option A": "I only",
    "Option B": "II only",
    "Option C": "Both I and II",
    "Option D": "Neither I nor II",
    "Correct Answer": "A",
    "Explanation": "There are four types of edges can yield in DFS. These are tree, forward, back, and cross edges. In undirected connected graph, forward and back edges are the same thing. A cross edge in a graph is an edge that goes from a vertex v to another vertex u such that u is neither an ancestor nor descendant of v. Therefore, cross edge is not possible in undirected graph. So, statement (I) is correct. For statement (II) take counterexample of complete graph of three vertices, i.e., K3 with XYZ, where X is source and Y and Z are in same level. Also,there is an edge between vertices Y and Z, i.e., |i-j| = 0 \u2260 1 in BFS. So, statement became false. Option (A) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 157,
    "Question Text": "Suppose the numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree. The binary search tree uses the reversal ordering on natural numbers i.e. 9 is assumed to be smallest and 0 is assumed to be largest. The in-order traversal of the resultant binary search tree is",
    "Option A": "9, 8, 6, 4, 2, 3, 0, 1, 5, 7",
    "Option B": "0, 1, 2, 3, 4, 5, 6, 7, 8, 9",
    "Option C": "0, 2, 4, 3, 1, 6, 5, 9, 8, 7",
    "Option D": "9, 8, 7, 6, 5, 4, 3, 2, 1, 0",
    "Correct Answer": "E",
    "Explanation": "Inorder traversal of a binary search tree always produces the keys in increasing order. In this question Reverse ordering of natural numbers are used i.e. 9 is assumed to be the smallest and 0 to be the largest. So the sequence in increasing order will be 9, 8, 7, 6, 5, 4, 3, 2, 1, 0.\r\nSo, option (D) is correct.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 158,
    "Question Text": "The in-order and pre-order traversal of a binary tree are d b e a f c g and a b d e c f g respectively. The post order traversal of a binary tree is",
    "Option A": "e d b g f c a",
    "Option B": "e d b f g c a",
    "Option C": "d e b f g c a",
    "Option D": "d e f g b c a",
    "Correct Answer": "D",
    "Explanation": "Refer:  GATE-CS-2007 | Question 39 \r\n\r\nOption (C) is correct.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 159,
    "Question Text": "Consider the following tree\r\n\r\n\r\n\r\nIf the post order traversal gives ab-cd*+ then the label of the nodes 1,2,3,\u2026 will be",
    "Option A": "+,-,*,a,b,c,d",
    "Option B": "a,-,b,+,c,*,d",
    "Option C": "a,b,c,d,-,*,+",
    "Option D": "-,a,b,+,*,c,d",
    "Correct Answer": "B",
    "Explanation": "Postorder traversal of the given binary tree will give the following sequence: 4 5 2 6 7 3 1.\r\nNow comparing the sequence with a b - c d * + we get 1 = +, 2 = -, 3 = *, 4 = a, 5 = b, 6 = c and 7 = d.\r\nSo, option (A) is correct.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 160,
    "Question Text": "Choose the equivalent prefix form of the following expression\r\n(a + (b \u2212 c))* ((d \u2212 e)/(f + g \u2212 h))",
    "Option A": "* +a \u2212 bc /\u2212 de \u2212 +fgh",
    "Option B": "* +a \u2212bc \u2212 /de \u2212 +fgh",
    "Option C": "* +a \u2212 bc /\u2212 ed + \u2212fgh",
    "Option D": "* +ab \u2212 c /\u2212 ed + \u2212fgh",
    "Correct Answer": "B",
    "Explanation": "We can write the prefix form of the expression as:\r\n(a + (b \u2212 c))* ((d \u2212 e) / (f + g \u2212 h))\r\n= (a + (- b c)) * ((- d e) / ( + f g - h))\r\n= (+ a - b c) * ((- d e) / (- + f g h)\r\n= (+ a - b c) * (/ - d e - + f g h)\r\n= * + a - b c / - d e - + f g h",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 161,
    "Question Text": "The number of rotations required to insert a sequence of elements 9,6,5,8,7,10 into an empty AVL tree is?",
    "Option A": "0",
    "Option B": "1",
    "Option C": "2",
    "Option D": "3",
    "Correct Answer": "E",
    "Explanation": "The insertion and rotation of the various elements are shown in the following figure:\r\n\r\n \r\n\r\nSo, the total number of rotations are 3.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 162,
    "Question Text": "Consider the following statements: \r\n(a) Depth - first search is used to traverse a rooted tree. \r\n(b) Pre - order, Post-order and Inorder are used to list the vertices of an ordered rooted tree. \r\n(c) Huffman\u2019s algorithm is used to find an optimal binary tree with given weights. \r\n(d) Topological sorting provides a labelling such that the parents have larger labels than their children. \r\nWhich of the above statements are true?",
    "Option A": "(a) and (b)",
    "Option B": "(c) and (d)",
    "Option C": "(a), (b) and (c)",
    "Option D": "(a), (b), (c) and (d)",
    "Correct Answer": "E",
    "Explanation": "Depth - first search is used to traverse a rooted tree. Correct Pre - order, Post-order and Inorder are used to list the vertices of an ordered rooted tree. CorrectHuffman\u2019s algorithm is used to find an optimal binary tree with given weights. CorrectTopological sorting provides a labelling such that the parents have larger labels than their children.Correct\r\nSo, option (D) is correct.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 163,
    "Question Text": "The inorder and preorder Traversal of binary Tree are dbeafcg and abdecfg respectively. The post-order Traversal is __________.",
    "Option A": "dbefacg",
    "Option B": "debfagc",
    "Option C": "dbefcga",
    "Option D": "debfgca",
    "Correct Answer": "E",
    "Explanation": "Inorder and preorder Traversal of binary Tree are dbeafcg and abdecfg respectively. \r\nFrom preorder(Parent left right) and inorder ( left parent right) we can easily find post order. \r\nFrom preorder(a(bdecfg)), it is clear that a is parent node(root node), Now we will look for left subttree in inorder traversal i.e. dbe and fcg.\r\nTo find root node and left subtree and right subtree of these subtree we will do the same process as above:\r\nNow see this scenario in graph:\r\n\r\nNow from above tree we can easily find out the post order(left right parent):\r\ni.e. debfgca.\r\nSo, option (D) is correct.",
    "Concept": "Tree",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 164,
    "Question Text": "Level order Traversal of a rooted Tree can be done by starting from root and performing:",
    "Option A": "Breadth First Search",
    "Option B": "Depth First Search",
    "Option C": "Root Search",
    "Option D": "Deep Search",
    "Correct Answer": "B",
    "Explanation": "Level order Traversal of a rooted Tree can be done by starting from root and performing Breadth First Search.\r\nFor more information on Level order Traversal Refer:Level Order Tree Traversal\r\nOption (A) is correct.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 165,
    "Question Text": "The in-order traversal of a tree resulted in FBGADCE. Then the pre-order traversal of that tree would result in",
    "Option A": "FGBDECA",
    "Option B": "ABFGCDE",
    "Option C": "BFGCDEA",
    "Option D": "AFGBDEC",
    "Correct Answer": "C",
    "Explanation": "The Inorder traversal of the tree can be seen as:\r\n\r\n\r\n\r\nSo, the preorder traversal of the following tree is ABFGCDE.\r\n\r\nOption (B) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 166,
    "Question Text": "Suppose the numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree. The binary search tree uses the usual ordering on natural numbers. What is the inorder traversal sequence of the resultant tree?",
    "Option A": "7 5 1 0 3 2 4 6 8 9",
    "Option B": "0 2 4 3 1 6 5 9 8 7",
    "Option C": "0 1 2 3 4 5 6 7 8 9",
    "Option D": "9 8 6 4 2 3 0 1 5 7",
    "Correct Answer": "D",
    "Explanation": "The numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree with the usual ordering on natural numbers. The inorder sequence of such a binary search tree always yields to the numbers arranged in ascending order. \r\nSo, option (C) is correct.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 167,
    "Question Text": "Assume that the operators +, \u2212, \u00d7 are left associative and ^ is right associative. The order of precedence (from highest to lowest) is ^, \u00d7, +, \u2212. The postfix expression corresponding to the infix expression is\r\na + b \u00d7 c \u2212 d ^ e ^ f",
    "Option A": "abc x  + def ^ ^ \u2212",
    "Option B": "abc x + de ^ f ^ \u2212",
    "Option C": "ab + c \u00d7 d \u2212 e^f^",
    "Option D": "\u2212 + a \u00d7 b c^^ def",
    "Correct Answer": "B",
    "Explanation": "The postfix expression:\r\r\na + b \u00d7 c \u2212 ( d ^( e ^ f))\r\na + b \u00d7 c \u2212 ( d ^( e f ^ ))\r\na + b \u00d7 c \u2212 ( d e f ^ ^)\r\n(a + (b \u00d7 c)) \u2212 d  e f ^ ^\r\n(a + (b c x)) \u2212 d  e f ^ ^\r\n(a (b c x) +) \u2212 d  e f ^ ^\r\n(a b c x +) - (d e f ^ ^)\r\n(a b c x +) - (d e f ^ ^)\r\na b c x + d e f ^ ^ -\r\n\n\r\rSo, option (A) is correct.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 168,
    "Question Text": "If Tree-1 and Tree-2 are the trees indicated below :  Which traversals of Tree-1 and Tree-2, respectively, will produce the same sequence?",
    "Option A": "Preorder, postorder",
    "Option B": "Postorder, inorder",
    "Option C": "Postorder, preorder",
    "Option D": "Inorder, preorder",
    "Correct Answer": "C",
    "Explanation": "Postorder, Inorder will be correct answer here.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 169,
    "Question Text": "If all the edge weights of an undirected graph are positive, then any subset of edges that connects all the vertices and has minimum total weight is a\r\n\r\n&nbsp;",
    "Option A": "Hamiltonian cycle",
    "Option B": "grid",
    "Option C": "hypercube",
    "Option D": "tree",
    "Correct Answer": "E",
    "Explanation": "&nbsp;\r\n\r\nAs here we want subset of edges that connects all the vertices and has minimum total weight i.e. Minimum Spanning Tree\r\nOption A - includes cycle, so may or may not connect all edges.\r\nOption B - has no relevance to this question.\r\nOption C - includes cycle, so may or may not connect all edges.\r\n\r\nRelated:\r\nhttp://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/\r\nhttp://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/\r\n\r\nThis solution is contributed by Mohit Gupta.\r\n\r\n&nbsp;",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 170,
    "Question Text": "The following three are known to be the preorder, inorder and postorder sequences of a binary tree. But it is not known which is which.\r\nMBCAFHPYK\r\nKAMCBYPFH\r\nMABCKYFPH\r\nPick the true statement from the following.",
    "Option A": "I and II are preorder and inorder sequences, respectively",
    "Option B": "I and III are preorder and postorder sequences, respectively",
    "Option C": "II is the inorder sequence, but nothing more can be said about the other two sequences",
    "Option D": "II and III are the preorder and inorder sequences, respectively",
    "Correct Answer": "E",
    "Explanation": "The approach to solve this question is to first find 2 sequences whose first and last element is same. The reason being first element in the Pre-order of any binary tree is the root and last element in the Post-order of any binary tree is the root.\r\nLooking at the sequences given, \r\nPre-order \u00a0\u00a0= \u00a0\u00a0KAMCBYPFH\r\nPost-order \u00a0= \u00a0MBCAFHPYK\r\nLeft-over sequence \u00a0MABCKYFPH will be in order.\r\nSince we have all the traversals identified, let's try to draw the binary tree if possible.\r\n\r\n\r\n\r\nI. Post order\r\nII. Pre order\r\nIII. Inorder\r\n\r\n\r\nThis solution is contributed by Pranjul Ahuja.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 171,
    "Question Text": "When searching for the key value 60 in a binary search tree, nodes containing the key values 10, 20, 40, 50, 70 80, 90 are traversed, not necessarily in the order given. How many different orders are possible in which these key values can occur on the search path from the root to the node containing the value 60?",
    "Option A": "35",
    "Option B": "64",
    "Option C": "128",
    "Option D": "5040",
    "Correct Answer": "B",
    "Explanation": "There are two set of values, smaller than 60 and greater than 60. Smaller values 10, 20, 40 and 50 are visited, means they are visited in order. Similarly, 90, 80 and 70 are visited in order. \r\n= 7!/(4!3!)\r\n= 35",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 172,
    "Question Text": "Which of the following is true about Binary Trees?",
    "Option A": "Every binary tree is either complete or full.",
    "Option B": "Every complete binary tree is also a full binary tree.",
    "Option C": "Every full binary tree is also a complete binary tree.",
    "Option D": "No binary tree is both complete and full.",
    "Correct Answer": "F",
    "Explanation": "A full binary tree (sometimes proper binary tree or 2-tree or strictly binary tree) is a tree in which every node other than the leaves has two children. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. A) is incorrect. For example, the following Binary tree is neither complete nor full     12\n   /  \n  20\n /\n30\nB) is incorrect. The following binary tree is complete but not full     12\n   /   \\\\\n  20    30\n /\n30\nC) is incorrect. Following Binary tree is full, but not complete     12\n   /   \\\\\n  20    30\n       /  \\\\  \n      20   40\nD) is incorrect. Following Binary tree is both complete and full      12\n    /   \\\\\n   20    30\n  /  \\\\  \n 10   40",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 173,
    "Question Text": "If arity of operators is fixed, then which of the following notations can be used to parse expressions without parentheses? a) Infix Notation (Inorder traversal of a expression tree) b) Postfix Notation (Postorder traversal of a expression tree) c) Prefix Notation (Preorder traversal of a expression tree)",
    "Option A": "b and c",
    "Option B": "Only b",
    "Option C": "a, b and c",
    "Option D": "None of them",
    "Correct Answer": "B",
    "Explanation": "Preorder and Postorder notations are used to parse expressions without parentheses.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 174,
    "Question Text": "What are the main applications of tree data structure?Manipulate hierarchical data&nbsp;Make information easy to search &nbsp;Manipulate sorted lists of data&nbsp;Router algorithms&nbsp;Form of a multi-stage decision-making, like Chess Game.&nbsp;As a workflow for compositing digital images for visual effects",
    "Option A": "1, 2, 3, 4 and 6",
    "Option B": "1, 2, 3, 4 and 5",
    "Option C": "1, 3, 4, 5 and 6",
    "Option D": "1, 2, 3, 4, 5 and 6",
    "Correct Answer": "E",
    "Explanation": "Tree data structure is used to study or tabulate hierarchical data. Searching of data becomes easy using the tree traversals. Using BST we can easily analyze sorted data. Decision making to reach an objective becomes easy due to decision tree creation. Trees are used in router algorithms. They can be beneficial as a workflow for compositing digital images for visual effects.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 175,
    "Question Text": "Level of a node is distance from root to that node. For example, level of root is 1 and levels of left and right children of root is 2. The maximum number of nodes on level i of a binary tree is \r\n\r\nIn the following answers, the operator '^' indicates power.",
    "Option A": "2^(i-1)",
    "Option B": "2^i",
    "Option C": "2^(i+1)",
    "Option D": "2^[(i+1)/2]",
    "Correct Answer": "B",
    "Explanation": "Number of nodes of binary tree will be maximum only when tree is full complete, therefore answer is 2^(i)-1\r\nSo, option (A) is true.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 176,
    "Question Text": "In a complete k-ary tree, every internal node has exactly k children or no child. The number of leaves in such a tree with n internal nodes is:",
    "Option A": "nk",
    "Option B": "(n \u2013 1) k+ 1",
    "Option C": "n( k \u2013 1) + 1",
    "Option D": "n(k \u2013 1)",
    "Correct Answer": "D",
    "Explanation": "For an k-ary tree where each node has k children or no children, following relation holds\rL = (k-1)*n + 1\r\rWhere L is the number of leaf nodes and n is the number of internal nodes.\r\rLet us see following for example \r\n             o\r\n        /    |    \\\\\r\n      o      o      o\r\n   / | \\\\          / | \\\\\r\n  o  o  o        o  o  o\r\n                  / | \\\\\r\n                 o  o  o\r\n\r\nk = 3\r\nNumber of internal nodes n = 4\r\nNumber of leaf nodes = (k-1)*n  + 1\r\n                     = (3-1)*4 + 1\r\n                     = 9",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 177,
    "Question Text": "The maximum number of binary trees that can be formed with three unlabelled nodes is:",
    "Option A": "1",
    "Option B": "5",
    "Option C": "4",
    "Option D": "3",
    "Correct Answer": "C",
    "Explanation": "Certainly, here's the revised presentation of the unlabeled binary trees:&nbsp;Note that nodes are unlabeled. If the nodes are labeled, we get more trees. We can find the number of binary tree by Catalan numbers. Here n = 3 Number of binary tree = (2nCn)/ n+1 = (2*3C3)/ 3+1 = 5. So, option (B) is correct.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 178,
    "Question Text": "The number of leaf nodes in a rooted tree of n nodes, with each node having 0 or 3 children is:",
    "Option A": "n/2",
    "Option B": "(n-1)/3",
    "Option C": "(n-1)/2",
    "Option D": "(2n+1)/3",
    "Correct Answer": "E",
    "Explanation": "In a tree with nodes, some having 0 or 3 children:Let's call:n - as the total number of nodes.L -the number of leaf nodes.I - as the number of internal nodes.Now, here's the deal: each internal node with 3 children gives us 2 internal nodes and 1 leaf node. The root node doesn't play a role here, so we can say (L = 2I + 1).And we know that the total number of nodes n is just the sum of leaf nodes L and internal nodes I: n = L + INow, if we substitute the L value from the first equation into the second one, we get n = (2I + 1) + I, which simplifies to n = 3I + 1.Solving this for I, we find I = (n-1)/3Now, plug this back into the L equation, and we get L = 2((n-1)/3) + 1, which simplifies to L = (2n+1)/3.So, in simple terms, the number of leaf nodes L in a tree with nodes having 0 or 3 children is (2n+1)/3.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 179,
    "Question Text": "A weight-balanced tree is a binary tree in which for each node. The number of nodes in the left sub tree is at least half and at most twice the number of nodes in the right sub tree. The maximum possible height (number of nodes on the path from the root to the farthest leaf) of such a tree on n nodes is best described by which of the following? a) \\\\log_2 n b) \\\\log_{4/3} n c) \\\\log_3 n d) \\\\log_{3/2} n",
    "Option A": "A",
    "Option B": "B",
    "Option C": "C",
    "Option D": "D",
    "Correct Answer": "E",
    "Explanation": "A weight-balanced tree is a binary tree where the number of nodes in the left subtree is at least half and at most twice the number of nodes in the right subtree for each node. To determine the maximum possible height of such a tree on n nodes, let's analyze the options:a) &nbsp;This represents the height of a perfectly balanced binary tree. In a weight-balanced tree, the left subtree can have at most twice the number of nodes in the right subtree, so it won't necessarily be perfectly balanced. Therefore, option a is not the best description.b)This option seems to be a non-standard logarithmic base. It's not a common logarithmic base used in tree height analysis. It is not a typical representation for the height of a binary tree.c) This represents the height of a perfectly balanced ternary tree. Similar to option a, this doesn't consider the constraints of a weight-balanced tree.d) &nbsp;This option is interesting because it suggests a growth factor in the number of nodes in the left subtree compared to the right subtree. It is a non-standard base but seems to reflect the constraints of a weight-balanced tree.In a weight-balanced tree, the number of nodes in the left subtree is at least half and at most twice the number of nodes in the right subtree. Therefore, option (d) is the best description of the maximum possible height of a weight-balanced tree on n nodes.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 180,
    "Question Text": "A complete n-ary tree is a tree in which each node has n children or no children. Let I be the number of internal nodes and L be the number of leaves in a complete n-ary tree. If L = 41, and I = 10, what is the value of n?",
    "Option A": "6",
    "Option B": "3",
    "Option C": "4",
    "Option D": "5",
    "Correct Answer": "E",
    "Explanation": "For an n-ary tree where each node has n children or no children, following relation holds\r    L = (n-1)*I + 1\n\rWhere L is the number of leaf nodes and I is the number of internal nodes.\r\rLet us find out the value of n for the given data.\r  L = 41 , I = 10\r\n  41 = 10*(n-1) + 1\r\n  (n-1) = 4\r\n  n = 5",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 181,
    "Question Text": "The height of a binary tree is the maximum number of edges in any root to leaf path. The maximum number of nodes in a binary tree of height h is:",
    "Option A": "2^h -1",
    "Option B": "2^(h-1) \u2013 1",
    "Option C": "2^(h+1) -1",
    "Option D": "2*(h+1)",
    "Correct Answer": "D",
    "Explanation": "Maximum number of nodes will be there for a complete tree.\r\nNumber of nodes in a complete tree of height h = 1 + 2 + 2^2 + 2*3 + \u2026. 2^h = 2^(h+1) \u2013 1",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 182,
    "Question Text": "A scheme for storing binary trees in an array X is as follows. Indexing of X starts at 1 instead of 0. the root is stored at X[1]. For a node stored at X[i], the left child, if any, is stored in X[2i] and the right child, if any, in X[2i+1]. To be able to store any binary tree on n vertices the minimum size of X should be. (GATE CS 2006)",
    "Option A": "log2n",
    "Option B": "n",
    "Option C": "2n + 1",
    "Option D": "2^n \u2014 1",
    "Correct Answer": "E",
    "Explanation": "For a right skewed binary tree, number of nodes will be 2^n -  1.  For example, in below binary tree, node 'A' will be stored at index 1, 'B' at index 3, 'C' at index 7 and 'D' at index 15.\r\nA\r\n \\\r\n   \\\r\n    B\r\n      \\\r\n        \\\r\n         C\r\n           \\\r\n             \\\r\n              D",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 183,
    "Question Text": "Postorder traversal of a given binary search tree, T produces the following sequence of keys \r\n        10, 9, 23, 22, 27, 25, 15, 50, 95, 60, 40, 29\r\nWhich one of the following sequences of keys can be the result of an in-order traversal of the tree T? (GATE CS 2005)",
    "Option A": "9, 10, 15, 22, 23, 25, 27, 29, 40, 50, 60, 95",
    "Option B": "9, 10, 15, 22, 40, 50, 60, 95, 23, 25, 27, 29",
    "Option C": "29, 15, 9, 10, 25, 22, 23, 27, 40, 60, 50, 95",
    "Option D": "95, 50, 60, 40, 27, 23, 22, 25, 10, 9, 15, 29",
    "Correct Answer": "B",
    "Explanation": "Inorder traversal of a BST always gives elements in increasing order.  Among all four options, a) is the only increasing order sequence.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 184,
    "Question Text": "Consider the following nested representation of binary trees: (X Y Z) indicates Y and Z are the left and right sub stress, respectively, of node X. Note that Y and Z may be NULL, or further nested. Which of the following represents a valid binary tree?",
    "Option A": "(1 2 (4 5 6 7))",
    "Option B": "(1 (2 3 4) 5 6) 7)",
    "Option C": "(1 (2 3 4)(5 6 7))",
    "Option D": "(1 (2 3 NULL) (4 5))",
    "Correct Answer": "D",
    "Explanation": "C is fine.\r\r\r\n(1 (2 3 4)(5 6 7))  represents following binary tree\r\n      1\r\n   /    \\\\\r\n  2      5 \r\n / \\\\    / \\\\\r\n3   4  6   7\n\r\r\rA) (1 2 (4 5 6 7)) is not fine as there are 4 elements in one bracket.\r\rB)  (1 (2 3 4) 5 6) 7) is not fine as there are 2 opening brackets and 3 closing.\r\rD)  (1 (2 3 NULL) (4 5)) is not fine one bracket has only two entries (4 5)",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 185,
    "Question Text": "Consider a node X in a Binary Tree.  Given that X has two children, let Y be Inorder successor of X. Which of the following is true about Y?",
    "Option A": "Y has no right child",
    "Option B": "Y has no left child",
    "Option C": "Y has both children",
    "Option D": "None of the above",
    "Correct Answer": "C",
    "Explanation": "Since X has both children, Y must be leftmost node in right child of X.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 186,
    "Question Text": "In a binary tree with n nodes, every node has an odd number of descendants. Every node is considered to be its own descendant. What is the number of nodes in the tree that have exactly one child?",
    "Option A": "0",
    "Option B": "1",
    "Option C": "(n-1)/2",
    "Option D": "n-1",
    "Correct Answer": "B",
    "Explanation": "It is mentioned that each node has odd number of descendants including node itself, so all nodes must have even number of descendants 0, 2, 4 so on.   Which means each node should have either 0 or 2 children. So there will be no node with 1 child.  Hence 0 is answer.\r\rFollowing are few examples. \r\n       a\r\n    /    \\\\\r\n   b      c\r\n\r\n\r\n      a\r\n    /   \\\\\r\n   b     c  \r\n  /  \\\\\r\n d    e\n\r  \r\rSuch a binary tree is full binary tree (a binary tree where every node has 0 or 2 children).",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 187,
    "Question Text": "The height of a binary tree is the maximum number of edges in any root to leaf path. The maximum number of nodes in a binary tree of height h is:",
    "Option A": "2h\u22121",
    "Option B": "2h\u22121 -1",
    "Option C": "2h+1-1",
    "Option D": "2h+1",
    "Correct Answer": "D",
    "Explanation": "See Question 1 http://www.geeksforgeeks.org/data-structures-and-algorithms-set-10/",
    "Concept": "Tree",
    "Difficulty": 0.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.3
  },
  {
    "Question ID": 188,
    "Question Text": "The height of a tree is the length of the longest root-to-leaf path in it. The maximum and minimum number of nodes in a binary tree of height 5 are",
    "Option A": "63 and 6, respectively",
    "Option B": "64 and 5, respectively",
    "Option C": "32 and 6, respectively",
    "Option D": "31 and 5, respectively",
    "Correct Answer": "A",
    "Explanation": "Number of nodes is maximum for a perfect binary tree.A perfect binary tree of height h has 2h+1 - 1 nodesNumber of nodes is minimum for a skewed binary tree.A perfect binary tree of height h has h+1 nodes.So according to the question and after analyzing the options, Option (A) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 189,
    "Question Text": "A binary tree T has 20 leaves. The number of nodes in T having two children is",
    "Option A": "18",
    "Option B": "19",
    "Option C": "17",
    "Option D": "Any number between 10 and 20",
    "Correct Answer": "C",
    "Explanation": "Sum of all degrees = 2 * |E|. Here considering tree as a k-ary tree :\n\nSum of degrees of leaves + Sum of degrees for Internal Node except root + Root's degree = 2 * (No. of nodes - 1).\n\nPutting values of above terms,\n\nL + (I-1)*(k+1) + k = 2 * (L + I - 1)\n\nL + k*I - k + I -1 + k = 2*L + 2I - 2\n\nL + K*I + I - 1 = 2*L + 2*I - 2\n\nK*I + 1 - I = L\n\n(K-1)*I + 1 = L\n\nGiven k = 2, L=20\n\n==&gt; (2-1)*I + 1 = 20\n==&gt; I = 19\n==&gt; T has 19 internal nodes which are having two children.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 190,
    "Question Text": "An array of integers of size n can be converted into a heap by adjusting the heaps rooted at each internal node of the complete binary tree starting at the node \u230a(n - 1) /2\u230b, and doing this adjustment up to the root node (root node is at index 0) in the order \u230a(n - 1)/2\u230b, \u230a(n - 3)/ 2\u230b, ....., 0. The time required to construct a heap in this manner is",
    "Option A": "O(log n)",
    "Option B": "O(n)",
    "Option C": "O (n log log n)",
    "Option D": "O(n log n)",
    "Correct Answer": "C",
    "Explanation": "The above statement is actually&nbsp;algorithm for building a Heap of an input array A.BUILD-HEAP(A) \n    heapsize := size(A); \n    for i := floor(heapsize/2) downto 1 \n        do HEAPIFY(A, i); \n    end for \nEND\nUpper bound of time complexity is O(n) for above algorithm.See- https://www.geeksforgeeks.org/time-complexity-of-building-a-heap/&nbsp;",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 191,
    "Question Text": "In a binary tree, for every node the difference between the number of nodes in the left and right subtrees is at most 2. If the height of the tree is h &gt; 0, then the minimum number of nodes in the tree is:",
    "Option A": "2h - 1",
    "Option B": "2h - 1 + 1",
    "Option C": "2h - 1",
    "Option D": "2h",
    "Correct Answer": "C",
    "Explanation": "Let there be n(h) nodes at height h.\r\n\r\nIn a perfect tree where every node has exactly \r\ntwo children, except leaves, following recurrence holds.\r\n\r\nn(h) = 2*n(h-1) + 1\r\n\r\nIn given case, the numbers of nodes are two less, therefore\r\nn(h) = 2*n(h-1) + 1 - 2\r\n     = 2*n(h-1) - 1\r\n\r\nNow if try all options, only option (b) satisfies above recurrence.\r\n\r\nLet us see option (B)\r\nn(h) = 2h - 1 + 1\r\n\r\nSo if we substitute \r\nn(h-1) = 2h-2 + 1, we should get n(h) = 2h-1 + 1\r\n\r\nn(h) =  2*n(h-1) - 1\r\n     =  2*(2h-2 + 1) -1\r\n     =  2h-1 + 1.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 192,
    "Question Text": "Breadth First Search (BFS) is started on a binary tree beginning from the root vertex. There is a vertex t at a distance four from the root. If t is the n-th vertex in this BFS traversal, then the maximum possible value of n is ________\r\n\r\n[This Question was originally a Fill-in-the-blanks Question]",
    "Option A": "15",
    "Option B": "16",
    "Option C": "31",
    "Option D": "32",
    "Correct Answer": "D",
    "Explanation": "It would be node number 31 for given distance 4.\r\rFor example if we consider at distance 2, below highlighted node G can be the farthest node at position 7.  \r\r\n            A\r\n         /    \\\\\r\n        B       C\r\n       / \\\\     / \\\\\r\n      D   E   F   G\r\n\n\r\rAlternative Solution :\rt is the n-th vertex in this BFS traversal at distance four from the root. So height of tree is 4.\rMax number of nodes = 2^{h+1} \u2212 1 = 2^{5} \u2212 1 = 31\rAt distance four, last node is 31. option (C).",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 193,
    "Question Text": "In a binary tree, the number of internal nodes of degree 1 is 5, and the number of internal nodes of degree 2 is 10. The number of leaf nodes in the binary tree is\r\n\r\n&nbsp;",
    "Option A": "10",
    "Option B": "11",
    "Option C": "12",
    "Option D": "15",
    "Correct Answer": "C",
    "Explanation": "In a binary tree, the number of leaf nodes is always 1 more than number of internal nodes with 2 children, refer http://www.geeksforgeeks.org/handshaking-lemma-and-interesting-tree-properties/\r\nSo,\r\nNumber of Leaf Nodes = Number of Internal nodes with 2 children + 1\r\nNumber of Leaf Nodes = 10 + 1\r\nNumber of Leaf Nodes = 11",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 194,
    "Question Text": "The following three are known to be the preorder, inorder and postorder sequences of a binary tree. But it is not known which is which.\r\nMBCAFHPYK\r\nKAMCBYPFH\r\nMABCKYFPH\r\nPick the true statement from the following.",
    "Option A": "I and II are preorder and inorder sequences, respectively",
    "Option B": "I and III are preorder and postorder sequences, respectively",
    "Option C": "II is the inorder sequence, but nothing more can be said about the other two sequences",
    "Option D": "II and III are the preorder and inorder sequences, respectively",
    "Correct Answer": "E",
    "Explanation": "The approach to solve this question is to first find 2 sequences whose first and last element is same. The reason being first element in the Pre-order of any binary tree is the root and last element in the Post-order of any binary tree is the root.\r\nLooking at the sequences given, \r\nPre-order \u00a0\u00a0= \u00a0\u00a0KAMCBYPFH\r\nPost-order \u00a0= \u00a0MBCAFHPYK\r\nLeft-over sequence \u00a0MABCKYFPH will be in order.\r\nSince we have all the traversals identified, let's try to draw the binary tree if possible.\r\n\r\n\r\n\r\nI. Post order\r\nII. Pre order\r\nIII. Inorder\r\n\r\n\r\nThis solution is contributed by Pranjul Ahuja.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 195,
    "Question Text": "A binary tree with n > 1 nodes has n1, n2 and n3 nodes of degree one, two and three respectively. The degree of a node is defined as the number of its neighbors.\r\n\r\nn3 can be expressed as",
    "Option A": "n1 + n2 - 1",
    "Option B": "n1 - 2",
    "Option C": "[((n1 + n2)/2)]",
    "Option D": "n2 - 1",
    "Correct Answer": "C",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 196,
    "Question Text": "A binary tree with n > 1 nodes has n1, n2 and n3 nodes of degree one, two and three respectively. The degree of a node is defined as the number of its neighbors.\r\n\r\nStarting with the above tree, while there remains a node v of degree two in the tree, add an edge between the two neighbors of v and then remove v from the tree. How many edges will remain at the end of the process?",
    "Option A": "2 * n1 - 3",
    "Option B": "n2 + 2 * n1 - 2",
    "Option C": "n3 - n2",
    "Option D": "n2 + n1 - 2",
    "Correct Answer": "B",
    "Explanation": "With reference to figure of answer of previous question:",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 197,
    "Question Text": "A binary search tree contains the values 1, 2, 3, 4, 5, 6, 7, 8. The tree is traversed in pre-order and the values are printed out. Which of the following sequences is a valid output?",
    "Option A": "53124786",
    "Option B": "53126487",
    "Option C": "53241678",
    "Option D": "53124768",
    "Correct Answer": "E",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 198,
    "Question Text": "In the balanced binary tree in the below figure, how many nodes will become unbalanced when a node is inserted as a child of the node \u201cg\u201d?\r\n         a\r\n       /   \\\\\r\n      b     e\r\n     / \\\\   /\r\n    c  d  f\r\n   /\r\n  g",
    "Option A": "1",
    "Option B": "3",
    "Option C": "7",
    "Option D": "8",
    "Correct Answer": "C",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 199,
    "Question Text": "The number of structurally different possible binary trees with 4 nodes is",
    "Option A": "14",
    "Option B": "12",
    "Option C": "336",
    "Option D": "168",
    "Correct Answer": "B",
    "Explanation": "The total number of structurally different possible binary trees can be found out using the Catalon number which is (2n)!/ (n! *(n+1)!). Here n=4, so, answer is 14.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 200,
    "Question Text": "A strictly binary tree with 10 leaves",
    "Option A": "cannot have more than 19 nodes",
    "Option B": "has exactly 19 nodes",
    "Option C": "has exactly 17 nodes",
    "Option D": "has exactly 20 nodes",
    "Correct Answer": "C",
    "Explanation": "A strict binary tree with \u2018n\u2019 leaf nodes always have \u20182n-1\u2019 intermediate nodes. With 10 leaf nodes a strict binary tree will have exactly 19 nodes. So, option (B) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 201,
    "Question Text": "What is the maximum height of any AVL tree with 7 nodes? Assume that height of tree with single node is 0.",
    "Option A": "2",
    "Option B": "3",
    "Option C": "4",
    "Option D": "5",
    "Correct Answer": "C",
    "Explanation": "Refer: Data Structures and Algorithms | Set 16",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 202,
    "Question Text": "Which one of the following property is correct for a red-black tree?",
    "Option A": "Every simple path from a node to a descendant leaf contains the same number of black nodes",
    "Option B": "If a node is red, then one children is red and another is black",
    "Option C": "If a node is red, then both its children are red",
    "Option D": "Every leaf node (sentinel node) is red",
    "Correct Answer": "B",
    "Explanation": "Refer: Red-Black Tree | Set 1 (Introduction)\r\nOption (A) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 203,
    "Question Text": "Consider a full binary tree with n internal nodes, internal path length i, and external path length e. The internal path length of a full binary tree is the sum, taken over all nodes of the tree, of the depth of each node. Similarly, the external path length is the sum, taken over all leaves of the tree, of the depth of each leaf. Which of the following is correct for the full binary tree?",
    "Option A": "e = i+n",
    "Option B": "e = i+2n",
    "Option C": "e = 2i+n",
    "Option D": "e = 2n+i",
    "Correct Answer": "C",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 204,
    "Question Text": "The order of a leaf node in a B+ tree is the maximum number of children it can have. Suppose that block size is 1 kilobytes, the child pointer takes 7 bytes long and search field value takes 14 bytes long. The order of the leaf node is ________.",
    "Option A": "16",
    "Option B": "63",
    "Option C": "64",
    "Option D": "68",
    "Correct Answer": "B",
    "Explanation": "Key size = 14 bytes (given)\r\n\r\nChild pointer = 7 bytes (given)\r\n\r\nWe assume the order of B+ tree to be \u2018n\u2019.\r\n\r\nBlock size >= (n \u2013 1) * key size + n * child pointer\r\n512 >= (n \u2013 1) * 14 + n * 7\r\n512 >= 14 * n \u2013 14 + 7 * n \r\nn <= (1024 + 14) / 20\r\nn <= 1038 / 21\r\nn <= 49.42\r\n\n\rSo, option (A) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 205,
    "Question Text": "A complete binary tree with n non-leaf nodes contains",
    "Option A": "log2 n nodes",
    "Option B": "n+1 nodes",
    "Option C": "2n nodes",
    "Option D": "2n+1 nodes",
    "Correct Answer": "E",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 206,
    "Question Text": "Suppose you are given a binary tree with n nodes, such that each node has exactly either zero or two children. The maximum height of the tree will be",
    "Option A": "n / 2  - 1",
    "Option B": "n / 2  + 1",
    "Option C": "(n \u2013 1) / 2",
    "Option D": "(n + 1) / 2",
    "Correct Answer": "D",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 207,
    "Question Text": "The number of different binary trees with 6 nodes is ______.",
    "Option A": "6",
    "Option B": "42",
    "Option C": "132",
    "Option D": "256",
    "Correct Answer": "D",
    "Explanation": "The number of different binary trees with 6 nodes is fact(2n) / fact(n+1) * fac(n) where n is no nodes:\rIf n= 6, then  fact(2 * n) / fact(n+1) * fac(n) \r\n= fact(2 * 6) / fact(6 + 1) * fact(6) \r\n= fact(12) / fact(7) * fact(6) \r\n= 12 * 11 * 10 * 9 * 8 * fact(7) / fact(7) * fact(6) \r\n= 12 * 11 * 10 * 9 * 8  / 6 * 5 * 4 * 3 * 2 \r\n= 6 * 11 * 2 \r\n= 132.\n\rSo, option (C) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 208,
    "Question Text": "Which of the following number of nodes can form a full binary tree?",
    "Option A": "8",
    "Option B": "15",
    "Option C": "14",
    "Option D": "13",
    "Correct Answer": "C",
    "Explanation": "a full binary tree is a binary tree in which all nodes except leaves have two children. In a Full Binary, number of leaf nodes is number of internal nodes plus 1 L = I + 1 Where L = Number of leaf nodes, I = Number of internal nodes So, option (B) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 209,
    "Question Text": "A complete binary tree with the property that the value at each node is as least as large as the values at its children is known as",
    "Option A": "Binary search tree",
    "Option B": "AVL tree",
    "Option C": "Completely balanced tree",
    "Option D": "Heap",
    "Correct Answer": "E",
    "Explanation": "In a Max. Binary Heap, the key value at each node is as least as large as the values at its children. Similarly in Min Binary Heap, the key at root must be minimum among all keys present in Binary Heap. So, correct option is (D).",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 210,
    "Question Text": "A full binary tree with n leaves contains",
    "Option A": "n nodes",
    "Option B": "log 2 n nodes",
    "Option C": "2n \u20131 node",
    "Option D": "2 n nodes",
    "Correct Answer": "D",
    "Explanation": "A Binary Tree is full if every node has 0 or 2 children. Following are examples of full binary tree. We can also say a full binary tree is a binary tree in which all nodes except leaves have two children. A full binary tree with n leaves contains  2 * n \u2013 1 nodes.\r\nSo, option (C) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 211,
    "Question Text": "Any decision tree that sorts n elements has height",
    "Option A": "\u03a9(n)",
    "Option B": "\u03a9(lgn)",
    "Option C": "\u03a9(nlgn)",
    "Option D": "\u03a9(n2)",
    "Correct Answer": "B",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 212,
    "Question Text": "Find the inorder and postorder of the binary tree with the given preorder:\r\n60, 40, 20, 10, 30, 33, 50, 44, 51, 90, 70, 65, 80, 110, 100, 95, 99, 120.",
    "Option A": "In order: 110, 100, 99, 90, 80, 70, 65, 60, 51, 50, 44, 40, 33, 30, 20, 10.\rPostorder: 110, 120, 100, 95, 99, 70, 80, 65, 60, 40, 50, 51, 44, 20, 30,  33, 10",
    "Option B": "Inorder: 10, 20, 30, 33, 40,  44, 50, 51, 60,  65, 70,  80,  90, 95,  99, 100, 110, 120\rPostorder: 10, 33, 30, 20, 44, 51, 50, 40,  65, 80, 70, 99, 95, 100, 120, 110, 90, 60",
    "Option C": "In order: 10, 33, 30, 20, 44, 51, 50, 40, 60, 65, 80, 70, 99, 95, 100, 120, 110,\rPostorder: 10, 20, 30, 33, 40,  44, 50, 51, 60,  65, 70,  80,  90, 95,  99, 100, 110",
    "Option D": "In order: 10, 33, 30, 20, 44, 51, 60,  65, 80, 70, 99, 95, 100, 120, 110,\rPostorder: 110, 100, 99, 90, 80, 70, 65, 60, 51, 50, 44, 40, 33, 30, 20, 10.",
    "Correct Answer": "C",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 213,
    "Question Text": "A binary search tree in which every non-leaf node has non-empty left and right subtrees is called a strictly binary tree. Such a tree with 19 leaves :",
    "Option A": "cannot have more than 37 nodes",
    "Option B": "has exactly 37 nodes",
    "Option C": "has exactly 35 nodes",
    "Option D": "cannot have more than 35 nodes",
    "Correct Answer": "C",
    "Explanation": "2(n)-1 where n is the for the leaves nodes. So by that way we have exactly 37 nodes.\r\n\r\nOption (B) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 214,
    "Question Text": "Consider a complete binary tree with 7 nodes. Let A denote the set of first 3 elements obtained by performing Breadth-First Search (BFS) starting from the root. Let B denote the set of first 3 elements obtained by performing Depth-First Search (DFS) starting from the root.  The value of \u2223A\u2212B\u2223 is _____________ .",
    "Option A": "1",
    "Option B": "2",
    "Option C": "3",
    "Option D": "4",
    "Correct Answer": "A",
    "Explanation": "In case of BFS if we draw complete binary tree then in Set A we have level1+level2. In DFS we have level1+ level 2 + level 3. Level 1 = 1 element, level 2 = 2 elements, level 3= 4 elements. Total of 7 elements. Set A have: Level 1 = 1st element, Level 2 = 2nd &amp; 3rd element.Set B have: Level 1 = 1 element, level 2 = 2nd element, level 3= 3rd element.L1 x 1 element from L2 (A \u2229 B) Element in A not in B.So A-B= remaining element of level 2. |A - B = 1|",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 215,
    "Question Text": "Which of the following sequences denotes the post order traversal sequence of the given tree?\r\n         a\r\n       /   \\\\\r\n      b     e\r\n     / \\\\   /\r\n    c  d  f\r\n   /\r\n  g",
    "Option A": "f e g c d b a",
    "Option B": "g c b d a f e",
    "Option C": "g c d b f e a",
    "Option D": "f e d g c b a",
    "Correct Answer": "D",
    "Explanation": "",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 216,
    "Question Text": "The in-order and pre-order traversal of a binary tree are d b e a f c g and a b d e c f g respectively. The post order traversal of a binary tree is",
    "Option A": "e d b g f c a",
    "Option B": "e d b f g c a",
    "Option C": "d e b f g c a",
    "Option D": "d e f g b c a",
    "Correct Answer": "D",
    "Explanation": "Refer:  GATE-CS-2007 | Question 39 \r\n\r\nOption (C) is correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 217,
    "Question Text": "Consider an array representation of an n element binary heap where the elements are stored from index 1 to index n of the array. For the element stored at index i of the array (i&lt;=n), the index of the parent is:&nbsp;&nbsp;",
    "Option A": "ceiling (i/2)",
    "Option B": "floor (i/2)",
    "Option C": "ceiling ((i+1)/2)",
    "Option D": "floor ((i+1)/2)",
    "Correct Answer": "A",
    "Explanation": "Refer: GATE-CS-2001 | Question 15&nbsp;To find parent of node at i index we have to find floor(i/2).&nbsp;So, option (C) is correct.&nbsp;",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 218,
    "Question Text": "What is the worst-case number of arithmetic operations performed by recursive binary search on a sorted array of size n?",
    "Option A": "\u0398(\u221an)",
    "Option B": "\u0398(log2(n))",
    "Option C": "\u0398(n2)",
    "Option D": "\u0398(n)",
    "Correct Answer": "C",
    "Explanation": "Arithmetic operations performed by binary search on sorted data items means computation of mid element required arithmetic operation. So it will be computed log(n) time and Hence option (C) will be correct.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 219,
    "Question Text": "Consider a binary tree with n nodes, where each node can have at most two children. The height of the tree is defined as the maximum number of edges between the root node and any leaf node. Which of the following statements is true regarding the height h of this binary tree?",
    "Option A": "The height of the tree is always equal to n-1.",
    "Option B": "The height of the tree can be greater than or equal to n-1.",
    "Option C": "The height of the tree is always equal to log\u2082(n).",
    "Option D": "The height of the tree can be greater than or equal to log\u2082(n).",
    "Correct Answer": "C",
    "Explanation": "In a binary tree, the height h represents the longest path from the root node to any leaf node. This path can consist of n-1 edges in the worst case, where each node has exactly one child except for the leaf nodes. However, it's also possible for a binary tree to have a height less than n-1, depending on its structure.Consider a binary tree where each parent node has only one child (left or right) while the other child is null. In this case, the height of the tree will be less than n-1. On the other hand, a balanced binary tree, such as a complete binary tree, can have a height equal to n-1 when it contains the maximum number of nodes.Therefore, option b) is correct, as the height of a binary tree can be greater than or equal to n-1, depending on its structure and the arrangement of nodes.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 222,
    "Question Text": "Consider a complete binary tree where the left and the right subtrees of the root are max-heaps. The lower bound for the number of operations to convert the tree to a heap is",
    "Option A": "\u03a9(logn)",
    "Option B": "\u03a9(n)",
    "Option C": "\u03a9(nlogn)",
    "Option D": "\u03a9(n2)",
    "Correct Answer": "A",
    "Explanation": "The answer to this question is simply max-heapify function.  Time complexity of max-heapify is O(Log n) as it recurses at most through height of heap.  // A recursive method to heapify a subtree with root at given index// This method assumes that the subtrees are already heapifiedvoid MinHeap::MaxHeapify(int i){    int l = left(i);    int r = right(i);    int largest = i;    if (l &lt; heap_size &amp;&amp; harr[l] &lt; harr[i])        largest = l;    if (r &lt; heap_size &amp;&amp; harr[r] &lt; harr[smallest])        largest = r;    if (largest != i)    {        swap(&amp;harr[i], &amp;harr[largest]);        MinHeapify(largest);    }}  See  for details.",
    "Concept": "Tree",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 223,
    "Question Text": "What is the worst case time complexity of inserting n2 elements into an AVL-tree with n elements initially ?",
    "Option A": "\u0398(n4)",
    "Option B": "\u0398(n2)",
    "Option C": "\u0398(n2 log n)",
    "Option D": "\u0398(n3)",
    "Correct Answer": "C",
    "Explanation": "Since AVL tree is balanced tree, the height is O(log n). So, time complexity to insert an element in an AVL tree is O(log n) in worst case.   Note:Every insertion of element:Finding place to insert = O(log n)If property not satisfied (after insertion) do rotation = O(log n)So, an AVL insertion take = O(log n) + O(log n) = O(log n) in worst case.   Now, given n2 element need to insert into given AVL tree, therefore, total time complexity will be O(n2 log n).  Alternative method: Time complexity in worst case, 1st insertion time complexity = O(log n)2nd insertion time complexity = O(log(n+1))...n2th insertion time complexity = O(log(n + n2))  So, total time complexity will be, = O(log n) +  O(log n+1)) + .... +  O(log(n + n2))= O(log n*(n+1)*(n+2)*...(n+n2))= O(log nn2)= O(n2 log n)   Option (C) is correct.",
    "Concept": "Tree",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 224,
    "Question Text": "The degree sequence of a simple graph is the sequence of the degrees of the nodes in the graph in decreasing order. Which of the following sequences can not be the degree sequence of any graph?&nbsp;&nbsp;I. 7, 6, 5, 4, 4, 3, 2, 1\nII. 6, 6, 6, 6, 3, 3, 2, 2\nIII. 7, 6, 6, 4, 4, 3, 2, 2\nIV. 8, 7, 7, 6, 4, 2, 1, 1 \n&nbsp;",
    "Option A": "I and II",
    "Option B": "III and IV",
    "Option C": "IV only",
    "Option D": "II and IV",
    "Correct Answer": "E",
    "Explanation": "Both II and IV cannot be the degree sequence of any graph.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 225,
    "Question Text": "The time complexity of computing the transitive closure of a binary relation on a set of n elements is known to be:",
    "Option A": "O(n)",
    "Option B": "O(nLogn)",
    "Option C": "O(n ^ (3/2))",
    "Option D": "O(n^3)",
    "Correct Answer": "E",
    "Explanation": "The time complexity of computing the transitive closure of a binary relation on a set of n elements is O(n^3) using the Floyd-Warshall algorithm.",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 226,
    "Question Text": "The most efficient algorithm for finding the number of connected components in an undirected graph on n vertices and m edges has time complexity.",
    "Option A": "theta(n)",
    "Option B": "theta(m)",
    "Option C": "theta(m + n)",
    "Option D": "theta(mn)",
    "Correct Answer": "D",
    "Explanation": "Connected components can be found in O(m + n) using Tarjan's algorithm. Once we have connected components, we can count them.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 227,
    "Question Text": "Consider an undirected unweighted graph G. Let a breadth-first traversal of G be done starting from a node r. Let d(r, u) and d(r, v) be the lengths of the shortest paths from r to u and v respectively, in G. lf u is visited before v during the breadth-first traversal, which of the following statements is correct?",
    "Option A": "d(r, u) &lt; d (r, v)",
    "Option B": "d(r, u) &gt; d(r, v)",
    "Option C": "d(r, u) &lt;= d (r, v)",
    "Option D": "None of the above",
    "Correct Answer": "D",
    "Explanation": "d(r, u) and d(r, v) will be equal when u and v are at same level, otherwise d(r, u) will be less than d(r, v)",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 228,
    "Question Text": "How many undirected graphs (not necessarily connected) can be constructed out of a given set V= {V 1, V 2,\u2026V n} of n vertices ?",
    "Option A": "n(n-l)/2",
    "Option B": "2^n",
    "Option C": "n!",
    "Option D": "2^(n(n-1)/2)",
    "Correct Answer": "E",
    "Explanation": "In an undirected graph, there can be maximum n(n-1)/2 edges. We can choose to have (or not have) any of the n(n-1)/2 edges.  So, total number of undirected graphs with n vertices is 2^(n(n-1)/2).",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 229,
    "Question Text": "Which of the following statements is/are TRUE for an undirected graph?&nbsp;P: The number of odd-degree vertices is even&nbsp;Q: Sum of degrees of all vertices is even",
    "Option A": "P Only",
    "Option B": "Q Only",
    "Option C": "Both P and Q",
    "Option D": "Neither P nor Q",
    "Correct Answer": "D",
    "Explanation": "P is true for undirected graph as adding an edge always increases degree of two vertices by 1. Q is true: If we consider sum of degrees and subtract all even degrees, we get an even number because every edge increases the sum of degrees by 2. So total number of odd degree vertices must be even.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 230,
    "Question Text": "Consider an undirected random graph of eight vertices. The probability that there is an edge between a pair of vertices is 1/2. What is the expected number of unordered cycles of length three?",
    "Option A": "01-Aug",
    "Option B": "1",
    "Option C": "7",
    "Option D": "8",
    "Correct Answer": "D",
    "Explanation": "A cycle of length 3 can be formed with 3 vertices. There can be total 8C3 ways to pick 3 vertices from 8. The probability that there is an edge between two vertices is 1/2. So expected number of unordered cycles of length 3 = (8C3)*(1/2)^3 = 7",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 231,
    "Question Text": "In which scenario would a directed acyclic graph (DAG) be most suitable?",
    "Option A": "Representing dependencies between tasks in a project schedule",
    "Option B": "Modeling a social network with friend connections",
    "Option C": "Finding the shortest path between two nodes in a weighted graph",
    "Option D": "Performing breadth-first search (BFS) on a graph",
    "Correct Answer": "B",
    "Explanation": "Directed acyclic graphs (DAGs) are commonly used to represent dependencies between tasks in a project schedule. DAGs ensure that the tasks are organized in a way that no cycles exist, allowing for efficient scheduling and task sequencing.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 232,
    "Question Text": "How many undirected graphs (not necessarily connected) can be constructed out of a given set V = {v1, v2, ... vn} of n vertices?",
    "Option A": "n(n-1)/2",
    "Option B": "2n",
    "Option C": "n!",
    "Option D": "2n(n-1)/2",
    "Correct Answer": "E",
    "Explanation": "There are total n*(n-1)/2 possible edges.  For every edge, there are to possible options, either we pick it or don't pick.   So total number of possible graphs is 2n(n-1)/2.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 233,
    "Question Text": "What is the maximum number of edges in an acyclic undirected graph with n\u00a0vertices?",
    "Option A": "n-1",
    "Option B": "n",
    "Option C": "n + 1",
    "Option D": "2n-1",
    "Correct Answer": "B",
    "Explanation": "n * (n - 1) / 2 when cyclic. But acyclic graph with the maximum number of edges is actually a spanning tree and therefore, correct answer is n-1 edges.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 234,
    "Question Text": "Q84 Part_B\r\n\r\nA sink in a directed graph is a vertex i such that there is an edge from every vertex j \u2260 i to i and there is no edge from i to any other vertex. A directed graph G with n vertices is represented by its adjacency matrix A, where A[i] [j] = 1 if there is an edge directed from vertex i to j and 0 otherwise. The following algorithm determines whether there is a sink in the graph G.\r\n\r\ni = 0\r\ndo {\r\n    j = i + 1;\r\n    while ((j < n) && E1) j++;\r\n    if (j < n) E2;\r\n} while (j < n);\r\n\r\nflag = 1;\r\nfor (j = 0; j < n; j++)\r\n    if ((j! = i) && E3)\r\n        flag = 0;\r\n\r\nif (flag)\r\n    printf(\"Sink exists\");\r\nelse\r\n    printf(\"Sink does not exist\");\r\n\r\n\r\nChoose the correct expressions for\u00a0E3\r\n\r\n&nbsp;",
    "Option A": "(A[i][j] && !A[j][i])",
    "Option B": "(!A[i][j] && A[j][i])",
    "Option C": "(!A[i][j] | | \u00a0A[j][i])",
    "Option D": "(A[i][j] | | !A[j][i])",
    "Correct Answer": "E",
    "Explanation": "Below explanation is for Previous Part of this question:\r\nFor vertex i to be a sink, there should be no edge from i to any other vertex.\r\n\r\n\r\n\r\nAccording the input given in question,\r\n\r\nA[i][j] = 1 means there is an edge from vertex i to j.\r\nA[i][j] = 0 means there is no edge from i to j\r\n\r\n\r\nFor a node to i to be sink, \r\nA[i][j] should be 0 for all j \r\nA[j][i] should be 1 for all j.\r\n\r\n\r\nThe above pseudo code checks every vertex i for sink, starting from i = 0.  It basically checks every vertex j after i for being a sink.  The trick in pseudo code is, it doesn't check for j smaller than i.  The i picked by this loop may not be sink. It basically makes sure that we don't ignore a potential sink.  The check whether i is actually a sink or not is done later after do while loop.\r\n\r\nVertex i is a potential sink while A[i][j] is zero \r\nThus, E1 : !A[i][j] \r\n\r\nIf the above condition is false, then i is not a sink. All j < i can also not be a sink because there is no edge from i to j.\r\nNow, the next potential sink can be j. \r\nSo, E2 : i = j\r\n\r\nExplanation for this question\r\nThe following pseudo code basically checks if the potential sink picked by the code above is actually a sink or not.\r\n\r\nflag = 1;\r\nfor (j = 0; j < n; j++)\r\n    if ((j! = i) && E3)\r\n        flag = 0;\r\n\r\n\r\nflag equals to 0 means i is not a sink. The code sets the flag 0 as soon as it finds out that i is not a sink.\r\n\r\nA node i is not a sink if either of the following \r\ntwo conditions become true for any j not equal to i.\r\nA[i][j] is 1 for any j \r\nOR\r\nA[j][i] is 0 for any j\r\n\r\nE3 : (A[i][j] | | !A[j][i])\r\n\r\nTherefore option D is correct",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 235,
    "Question Text": "Q85 &nbsp;Part_A  Consider a simple graph with unit edge costs. Each node in the graph represents a router. Each node maintains a routing table indicating the next hop router to be used to relay a packet to its destination and the cost of the path to the destination through that router. Initially, the routing table is empty. The routing table is synchronously updated as follows. In each updation interval, three tasks are performed.  A node determines whether its neighbours in the graph are accessible. If so, it sets the tentative cost to each accessible neighbour as 1. Otherwise, the cost is set to \u221e. From each accessible neighbour, it gets the costs to relay to other nodes via that neighbour (as the next hop). Each node updates its routing table based on the information received in the previous two steps by choosing the minimum cost.   For the graph given above, possible routing tables for various nodes after they have stabilized, are shown in the following options. Identify the correct table.   \n\n\n1)\nTable for node A\n\n\n\n&nbsp;A\n&nbsp;-\n&nbsp;-\n\n\n&nbsp;B\n&nbsp;B\n&nbsp;1\n\n\n&nbsp;C\n&nbsp;C\n&nbsp;1\n\n\n&nbsp;D\n&nbsp;B\n&nbsp;3\n\n\n&nbsp;E\n&nbsp;C\n&nbsp;3\n\n\n&nbsp;F\n&nbsp;C\n&nbsp;4\n\n\n    2) Table for node C\n   &nbsp;A &nbsp;A &nbsp;1   &nbsp;B &nbsp;B &nbsp;1   &nbsp;C &nbsp;- &nbsp;-   &nbsp;D &nbsp;D &nbsp;1   &nbsp;E &nbsp;E &nbsp;1   &nbsp;F &nbsp;E &nbsp;3        3) Table for node B\n   &nbsp;A &nbsp;A &nbsp;1   &nbsp;B &nbsp;- &nbsp;-   &nbsp;C &nbsp;C &nbsp;1   &nbsp;D &nbsp;D &nbsp;1   &nbsp;E &nbsp;C &nbsp;2   &nbsp;F &nbsp;D &nbsp;2       4) Table for node D\n   &nbsp;A &nbsp;B &nbsp;3   &nbsp;B &nbsp;B &nbsp;1   &nbsp;C &nbsp;C &nbsp;1   &nbsp;D &nbsp;- -   &nbsp;E &nbsp;E &nbsp;1   &nbsp;F &nbsp;F &nbsp;1",
    "Option A": "A",
    "Option B": "B",
    "Option C": "C",
    "Option D": "D",
    "Correct Answer": "C",
    "Explanation": "&nbsp;  This solution is contributed by Sandeep Pandey.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 236,
    "Question Text": "Q85 Part_B\r\n\r\nConsider a simple graph with unit edge costs. Each node in the graph represents a router. Each node maintains a routing table indicating the next hop router to be used to relay a packet to its destination and the cost of the path to the destination through that router. Initially, the routing table is empty. The routing table is synchronously updated as follows. In each updation interval, three tasks are performed.\r\n\nA node determines whether its neighbours in the graph are accessible. If so, it sets the tentative cost to each accessible neighbour as 1. Otherwise, the cost is set to \u221e.\nFrom each accessible neighbour, it gets the costs to relay to other nodes via that neighbour (as the next hop).\nEach node updates its routing table based on the information received in the previous two steps by choosing the minimum cost.\n\n\nFor the graph given above, possible routing tables for various nodes after they have stabilized, are shown in the following options. Identify the correct table.\n\n\n\n\n\n1)\nTable for node A\r\n\n\n\n\u00a0A\n\u00a0-\n\u00a0-\n\n\n\u00a0B\n\u00a0B\n\u00a01\n\n\n\u00a0C\n\u00a0C\n\u00a01\n\n\n\u00a0D\n\u00a0B\n\u00a03\n\n\n\u00a0E\n\u00a0C\n\u00a03\n\n\n\u00a0F\n\u00a0C\n\u00a04\n\n\n\n\n\n\n2)\nTable for node C\r\n\n\n\n\u00a0A\n\u00a0A\n\u00a01\n\n\n\u00a0B\n\u00a0B\n\u00a01\n\n\n\u00a0C\n\u00a0-\n\u00a0-\n\n\n\u00a0D\n\u00a0D\n\u00a01\n\n\n\u00a0E\n\u00a0E\n\u00a01\n\n\n\u00a0F\n\u00a0E\n\u00a03\n\n\n\n\n\n\n\n3)\nTable for node B\r\n\n\n\n\u00a0A\n\u00a0A\n\u00a01\n\n\n\u00a0B\n\u00a0-\n\u00a0-\n\n\n\u00a0C\n\u00a0C\n\u00a01\n\n\n\u00a0D\n\u00a0D\n\u00a01\n\n\n\u00a0E\n\u00a0C\n\u00a02\n\n\n\u00a0F\n\u00a0D\n\u00a02\n\n\n\n\n\n\n4)\nTable for node D\r\n\n\n\n\u00a0A\n\u00a0B\n\u00a03\n\n\n\u00a0B\n\u00a0B\n\u00a01\n\n\n\u00a0C\n\u00a0C\n\u00a01\n\n\n\u00a0D\n\u00a0-\n-\n\n\n\u00a0E\n\u00a0E\n\u00a01\n\n\n\u00a0F\n\u00a0F\n\u00a01\n\n\n\n\n\n\n\r\nContinuing from the earlier problem, suppose at some time t, when the costs have stabilized, node A goes down. The cost from node F to node A at time (t + 100) is",
    "Option A": ">100 but finite",
    "Option B": "\u221e",
    "Option C": "3",
    "Option D": ">3 and \u2264100",
    "Correct Answer": "B",
    "Explanation": "",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 237,
    "Question Text": "For the undirected, weighted graph given below, which of the following sequences of edges represents a correct execution of Prim's algorithm to construct a Minimum Span\u00adning Tree?\n&nbsp;",
    "Option A": "(a, b), (d, f), (f, c), (g, i), (d, a), (g, h), (c, e), (f, h)",
    "Option B": "(c, e), (c, f), (f, d), (d, a), (a, b), (g, h), (h, f), (g, i)",
    "Option C": "(d, f), (f, c), (d, a), (a, b), (c, e), (f, h), (g, h), (g, i)",
    "Option D": "(h, g), (g, i), (h, f), (f, c), (f, d), (d, a), (a, b), (c, e)",
    "Correct Answer": "D",
    "Explanation": "In prims algorithm we start with any node and keep on exploring minimum cost neighbors of nodes already covered.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 238,
    "Question Text": "Consider a directed graph with n vertices and m edges such that all edges have same edge weights. Find the complexity of the best known algorithm to compute the minimum spanning tree of the graph?",
    "Option A": "O(m+n)",
    "Option B": "O(m logn)",
    "Option C": "O(mn)",
    "Option D": "O(n logm)",
    "Correct Answer": "B",
    "Explanation": "It\u2019s a special case in which all edge weights are equal, so dfs would work and resultant depth first tree would be the spanning tree. So the answer would be O(m+n).",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 239,
    "Question Text": "You are given a graph containing n vertices and m edges and given that the graph doesn\u2019t contain cycle of odd length. Time Complexity of the best known algorithm to find out whether the graph is bipartite or not is ?",
    "Option A": "O(m+n)",
    "Option B": "O(1)",
    "Option C": "O(mn)",
    "Option D": "O(n2)",
    "Correct Answer": "C",
    "Explanation": "It is by definition that a graph is bipartite if it does not contain odd length cycles. So the answer is O(1).For more background reading, check this link&nbsp;https://proofwiki.org/wiki/Graph_is_Bipartite_iff_No_Odd_Cycles",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 240,
    "Question Text": "Let G be a simple graph with 20 vertices and 8 components. If we delete a vertex in G, then number of components in G should lie between ____.",
    "Option A": "8 and 20",
    "Option B": "8 and 19",
    "Option C": "7 and 19",
    "Option D": "7 and 20",
    "Correct Answer": "D",
    "Explanation": "Case 1: If the vertex we are deleting from G is an isolated vertex, which is a component by itself, then number of components in G becomes 7.\r\nCase 2: If G is a start Graph, then by deleting the cut vertex of G, we get 19 components.\r\nHence, number of components in G should lie between 7 and 19.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 241,
    "Question Text": "Let G be the graph with 100 vertices numbered 1 to 100. Two vertices i and j are adjacent if |i\u2212j|=8&nbsp;or |i\u2212j|=12. The number of connected components in G is",
    "Option A": "8",
    "Option B": "4",
    "Option C": "12",
    "Option D": "25",
    "Correct Answer": "C",
    "Explanation": "When vertices are arranged with difference of 12 the number of components is reduced to 4 as first column will be connected with fifth column, second column will be connected with sixth column, third column will be connected with seventh column and fourth column will be connected with eighth column. No other form of connection exists so total 4 connected components are there.&nbsp;So, option (B) is correct.&nbsp;",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 242,
    "Question Text": "A complete, undirected, weighted graph G is given on the vertex {0, 1,...., n\u22121} for any fixed \u2018n\u2019. Draw the minimum spanning tree of G if\r\n\r\na) the weight of the edge (u,v) is \u2223 u\u2212v \u2223\r\nb) the weight of the edge (u,v) is u + v",
    "Option A": "1",
    "Option B": "2",
    "Option C": "3",
    "Option D": "4",
    "Correct Answer": "D",
    "Explanation": "",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 243,
    "Question Text": "Which of the following data structure is useful in traversing a given graph by breadth first search?",
    "Option A": "Stack",
    "Option B": "List",
    "Option C": "Queue",
    "Option D": "None of the above.",
    "Correct Answer": "D",
    "Explanation": "BFS performs level-order traversal which can be fairly done using a queue. A queue uses FIFO ordering and the nodes that we enqueue first are explored first maintaining the order of traversal.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 244,
    "Question Text": "In the following graph, discovery time stamps and finishing time stamps of Depth First Search (DFS) are shown as x/y, where x is discovery time stamp and y is finishing time stamp.\r\n\r\n\r\nIt shows which of the following depth first forest?",
    "Option A": "{a, b, e} {c, d, f, g, h}",
    "Option B": "{a, b, e} {c, d, h} {f, g}",
    "Option C": "{a, b, e} {f, g} {c, d} {h}",
    "Option D": "{a, b, c, d} {e, f, g} {h}",
    "Correct Answer": "B",
    "Explanation": "",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 245,
    "Question Text": "Consider a segment tree built on an array of N elements. What is the minimum number of node updates required to rebuild the entire tree if the original array is reversed?",
    "Option A": "N",
    "Option B": "N - 1",
    "Option C": "2N - 1",
    "Option D": "N log N",
    "Correct Answer": "D",
    "Explanation": "Rebuilding the entire segment tree requires updating each node, and the minimum number of nodes in a segment tree is 2N-1.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 246,
    "Question Text": "Which of the following according to you is incorrect?",
    "Option A": "Trie is also known as prefix tree",
    "Option B": "Trie requires less storage space than hashing",
    "Option C": "Trie allows listing of all the words with same prefix",
    "Option D": "Tries are collision free",
    "Correct Answer": "C",
    "Explanation": "Both the hashing and the trie provides searching in the linear time. But trie requires extra space for storage and it is collision free. And trie allows finding all the strings with same prefix, so it is also called prefix tree. Hence , option B is the correct option.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 247,
    "Question Text": "Which of the following statements about disjoint-set forests is false?",
    "Option A": "Disjoint-set forests can be used to efficiently detect cycles in a graph.",
    "Option B": "Disjoint-set forests can handle disconnected components efficiently.",
    "Option C": "The union operation in disjoint-set forests can be performed in constant time.",
    "Option D": "Disjoint-set forests are commonly used in minimum spanning tree algorithms.",
    "Correct Answer": "D",
    "Explanation": "The union operation in disjoint-set forests, using union by rank and path compression, takes time proportional to the inverse Ackermann function, which is not constant but extremely slow-growing.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 248,
    "Question Text": "In an undirected connected planar graph G, there are eight vertices and five faces. The number of edges in G is _________.",
    "Option A": "10",
    "Option B": "11",
    "Option C": "12",
    "Option D": "6",
    "Correct Answer": "C",
    "Explanation": "By using Euler\u2019s theorem, the number of regions = e - v + 2 \r\nR = e - v + 2\r\n5 = e - 8 + 2 = e-6\r\ne = 5+6 = 11",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 249,
    "Question Text": "Consider the following undirected graph with edge weights as shown: The number of minimum-weight spanning trees of the graph is ___________.",
    "Option A": "3",
    "Option B": "4",
    "Option C": "5",
    "Option D": "2",
    "Correct Answer": "A",
    "Explanation": "There are 3 edges between these components to connect them.  According to Kruskal's algorithm edges with weight 0.1 are significantly lighter. So the MST will consist only of edges with weight 0.1.We will include minimum weights edges first if there is no cycle resultant. But we need only one edge to form spanning tree, and we have 3 options for one edge. Hence, number of spanning trees are 3.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 250,
    "Question Text": "The cyclomatic complexity of the flow graph of a program provides &nbsp;",
    "Option A": "an upper bound for the number of tests that must be conducted to ensure that all statements have been executed at most once",
    "Option B": "a lower bound for the number of tests that must be conducted to ensure that all statements have been executed at most once",
    "Option C": "an upper bound for the number of tests that must be conducted to ensure that all statements have been executed at least once",
    "Option D": "a lower bound for the number of tests that must be conducted to ensure that all statements have been executed at least once",
    "Correct Answer": "D",
    "Explanation": "Option (C) is correct, because the cyclomatic complexity of the flow graph of a program provides an upper bound for the number of tests that must be conducted to ensure that all statements have been executed at least once.",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 251,
    "Question Text": "What is the largest integer m such that every simple connected graph with n vertices and n edges contains at least m different spanning trees?",
    "Option A": "1",
    "Option B": "2",
    "Option C": "3",
    "Option D": "n",
    "Correct Answer": "D",
    "Explanation": "A graph is connected iff all nodes can be traversed from each node. For a graph with n nodes, there will be n-1 minimum number of edges. \r\nGiven that there are n edges, that means a cycle is there in the graph.\r\nThe simplex graph with these conditions may be:\r\n\r\n\r\n\r\nNow we can make a different spanning tree by removing one edge from the cycle, one at a time.\r\nMinimum cycle length can be 3, So, there must be atleast 3 spanning trees in any such Graph.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 252,
    "Question Text": "Which of the following is an advantage of adjacency list representation over adjacency matrix representation of a graph?",
    "Option A": "In adjacency list representation, space is saved for sparse graphs.",
    "Option B": "DFS and BSF can be done in O(V + E) time for adjacency list representation. These operations take O(V^2) time in adjacency matrix representation. Here is V and E are number of vertices and edges respectively.",
    "Option C": "Adding a vertex in adjacency list representation is easier than adjacency matrix representation.",
    "Option D": "All of the above",
    "Correct Answer": "E",
    "Explanation": "See http://www.geeksforgeeks.org/graph-and-its-representations/",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 253,
    "Question Text": "What is the worst case efficiency for a path compression algorithm?",
    "Option A": "O(M log N)",
    "Option B": "O(N log N)",
    "Option C": "O(log N)",
    "Option D": "O(N)",
    "Correct Answer": "B",
    "Explanation": "The worst case efficiency for a path compression algorithm is mathematically found to be O(M log N).\r\nHence , option A is correct.",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 254,
    "Question Text": "Trie is also known as _____",
    "Option A": "Treap",
    "Option B": "Binomial Tree",
    "Option C": "2-3 Tree",
    "Option D": "Digital Tree",
    "Correct Answer": "E",
    "Explanation": "Trie is also known as Digital tree. Hence , option D is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 255,
    "Question Text": "Let G be a weighted undirected graph and e be an edge with maximum weight in G. Suppose there is a minimum weight spanning tree in G containing the edge e. Which of the following statements is always TRUE?\r\n\r\n&nbsp;",
    "Option A": "There exists a cutset in G having all edges of maximum weight.",
    "Option B": "There exists a cycle in G having all edges of maximum weight",
    "Option C": "Edge e cannot be contained in a cycle.",
    "Option D": "All edges in G have the same weight",
    "Correct Answer": "B",
    "Explanation": "Background :  Given a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the vertices together. \r\n\r\n A spanning tree has exactly V - 1 edges.\r\n A single graph can have many different spanning trees. A minimum spanning tree (MST) or minimum weight spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.\r\n There can be more that one possible spanning trees of a graph. For example, the graph in this question has 6 possible spanning trees.\r\n MST has lightest edge of every cutset. Remember Prim's algorithm which basically picks the lightest edge from every cutset. \r\n\r\n\r\nChoices of this question : \r\na) There exists a cutset in G having all edges of maximum weight  : This is correct. If there is a heaviest edge in MST, then there exist a cut with all edges with weight equal to heavies edge.  See point 4 discussed in above background.\r\n\r\n\r\nb) There exists a cycle in G having all edges of maximum weight :  Not always TRUE. The cutset of heaviest edge may contain only one edge.  In fact there may be overall one edge of heavies weight which is part of MST (Consider a graph with two components which are connected by only one edge and this edge is the heavies)\r\n\r\nc) Edge e cannot be contained in a cycle. Not Always True. The curset may form cycle with other edges.\r\n\r\nd) All edges in G have the same weight Not always True. As discussed in option b, there can be only one edge of heaviest weight.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 257,
    "Question Text": "Consider a segment tree built on an array of N elements. What is the time complexity of updating a range of elements in the segment tree?",
    "Option A": "O(log N)",
    "Option B": "O(N)",
    "Option C": "O(log N + K), where K is the number of elements in the range",
    "Option D": "O(N log N)",
    "Correct Answer": "C",
    "Explanation": "Updating a range of elements in a segment tree requires visiting each affected node, resulting in a time complexity of O(N).",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 258,
    "Question Text": "Which of the following operations can be efficiently performed using a segment tree?",
    "Option A": "Finding the longest increasing subsequence in a given range",
    "Option B": "Finding the most frequent element in a given range",
    "Option C": "Finding the number of inversions in a given range",
    "Option D": "Finding the top K elements in a given range",
    "Correct Answer": "D",
    "Explanation": "A segment tree can efficiently find the number of inversions in a given range by performing a modified merge sort algorithm.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 259,
    "Question Text": "The following code snippet is the function to insert a string in a trie. Find the missing line.\n        C++\n        \n        void insert(const std::string &amp;str) {\n    TrieNode *node = root;\n    for (int i = 0; i &lt; str.length(); i++) {\n        int index = str[i] - &#39;a&#39;;\n        if (node-&gt;children[index] == nullptr)\n            node-&gt;children[index] = new TrieNode();\n        // ________________________\n    }\n    node-&gt;isEndOfWord = true;\n}\n\n        \n    \n        C\n        \n        void insert(char *str) {\n    TrieNode *node = root;\n    for (int i = 0; i &lt; length; i++) {\n        int index = str[i] - &#39;a&#39;;\n        if (node-&gt;children[index] == NULL)\n            node-&gt;children[index] = (TrieNode *)malloc(sizeof(TrieNode));\n        _________________________\n    }\n    node-&gt;isEndOfWord = 1;\n}\n\n        \n    \n        Java\n        \n        private void insert(String str){\n   TrieNode node = root;\n   for (int i = 0; i &lt; length; i++){\n       int index = key.charAt(i) - &#39;a&#39;;\n       if (node.children[index] == null)\n          node.children[index] = new TrieNode();\n       ________________________\n   }\n   node.isEndOfWord = true;\n}\n\n        \n    \n        Python\n        \n        def insert(self, str):\n    node = self.root\n    for i in range(len(str)):\n        index = ord(str[i]) - ord(&#39;a&#39;)\n        if node.children[index] is None:\n            node.children[index] = TrieNode()\n        ___________________________\n    node.isEndOfWord = True\n\n        \n    \n        JavaScript\n        \n        insert(str) {\n    let node = this.root;\n    for (let i = 0; i &lt; str.length; i++) {\n        let index = str.charCodeAt(i) - &#39;a&#39;.charCodeAt(0);\n        if (node.children[index] === null)\n            node.children[index] = new TrieNode();\n        ____________________________\n    }\n    node.isEndOfWord = true;\n}",
    "Option A": "node = node.children[index];",
    "Option B": "&nbsp;node = node.children[str.charAt(i + 1)];",
    "Option C": "node = node.children[index++];",
    "Option D": "node = node.children[index++];",
    "Correct Answer": "A",
    "Explanation": "After checking if the current node has a child at the given index, we need to move to the next node in the trie. The missing line moves the current target node to next node after checking the current node. node = node-&gt;children[index]; / node = node.children[index];Hence (A) is the correct option.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 260,
    "Question Text": "Which of the following is not true?",
    "Option A": "Trie requires less storage space than hashing",
    "Option B": "Trie allows listing of all the words with same prefix",
    "Option C": "Tries are collision free",
    "Option D": "Trie is also known as prefix tree",
    "Correct Answer": "B",
    "Explanation": "",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 261,
    "Question Text": "Given a disjoint-set forest with N elements, what is the maximum height of the trees in the forest after M union operations if union by rank and path compression techniques are used?",
    "Option A": "O(M)",
    "Option B": "O(logM)",
    "Option C": "O(N)",
    "Option D": "O(N + M)",
    "Correct Answer": "C",
    "Explanation": "Using union by rank and path compression, the maximum height of the trees in the forest after M union operations is logarithmic with respect to M, resulting in a time complexity of O(log M).",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 262,
    "Question Text": "Which of the following ways can be used to represent a graph?",
    "Option A": "Adjacency List and Adjacency Matrix",
    "Option B": "Incidence Matrix&nbsp;",
    "Option C": "Adjacency List, Adjacency Matrix and Incidence Matrix",
    "Option D": "None of the above",
    "Correct Answer": "D",
    "Explanation": "Adjacency Matrix, Adjacency List and Incidence Matrix are used to represent a graph.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 263,
    "Question Text": "For a given graph G having v vertices and e edges which is connected and has no cycles, which of the following statements is true?",
    "Option A": "v=e&nbsp;",
    "Option B": "v = e+1",
    "Option C": "v + 1 = e",
    "Option D": "v = e-1",
    "Correct Answer": "C",
    "Explanation": "For any connected graph with no cycles the equation holds true.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 264,
    "Question Text": "Which of the following is true?&nbsp;",
    "Option A": "A graph may contain no edges and many vertices",
    "Option B": "A graph may contain many edges and one vertex",
    "Option C": "A graph may contain no edges and no vertices",
    "Option D": "A graph may contain no vertices and many edges",
    "Correct Answer": "C",
    "Explanation": "A graph must contain at least one vertex.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 265,
    "Question Text": "Time Complexity of DFS is? (V \u2013 number of vertices, E \u2013 number of edges)",
    "Option A": "O(V + E)",
    "Option B": "O(V)",
    "Option C": "O(E)",
    "Option D": "O(V*E)",
    "Correct Answer": "B",
    "Explanation": "The Depth First Search explores every node once and every edge once (in worst case), so it\u2019s time complexity is O(V + E).",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 266,
    "Question Text": "A person wants to visit some places. He starts from a vertex and then wants to visit every vertex till it finishes from one vertex, backtracks and then explore other vertex from same vertex. What algorithm he should use?",
    "Option A": "Depth First Search",
    "Option B": "Breadth First Search",
    "Option C": "Trim\u2019s algorithm",
    "Option D": "Kruskal\u2019s Algorithm",
    "Correct Answer": "B",
    "Explanation": "This is the definition of the Depth First Search. Exploring a node, then aggressively finding nodes till it is not able to find any node.",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 267,
    "Question Text": "A bridge cannot be a part of&nbsp;",
    "Option A": "a simple cycle&nbsp;",
    "Option B": "a tree",
    "Option C": "a clique with size&gt;=3 whose every edge is a bridge",
    "Option D": "a graph which contains cycle",
    "Correct Answer": "B",
    "Explanation": "In a connected graph, a bridge is an edge whose removal disconnects the graph. In a cycle if we remove an edge, it will still be connected. So, bridge cannot be a part of cycle.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 268,
    "Question Text": "Which of the following is the most commonly used data structure for implementing Dijkstra\u2019s Algorithm?",
    "Option A": "Max priority queue",
    "Option B": "Stack",
    "Option C": "Circular queue",
    "Option D": "Min priority queue",
    "Correct Answer": "E",
    "Explanation": "Minimum priority queue is the most commonly used data structure for implementing Dijkstra\u2019s Algorithm because the required operations to be performed in Dijkstra\u2019s Algorithm match with specialty of a minimum priority queue.",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 269,
    "Question Text": "What is the time complexity of Dijkstra\u2019s algorithm?",
    "Option A": "O(N)",
    "Option B": "O(N3)",
    "Option C": "O(N2)",
    "Option D": "O(logN)",
    "Correct Answer": "D",
    "Explanation": "Time complexity of Dijkstra\u2019s algorithm is O(N2) because of the use of doubly nested for loops. It depends on how the table is manipulated.",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 270,
    "Question Text": "In most of the cases, topological sort starts from a node which has __________",
    "Option A": "Maximum Degree",
    "Option B": "Minimum Degree",
    "Option C": "Any degree",
    "Option D": "Zero Degree",
    "Correct Answer": "E",
    "Explanation": "Topological sort starts with a node which has zero degree. If multiple such nodes exists then it can start with any node.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 271,
    "Question Text": "Topological sort can be implemented by?",
    "Option A": "Using Depth First Search",
    "Option B": "Using Breadth First Search",
    "Option C": "Using Depth and Breadth First Search",
    "Option D": "Using level ordered search",
    "Correct Answer": "D",
    "Explanation": "We can implement topological sort by both BFS and DFS. In BFS, we use queue as data structure and in DFS, we use Linked list (if recursive) or Stack (if not recursive) as data structure.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 272,
    "Question Text": "Which of the following algorithms can be used to most efficiently determine the presence of a cycle in a given graph ?",
    "Option A": "Depth First Search",
    "Option B": "Breadth First Search",
    "Option C": "Prim\\'s Minimum Spanning Tree Algorithm",
    "Option D": "Kruskal\\' Minimum Spanning Tree Algorithm",
    "Correct Answer": "B",
    "Explanation": "To find cycle in a graph we can use the Depth First Traversal (DFS) technique. It is based on the idea that there is a cycle in a graph only if there is a back edge [i.e., a node points to one of its ancestors] present in the graph.To detect a back edge, we need to keep track of the nodes visited till now and the nodes that are in the current recursion stack [i.e., the current path that we are visiting]. If during recursion, we reach a node that is already in the recursion stack, there is a cycle present in the graph.Hence Option (A) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 273,
    "Question Text": "Traversal of a graph is different from tree because",
    "Option A": "There can be a loop in graph so we must maintain a visited flag for every vertex",
    "Option B": "DFS of a graph uses stack, but inorder traversal of a tree is recursive",
    "Option C": "BFS of a graph uses queue, but a time efficient BFS of a tree is recursive.",
    "Option D": "All of the above",
    "Correct Answer": "B",
    "Explanation": "Depth First Traversal (or DFS) for a graph is similar to Depth First Traversal of a tree. The only catch here is, that, unlike trees, graphs may contain cycles (a node may be visited twice). To avoid processing a node more than once, use a boolean visited array. A graph can have more than one DFS traversal.Hence Option (A) is the correct answer.&nbsp;",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 274,
    "Question Text": "What are the appropriate data structures for following algorithms?\n\n1) Breadth-First Search &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;2) Depth First Search&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;3) Prim's Minimum Spanning Tree &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;4) Kruskal' Minimum Spanning Tree &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;",
    "Option A": "&nbsp;Stack&nbsp;QueuePriority QueueUnion Find",
    "Option B": "QueueStackPriority QueueUnion Find",
    "Option C": "StackQueueUnion FindPriority Queue&nbsp;",
    "Option D": "Priority QueueQueueStackUnion Find",
    "Correct Answer": "C",
    "Explanation": "&nbsp;Breadth First Search uses Queue&nbsp;&nbsp;Depth First Search uses Stack&nbsp;&nbsp;Prim's Minimum Spanning Tree uses Priority Queue.&nbsp;&nbsp;Kruskal' Minimum Spanning Tree uses Union Find.\nHence Option(B) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 275,
    "Question Text": "The Breadth First Search algorithm has been implemented using the queue data structure. One possible order of visiting the nodes of the following graph is&nbsp;&nbsp;&nbsp;",
    "Option A": "MNOPQR",
    "Option B": "NQMPOR",
    "Option C": "QMNPRO",
    "Option D": "QMNPOR",
    "Correct Answer": "D",
    "Explanation": "Option (A) is MNOPQR. It cannot be a BFS as the traversal starts with M, but O is visited before N and Q. In BFS all adjacent must be visited before adjacent of adjacent. Option (B) is NQMPOR. It also cannot be BFS, because here, P is visited before O. (C) and (D) match up to QMNP. We see that M was added to the queue before N and P (because M comes before NP in QMNP). Because R is M's neighbor, it gets added to the queue before the neighbor of N and P (which is O). Thus, R is visited before O.\n\nHence (C) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 2.5,
    "Discrimination": 2.5,
    "Guessing Probability": 0.2
  },
  {
    "Question ID": 276,
    "Question Text": "Let G be an undirected graph. Consider a depth-first traversal of G, and let T be the resulting depth-first search tree. Let u be a vertex in G and let v be the first new (unvisited) vertex visited after visiting u in the traversal. Which of the following statements is always true? (GATE CS 2000)",
    "Option A": "{u,v} must be an edge in G, and u is a descendant of v in T",
    "Option B": "{u,v} must be an edge in G, and v is a descendant of u in T",
    "Option C": "If {u,v} is not an edge in G then u is a leaf in T",
    "Option D": "If {u,v} is not an edge in G then u and v must have the same parent in T",
    "Correct Answer": "D",
    "Explanation": "In DFS, if 'v' is visited\nafter 'u', then one of the following is true.\n1) (u, v) is an edge.\n     u\n   /   \\\n  v     w\n /     / \\\nx     y   z\n\n2) 'u' is a leaf node.\n     w\n   /   \\\n  x     v\n /     / \\\nu     y   z \nIn DFS, after visiting a node, we first recur for all unvisited children. If there are no unvisited children (u is leaf), then control goes back to parent and parent then visits next unvisited children.\n\nHence (C) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 277,
    "Question Text": "Consider the following graph,\r\n\n\n\r\n\r\nAmong the following sequences:\r\n(I) a b e g h f \r\n(II) a b f e h g\r\n(III) a b f h g e \r\n(IV) a f g h b e  \r\nWhich are depth first traversals of the above graph?",
    "Option A": "I, II and IV only",
    "Option B": "I and IV only",
    "Option C": "II, III and IV only",
    "Option D": "I, III and IV only",
    "Correct Answer": "E",
    "Explanation": "We can check all DFSs for following properties.\r\n\r\nIn DFS, if a vertex 'v' is visited\r\nafter 'u', then one of the following is true.\r\n1) (u, v) is an edge.\r\n     u\r\n   /   \\\r\n  v     w\r\n /     / \\\r\nx     y   z\r\n\r\n2) 'u' is a leaf node.\r\n     w\r\n   /   \\\r\n  x     v\r\n /     / \\\r\nu     y   z\r\nIn DFS, after visiting a node, we first recur for all unvisited children. If there are no unvisited children (u is leaf), then control goes back to parent and parent then visits next unvisited children.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 278,
    "Question Text": "Which of the following condition is sufficient to detect cycle in a directed graph?",
    "Option A": "There is an edge from currently being visited node to an already visited node.",
    "Option B": "There is an edge from currently being visited node to an ancestor of currently visited node in DFS forest.",
    "Option C": "Every node is seen twice in DFS.",
    "Option D": "None of the above",
    "Correct Answer": "C",
    "Explanation": "To find cycle in a directed graph we can use the Depth First Traversal (DFS) technique. It is based on the idea that there is a cycle in a graph only if there is a back edge [i.e., a node points to one of its ancestors] present in the graph.To detect a back edge, we need to keep track of the nodes visited till now and the nodes that are in the current recursion stack [i.e., the current path that we are visiting]. If during recursion, we reach a node that is already in the recursion stack, there is a cycle present in the graph.If the graph is disconnected then get the DFS forest and check for a cycle in individual trees by checking back edges.Hence Option(B) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 279,
    "Question Text": "Is following statement true/false If a DFS of a directed graph contains a back edge, any other DFS of the same graph will also contain at least one back edge.",
    "Option A": "TRUE",
    "Option B": "FALSE",
    "Option C": "",
    "Option D": "",
    "Correct Answer": "B",
    "Explanation": "A back edge means a cycle in graph. So if there is a cycle, all DFS traversals would contain at least one back edge.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 280,
    "Question Text": "Make is a utility that automatically builds executable programs and libraries from source code by reading files called makefiles which specify how to derive the target program. Which of the following standard graph algorithms is used by Make.",
    "Option A": "Strongly Connected Components",
    "Option B": "Topological Sorting",
    "Option C": "Breadth First Search",
    "Option D": "Dijkstra\\'s Shortest Path",
    "Correct Answer": "C",
    "Explanation": "Make can decide the order of building software using topological sorting. Topological sorting produces the order considering all dependencies provide by makefile. See following for details. Topological SortingHence Option(B) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 281,
    "Question Text": "Given two vertices in a graph s and t, which of the two traversals (BFS and DFS) can be used to find if there is path from s to t?",
    "Option A": "Only BFS",
    "Option B": "Only DFS",
    "Option C": "Both BFS and DFS",
    "Option D": "Neither BFS nor DFS",
    "Correct Answer": "D",
    "Explanation": "We can use both traversals to find if there is a path from s to t.Hence Option(C) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 282,
    "Question Text": "Is the following statement true/false? A DFS of a directed graph always produces the same number of tree edges, i.e., independent of the order in which vertices are considered for DFS.&nbsp;",
    "Option A": "TRUE",
    "Option B": "FALSE",
    "Option C": "",
    "Option D": "",
    "Correct Answer": "C",
    "Explanation": "The statement is false.A Depth-First Search (DFS) of a directed graph can produce a different number of tree edges depending on the order in which vertices are considered for the DFS. The number of tree edges in a DFS tree depends on the specific traversal path taken during the DFS.During a DFS, starting from a particular source vertex, the traversal explores the graph by visiting neighboring vertices in a systematic way. The order in which the neighboring vertices are visited impacts the formation of the DFS tree.Hence (B) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 283,
    "Question Text": "If the DFS finishing time f[u] &gt; f[v] for two vertices u and v in a directed graph G, and u and v are in the same DFS tree in the DFS forest, then u is an ancestor of v in the depth-first tree.",
    "Option A": "TRUE",
    "Option B": "FALSE",
    "Option C": "",
    "Option D": "",
    "Correct Answer": "C",
    "Explanation": "In a graph with three nodes, r u, and v, with edges (r; u) and (r; v), and r is the starting point for the DFS, u and v are siblings in the DFS tree, neither as the ancestor of the other.Hence the above statement si false.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 284,
    "Question Text": "Consider the DAG with Consider V = {1, 2, 3, 4, 5, 6}, shown below. Which of the following is NOT a topological ordering?&nbsp;",
    "Option A": "1 2 3 4 5 6",
    "Option B": "1 3 2 4 5 6",
    "Option C": "1 3 2 4 6 5",
    "Option D": "3 2 4 1 6 5",
    "Correct Answer": "D",
    "Explanation": "In option D, 1 appears after 2 and 3 which is not possible in Topological Sorting. In the given DAG it is directly visible that there is an outgoing edge from vertex 1 to vertex 2 and 3 hence 2 and 3 cannot come before vertex 1 so clearly option D is an incorrect topological sort. But for questions in which it is not directly visible, we should know how to find a topological sort of a DAG.&nbsp; Hence Option(D) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 285,
    "Question Text": "Let G be a graph with n vertices and m edges. What is the tightest upper bound on the running time on Depth First Search of G? Assume that the graph is represented using adjacency matrix.",
    "Option A": "O(n)",
    "Option B": "O(m+n)",
    "Option C": "O(n2)",
    "Option D": "O(mn)",
    "Correct Answer": "D",
    "Explanation": "Depth First Search of a graph takes O(m+n) time when the graph is represented using adjacency list.\r\n\r\nIn adjacency matrix representation, graph is represented as an \"n x n\" matrix.  To do DFS, for every vertex, we traverse the row corresponding to that vertex to find all adjacent vertices (In adjacency list representation we traverse only the adjacent vertices of the vertex). Therefore time complexity becomes O(n2)",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 286,
    "Question Text": "Consider the tree arcs of a BFS traversal from a source node W in an unweighted, connected, undirected graph. The tree T formed by the tree arcs is a data structure for computing.",
    "Option A": "the shortest path between every pair of vertices.",
    "Option B": "the shortest path from W to every vertex in the graph.",
    "Option C": "the shortest paths from W to only those nodes that are leaves of T.",
    "Option D": "the longest path in the graph",
    "Correct Answer": "C",
    "Explanation": "Explanation:&nbsp;The correct answer is (B) the shortest path from W to every vertex in the graph. When performing a Breadth First Search (BFS) traversal from a source node W in an unweighted, connected, undirected graph, the tree T formed by the tree arcs represents the shortest path from W to every other vertex in the graph.&nbsp;BFS explores the graph level by level, starting from the source node W. As it traverses the graph, it discovers the vertices in increasing order of their distance from W. The tree arcs in the resulting tree T represent the shortest paths from W to each vertex, as BFS ensures that the vertices are visited in the order of their distance from the source.&nbsp;Option (A) the shortest path between every pair of vertices is not correct because the tree T only represents the shortest path from W to every vertex, not between all pairs of vertices in the graph.&nbsp;Option (C) the shortest paths from W to only those nodes that are leaves of T is also not correct. The tree T formed by BFS includes all vertices reachable from W, not just the leaves of the tree. It represents the shortest path to every vertex, regardless of whether it is a leaf or an internal node in the tree.&nbsp;Option (D) the longest path in the graph is also not correct. BFS does not provide information about the longest path in the graph. It focuses on finding the shortest paths from the source node W to other vertices, not the longest paths. Therefore, the correct answer is (B) the shortest path from W to every vertex in the graph.Quiz of this Question",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 287,
    "Question Text": "Suppose depth first search is executed on the graph below starting at some unknown vertex. Assume that a recursive call to visit a vertex is made only after first checking that the vertex has not been visited earlier. Then the maximum possible recursion depth (including the initial call) is _________.",
    "Option A": "17",
    "Option B": "18",
    "Option C": "19",
    "Option D": "20",
    "Correct Answer": "D",
    "Explanation": "The following diagram shows the worst case situation where the recursion tree has maximum depth.  \r\n\r\n\r\n\r\nSo the recursion depth is 19 (including the first node).",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 288,
    "Question Text": "Let T be a depth first search tree in an undirected graph G. Vertices u and n are leaves of this tree T. The degrees of both u and n in G are at least 2. which one of the following statements is true?",
    "Option A": "There must exist a vertex w adjacent to both u and n in G",
    "Option B": "There must exist a vertex w whose removal disconnects u and n in G",
    "Option C": "There must exist a cycle in G containing u and n",
    "Option D": "There must exist a cycle in G containing u and all its neighbours in G.",
    "Correct Answer": "E",
    "Explanation": "Below example shows that A and B are FALSE:\r\n\r\n\r\nBelow example shows C is false:",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 289,
    "Question Text": "Let G be an undirected graph. Consider a depth-first traversal of G, and let T be the resulting depth-first search tree. Let u be a vertex in G and let v be the first new (unvisited) vertex visited after visiting u in the traversal. Which of the following statements is always true?",
    "Option A": "{u,v} must be an edge in G, and u is a descendant of v in T",
    "Option B": "{u,v} must be an edge in G, and v is a descendant of u in T",
    "Option C": "If {u,v} is not an edge in G then u is a leaf in T",
    "Option D": "If {u,v} is not an edge in G then u and v must have the same parent in T",
    "Correct Answer": "D",
    "Explanation": "In DFS, if 'v' is visited\r\nafter 'u', then one of the following is true.\r\n1) (u, v) is an edge.\r\n     u\r\n   /   \\\r\n  v     w\r\n /     / \\\r\nx     y   z\r\n\r\n2) 'u' is a leaf node.\r\n     w\r\n   /   \\\r\n  x     v\r\n /     / \\\r\nu     y   z \r\nIn DFS, after visiting a node, we first recur for all unvisited children.  If there are no unvisited children (u is leaf), then control goes back to parent and parent then visits next unvisited children.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 290,
    "Question Text": "In a depth-first traversal of a graph G with n vertices, k edges are marked as tree edges. The number of connected components in G is",
    "Option A": "k",
    "Option B": "k + 1",
    "Option C": "n - k - 1",
    "Option D": "n - k",
    "Correct Answer": "E",
    "Explanation": "Tree edges are the edges that are part of DFS tree.\u00a0 If there are x tree edges in a tree, then\u00a0 x+1 vertices in the tree.\r\n\r\nThe output of DFS is a forest if the graph is disconnected.\u00a0 Let us see below simple example where graph is disconnected.\r\n\r\n\r\n\r\n&nbsp;\r\n\r\nThe above example matches with D option\r\n\r\nMore Examples:\r\n\r\n1) All vertices\u00a0 of Graph are connected.\u00a0 k must be n-1.\u00a0 We get number of connected components\u00a0 = n- k =\u00a0 n - (n-1) = 1\r\n\r\n2) No vertex is connected. k must be 0.\u00a0 We get number of connected components\u00a0 = n- k =\u00a0 n - 0 = n",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 291,
    "Question Text": "Consider the following directed graph.  The number of different topological orderings of the vertices of the graph is &nbsp; Note : This question was asked as Numerical Answer Type.",
    "Option A": "1",
    "Option B": "2",
    "Option C": "4",
    "Option D": "6",
    "Correct Answer": "E",
    "Explanation": "Following are different 6 Topological Sortingsa-b-c-d-e-f\na-d-e-b-c-f\na-b-d-c-e-f\na-d-b-c-e-f\na-b-d-e-c-f\na-d-b-e-c-f",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 292,
    "Question Text": "In an adjacency list representation of an undirected simple graph G = (V, E), each edge (u, v) has two adjacency list entries: [v] in the adjacency list of u, and [u] in the adjacency list of v. These are called twins of each other. A twin pointer is a pointer from an adjacency list entry to its twin. If |E| = m and |V | = n, and the memory size is not a constraint, what is the time complexity of the most efficient algorithm to set the twin pointer in each entry in each adjacency list?",
    "Option A": "\u0398(n2)",
    "Option B": "\u0398(m+n)",
    "Option C": "\u0398(m2)",
    "Option D": "\u0398(n4)",
    "Correct Answer": "C",
    "Explanation": "First you need to find twins of each node. You can do this using level order traversal (i.e., BFS) once. Time complexity of BFS is \u0398(m +n).\r\nAnd you have to use linked list for representation which is extra space (but memory size is not a constraint here).\r\nFinal, time complexity is \u0398(m + n) to set twin pointer.\r\n\r\nOption (B) is correct.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 293,
    "Question Text": "Let  G = (V, G) be a weighted undirected graph and let T be a Minimum Spanning Tree (MST) of G maintained using adjacency lists. Suppose a new weighed edge (u, v) \u2208 V\u00d7V is added to G. The worst case time complexity of determining if T is still an MST of the resultant graph is",
    "Option A": "\u0398(\u2223E\u2223 + \u2223V\u2223)",
    "Option B": "\u0398(\u2223E\u2223.\u2223V\u2223)",
    "Option C": "\u0398(E\u2223 log \u2223V\u2223)",
    "Option D": "\u0398(\u2223V\u2223)",
    "Correct Answer": "D",
    "Explanation": "In a graph with distinct edge weights, BFS cannot be directly applied for this purpose. Here's an alternative approach:For a minimum spanning tree (MST) with V vertices, there are V\u22121 edges. Traversing the adjacency list has a time complexity of O(V+E), and since we are dealing with V\u22121 edges, the traversal effectively takes O(V) time.The tree is given instead of the Entire graph and in a tree E=V-1, Hence TC = [Tex]\\theta[/Tex](V + E) = [Tex]\\Theta[/Tex](V + V-1) = \u0398(V)While traversing the adjacency list of T, compare the weight of the newly added edge with the weights of the edges in the MST. If the new edge has a smaller weight, the MST will be updated. Otherwise, no changes are needed.Thus, the time complexity of this process is O(V).",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 294,
    "Question Text": "An articulation point in a connected graph is a vertex such that removing the vertex and its incident edges disconnects the graph into two or more connected components.&nbsp;Let T be a DFS tree obtained by doing DFS in a connected undirected graph G. Which of the following options is/are correct?",
    "Option A": "Root of T can never be an articulation point in G.",
    "Option B": "Root of T is an articulation point in G if and only if it has 2 or more children.",
    "Option C": "A leaf of T can be an articulation point in G.",
    "Option D": "If u is an articulation point in G such that x is an ancestor of u in T and y is a descendent of u in T, then all paths from x to y in G must pass through u.",
    "Correct Answer": "C",
    "Explanation": "We check all the options one by one:Option (A): Root of T can never be an articulation point in G. This option is FALSE.Look at the following DFS tree T of a graph G:When root can be an articulation pointWe can clearly see that removing the vertex corresponding to the root of T, will disconnect the graph into two components. Thus the root of T can be an articulation point in G.Option (B): Root of T is an articulation point in G if and only if it has 2 or more children. This option is TRUE.From the above example and the following tree:Root can be an articulation iff there are 2 or more childrenThe root of T has 1 child, and as such removing its corresponding vertex in G does not disconnect the graph into two (or more) components. Thus the root can not be an articulation point in this scenario. Therefore having at least 2 children is a compulsory condition for the root of T to be an articulation point.Option (C): A leaf of T can be an articulation point in G. This option is FALSE.From the tree T below:&nbsp;We can understand that any leaf of T is connected to only one node, i.e. its parent. Thus removing the vertex corresponding to T in the graph will not disconnect the graph into two or more components. So, a leaf of T can never be an articulation point in G.Option (D): If u is an articulation point in G such that x is an ancestor of u in T and y is a descendant of u in T, then all paths from x to y in G must pass through u. This option is FALSE.Let us take an example of a graph G:&nbsp;For this graph G, we can verify that in T (obtained by doing DFS): u is an articulation point in G, x is an ancestor of u and y is a descendent of u. All the conditions are satisfied, yet we have a path from x to y in G (x-&gt;w-&gt;v-&gt;y) that does not pass through u.Thus the only correct option is B.Articulation points in a graph are found using the Depth First Search (https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/).Quiz of this Question",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 295,
    "Question Text": "Consider the following directed graph:Which of the following is/are correct about the graph?",
    "Option A": "The graph does not have a topological order",
    "Option B": "A depth-first traversal starting at vertex S classifies three directed edges as back edges",
    "Option C": "The graph does not have a strongly connected component",
    "Option D": "For each pair of vertices u and v, there is a directed path from u to v",
    "Correct Answer": "A",
    "Explanation": "(A) True, because of cycle in the bottom left corner of the graph.  (B) True, we can come back length of 3 edges.  (C)  The graph does have a strongly connected component, it has cycle.  (D) False, not a strongly connected graph.",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 296,
    "Question Text": "In a directed acyclic graph with a source vertex s, the quality-score of a directed path is defined to be the product of the weights of the edges on the path. Further, for a vertex v other than s, the quality-score of v is defined to be the maximum among the quality-scores of all the paths from s to v. The quality-score of s is assumed to be 1.\r\n\r\n\r\n\r\nThe sum of the quality-scores of all vertices on the graph shown above is _______ .",
    "Option A": "929",
    "Option B": "81",
    "Option C": "729",
    "Option D": "1023",
    "Correct Answer": "B",
    "Explanation": "Let Q(V) denote the quality-score of vertex V.\r\r\nQ(S) = 1 (Given)\r\nQ(C) = 1 (S \u2192 C)\r\nQ(F) = 1 * 9 (S  \u2192 C  \u2192 F)\r\nQ(A) = 9 (S  \u2192 A)\r\nQ(D) = 9*1 (S  \u2192 A  \u2192 D)\r\nQ(G) = 9 * 1 * 9 (S  \u2192 A  \u2192 D  \u2192 G)\r\nQ(B) = 9 * 1 (S  \u2192 A  \u2192 B)\r\nQ(E) = 9 * 1 * 9 (S  \u2192 A  \u2192 D  \u2192 E)\r\nQ(T) = 9*1*9*9 (S  \u2192 A  \u2192 D  \u2192 E \u2192 T) \r\n\r\nSum of quality-score of all vertices, \r\n\r\n= 1 + 1 + 9 + 9 + 9 + 81 + 9 + 81 + 729 \r\n= 929",
    "Concept": "Graph",
    "Difficulty": 0.5,
    "Discrimination": 0.5,
    "Guessing Probability": 0.27
  },
  {
    "Question ID": 297,
    "Question Text": "Consider a complete binary tree with 7 nodes. Let A denote the set of first 3 elements obtained by performing Breadth-First Search (BFS) starting from the root. Let B denote the set of first 3 elements obtained by performing Depth-First Search (DFS) starting from the root.  The value of \u2223A\u2212B\u2223 is _____________ .",
    "Option A": "1",
    "Option B": "2",
    "Option C": "3",
    "Option D": "4",
    "Correct Answer": "A",
    "Explanation": "In case of BFS if we draw complete binary tree then in Set A we have level1+level2. In DFS we have level1+ level 2 + level 3. Level 1 = 1 element, level 2 = 2 elements, level 3= 4 elements. Total of 7 elements. Set A have: Level 1 = 1st element, Level 2 = 2nd &amp; 3rd element.Set B have: Level 1 = 1 element, level 2 = 2nd element, level 3= 3rd element.L1 x 1 element from L2 (A \u2229 B) Element in A not in B.So A-B= remaining element of level 2. |A - B = 1|",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 298,
    "Question Text": "For a given graph G having v vertices and e edges which is connected and has no cycles, which of the following statements is true?",
    "Option A": "v= e-1",
    "Option B": "e= v-2",
    "Option C": "v=e+1",
    "Option D": "",
    "Correct Answer": "D",
    "Explanation": "For a given graph G is connected, has no cycles (also called acyclic), and has v - 1 edges. Since G is connected and has no cycles, and the number of edges (e) is v - 1, it satisfies the definition of a tree. Trees are fundamental data structures in graph theory and have important applications in computer science and various other fields.The number of edges e= v-1 or v= e+1.Hence Option(C) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 299,
    "Question Text": "Which data structure is commonly used to implement the navigation system in a mapping application, helping users find the shortest route between locations?",
    "Option A": "Heap",
    "Option B": "Stack",
    "Option C": "Graph",
    "Option D": "Queue",
    "Correct Answer": "D",
    "Explanation": "The data structure commonly used to implement the navigation system in a mapping application, helping users find the shortest route between locations, is a graph.Hence Option (C) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 300,
    "Question Text": "Identify the following Representation of the graph.",
    "Option A": "Adjacency List",
    "Option B": "Adjacency Matrix",
    "Option C": "Both",
    "Option D": "",
    "Correct Answer": "B",
    "Explanation": "The above representation is the Adjacency matrix of the graph.Hence Option(B) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  },
  {
    "Question ID": 301,
    "Question Text": "Which of the following statement is correct?P1: Every tree will always be a graphP2: Every graph will always be trees.P3: Every tree will be a graph, but every graph will not be a treeP4: Every graph will be a tree, but every tree will not be a graph.",
    "Option A": "P1 and P2",
    "Option B": "P1",
    "Option C": "P2",
    "Option D": "P1 and P3",
    "Correct Answer": "E",
    "Explanation": "Trees are the restricted types of graphs, just with some more rules. Every tree will always be a graph but not all graphs will be trees. Linked List, Trees, and Heaps all are special cases of graphs.&nbsp;&nbsp;Hence Option(D) is the correct answer.",
    "Concept": "Graph",
    "Difficulty": 1.5,
    "Discrimination": 1.5,
    "Guessing Probability": 0.25
  }
]
